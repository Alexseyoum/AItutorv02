
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model StudentActivity
 * 
 */
export type StudentActivity = $Result.DefaultSelection<Prisma.$StudentActivityPayload>
/**
 * Model LearningStreak
 * 
 */
export type LearningStreak = $Result.DefaultSelection<Prisma.$LearningStreakPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model ChatSession
 * 
 */
export type ChatSession = $Result.DefaultSelection<Prisma.$ChatSessionPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model SATStudyPlan
 * 
 */
export type SATStudyPlan = $Result.DefaultSelection<Prisma.$SATStudyPlanPayload>
/**
 * Model SATPracticeSession
 * 
 */
export type SATPracticeSession = $Result.DefaultSelection<Prisma.$SATPracticeSessionPayload>
/**
 * Model SATDiagnosticResult
 * 
 */
export type SATDiagnosticResult = $Result.DefaultSelection<Prisma.$SATDiagnosticResultPayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model MockExam
 * 
 */
export type MockExam = $Result.DefaultSelection<Prisma.$MockExamPayload>
/**
 * Model MockAttempt
 * 
 */
export type MockAttempt = $Result.DefaultSelection<Prisma.$MockAttemptPayload>
/**
 * Model TopicMastery
 * 
 */
export type TopicMastery = $Result.DefaultSelection<Prisma.$TopicMasteryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const LearningStyle: {
  VISUAL: 'VISUAL',
  AUDITORY: 'AUDITORY',
  KINESTHETIC: 'KINESTHETIC',
  READING_WRITING: 'READING_WRITING',
  MIXED: 'MIXED'
};

export type LearningStyle = (typeof LearningStyle)[keyof typeof LearningStyle]


export const DifficultyLevel: {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED'
};

export type DifficultyLevel = (typeof DifficultyLevel)[keyof typeof DifficultyLevel]


export const ActivityType: {
  CHAT_MESSAGE: 'CHAT_MESSAGE',
  QUIZ_COMPLETED: 'QUIZ_COMPLETED',
  TOPIC_STUDIED: 'TOPIC_STUDIED',
  PROBLEM_SOLVED: 'PROBLEM_SOLVED',
  SESSION_COMPLETED: 'SESSION_COMPLETED',
  EXPLANATION_REQUESTED: 'EXPLANATION_REQUESTED'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const AchievementCategory: {
  STREAK: 'STREAK',
  PROBLEM_SOLVING: 'PROBLEM_SOLVING',
  SUBJECT_MASTERY: 'SUBJECT_MASTERY',
  ENGAGEMENT: 'ENGAGEMENT',
  MILESTONE: 'MILESTONE'
};

export type AchievementCategory = (typeof AchievementCategory)[keyof typeof AchievementCategory]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type LearningStyle = $Enums.LearningStyle

export const LearningStyle: typeof $Enums.LearningStyle

export type DifficultyLevel = $Enums.DifficultyLevel

export const DifficultyLevel: typeof $Enums.DifficultyLevel

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type AchievementCategory = $Enums.AchievementCategory

export const AchievementCategory: typeof $Enums.AchievementCategory

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Posts
 * const posts = await prisma.post.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Posts
   * const posts = await prisma.post.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentActivity`: Exposes CRUD operations for the **StudentActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentActivities
    * const studentActivities = await prisma.studentActivity.findMany()
    * ```
    */
  get studentActivity(): Prisma.StudentActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learningStreak`: Exposes CRUD operations for the **LearningStreak** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningStreaks
    * const learningStreaks = await prisma.learningStreak.findMany()
    * ```
    */
  get learningStreak(): Prisma.LearningStreakDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatSession`: Exposes CRUD operations for the **ChatSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatSessions
    * const chatSessions = await prisma.chatSession.findMany()
    * ```
    */
  get chatSession(): Prisma.ChatSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sATStudyPlan`: Exposes CRUD operations for the **SATStudyPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SATStudyPlans
    * const sATStudyPlans = await prisma.sATStudyPlan.findMany()
    * ```
    */
  get sATStudyPlan(): Prisma.SATStudyPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sATPracticeSession`: Exposes CRUD operations for the **SATPracticeSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SATPracticeSessions
    * const sATPracticeSessions = await prisma.sATPracticeSession.findMany()
    * ```
    */
  get sATPracticeSession(): Prisma.SATPracticeSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sATDiagnosticResult`: Exposes CRUD operations for the **SATDiagnosticResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SATDiagnosticResults
    * const sATDiagnosticResults = await prisma.sATDiagnosticResult.findMany()
    * ```
    */
  get sATDiagnosticResult(): Prisma.SATDiagnosticResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mockExam`: Exposes CRUD operations for the **MockExam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MockExams
    * const mockExams = await prisma.mockExam.findMany()
    * ```
    */
  get mockExam(): Prisma.MockExamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mockAttempt`: Exposes CRUD operations for the **MockAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MockAttempts
    * const mockAttempts = await prisma.mockAttempt.findMany()
    * ```
    */
  get mockAttempt(): Prisma.MockAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topicMastery`: Exposes CRUD operations for the **TopicMastery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TopicMasteries
    * const topicMasteries = await prisma.topicMastery.findMany()
    * ```
    */
  get topicMastery(): Prisma.TopicMasteryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Post: 'Post',
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    StudentActivity: 'StudentActivity',
    LearningStreak: 'LearningStreak',
    Achievement: 'Achievement',
    ChatSession: 'ChatSession',
    ChatMessage: 'ChatMessage',
    SATStudyPlan: 'SATStudyPlan',
    SATPracticeSession: 'SATPracticeSession',
    SATDiagnosticResult: 'SATDiagnosticResult',
    Question: 'Question',
    MockExam: 'MockExam',
    MockAttempt: 'MockAttempt',
    TopicMastery: 'TopicMastery'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "post" | "user" | "session" | "account" | "verification" | "studentActivity" | "learningStreak" | "achievement" | "chatSession" | "chatMessage" | "sATStudyPlan" | "sATPracticeSession" | "sATDiagnosticResult" | "question" | "mockExam" | "mockAttempt" | "topicMastery"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      StudentActivity: {
        payload: Prisma.$StudentActivityPayload<ExtArgs>
        fields: Prisma.StudentActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentActivityPayload>
          }
          findFirst: {
            args: Prisma.StudentActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentActivityPayload>
          }
          findMany: {
            args: Prisma.StudentActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentActivityPayload>[]
          }
          create: {
            args: Prisma.StudentActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentActivityPayload>
          }
          createMany: {
            args: Prisma.StudentActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentActivityPayload>[]
          }
          delete: {
            args: Prisma.StudentActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentActivityPayload>
          }
          update: {
            args: Prisma.StudentActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentActivityPayload>
          }
          deleteMany: {
            args: Prisma.StudentActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentActivityPayload>[]
          }
          upsert: {
            args: Prisma.StudentActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentActivityPayload>
          }
          aggregate: {
            args: Prisma.StudentActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentActivity>
          }
          groupBy: {
            args: Prisma.StudentActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentActivityCountArgs<ExtArgs>
            result: $Utils.Optional<StudentActivityCountAggregateOutputType> | number
          }
        }
      }
      LearningStreak: {
        payload: Prisma.$LearningStreakPayload<ExtArgs>
        fields: Prisma.LearningStreakFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningStreakFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningStreakPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningStreakFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningStreakPayload>
          }
          findFirst: {
            args: Prisma.LearningStreakFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningStreakPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningStreakFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningStreakPayload>
          }
          findMany: {
            args: Prisma.LearningStreakFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningStreakPayload>[]
          }
          create: {
            args: Prisma.LearningStreakCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningStreakPayload>
          }
          createMany: {
            args: Prisma.LearningStreakCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningStreakCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningStreakPayload>[]
          }
          delete: {
            args: Prisma.LearningStreakDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningStreakPayload>
          }
          update: {
            args: Prisma.LearningStreakUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningStreakPayload>
          }
          deleteMany: {
            args: Prisma.LearningStreakDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningStreakUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearningStreakUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningStreakPayload>[]
          }
          upsert: {
            args: Prisma.LearningStreakUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningStreakPayload>
          }
          aggregate: {
            args: Prisma.LearningStreakAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningStreak>
          }
          groupBy: {
            args: Prisma.LearningStreakGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningStreakGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningStreakCountArgs<ExtArgs>
            result: $Utils.Optional<LearningStreakCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      ChatSession: {
        payload: Prisma.$ChatSessionPayload<ExtArgs>
        fields: Prisma.ChatSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          findFirst: {
            args: Prisma.ChatSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          findMany: {
            args: Prisma.ChatSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          create: {
            args: Prisma.ChatSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          createMany: {
            args: Prisma.ChatSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          delete: {
            args: Prisma.ChatSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          update: {
            args: Prisma.ChatSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          deleteMany: {
            args: Prisma.ChatSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>[]
          }
          upsert: {
            args: Prisma.ChatSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatSessionPayload>
          }
          aggregate: {
            args: Prisma.ChatSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatSession>
          }
          groupBy: {
            args: Prisma.ChatSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ChatSessionCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      SATStudyPlan: {
        payload: Prisma.$SATStudyPlanPayload<ExtArgs>
        fields: Prisma.SATStudyPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SATStudyPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATStudyPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SATStudyPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATStudyPlanPayload>
          }
          findFirst: {
            args: Prisma.SATStudyPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATStudyPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SATStudyPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATStudyPlanPayload>
          }
          findMany: {
            args: Prisma.SATStudyPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATStudyPlanPayload>[]
          }
          create: {
            args: Prisma.SATStudyPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATStudyPlanPayload>
          }
          createMany: {
            args: Prisma.SATStudyPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SATStudyPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATStudyPlanPayload>[]
          }
          delete: {
            args: Prisma.SATStudyPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATStudyPlanPayload>
          }
          update: {
            args: Prisma.SATStudyPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATStudyPlanPayload>
          }
          deleteMany: {
            args: Prisma.SATStudyPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SATStudyPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SATStudyPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATStudyPlanPayload>[]
          }
          upsert: {
            args: Prisma.SATStudyPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATStudyPlanPayload>
          }
          aggregate: {
            args: Prisma.SATStudyPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSATStudyPlan>
          }
          groupBy: {
            args: Prisma.SATStudyPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<SATStudyPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.SATStudyPlanCountArgs<ExtArgs>
            result: $Utils.Optional<SATStudyPlanCountAggregateOutputType> | number
          }
        }
      }
      SATPracticeSession: {
        payload: Prisma.$SATPracticeSessionPayload<ExtArgs>
        fields: Prisma.SATPracticeSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SATPracticeSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATPracticeSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SATPracticeSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATPracticeSessionPayload>
          }
          findFirst: {
            args: Prisma.SATPracticeSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATPracticeSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SATPracticeSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATPracticeSessionPayload>
          }
          findMany: {
            args: Prisma.SATPracticeSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATPracticeSessionPayload>[]
          }
          create: {
            args: Prisma.SATPracticeSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATPracticeSessionPayload>
          }
          createMany: {
            args: Prisma.SATPracticeSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SATPracticeSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATPracticeSessionPayload>[]
          }
          delete: {
            args: Prisma.SATPracticeSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATPracticeSessionPayload>
          }
          update: {
            args: Prisma.SATPracticeSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATPracticeSessionPayload>
          }
          deleteMany: {
            args: Prisma.SATPracticeSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SATPracticeSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SATPracticeSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATPracticeSessionPayload>[]
          }
          upsert: {
            args: Prisma.SATPracticeSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATPracticeSessionPayload>
          }
          aggregate: {
            args: Prisma.SATPracticeSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSATPracticeSession>
          }
          groupBy: {
            args: Prisma.SATPracticeSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SATPracticeSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SATPracticeSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SATPracticeSessionCountAggregateOutputType> | number
          }
        }
      }
      SATDiagnosticResult: {
        payload: Prisma.$SATDiagnosticResultPayload<ExtArgs>
        fields: Prisma.SATDiagnosticResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SATDiagnosticResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATDiagnosticResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SATDiagnosticResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATDiagnosticResultPayload>
          }
          findFirst: {
            args: Prisma.SATDiagnosticResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATDiagnosticResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SATDiagnosticResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATDiagnosticResultPayload>
          }
          findMany: {
            args: Prisma.SATDiagnosticResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATDiagnosticResultPayload>[]
          }
          create: {
            args: Prisma.SATDiagnosticResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATDiagnosticResultPayload>
          }
          createMany: {
            args: Prisma.SATDiagnosticResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SATDiagnosticResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATDiagnosticResultPayload>[]
          }
          delete: {
            args: Prisma.SATDiagnosticResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATDiagnosticResultPayload>
          }
          update: {
            args: Prisma.SATDiagnosticResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATDiagnosticResultPayload>
          }
          deleteMany: {
            args: Prisma.SATDiagnosticResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SATDiagnosticResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SATDiagnosticResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATDiagnosticResultPayload>[]
          }
          upsert: {
            args: Prisma.SATDiagnosticResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SATDiagnosticResultPayload>
          }
          aggregate: {
            args: Prisma.SATDiagnosticResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSATDiagnosticResult>
          }
          groupBy: {
            args: Prisma.SATDiagnosticResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<SATDiagnosticResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.SATDiagnosticResultCountArgs<ExtArgs>
            result: $Utils.Optional<SATDiagnosticResultCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      MockExam: {
        payload: Prisma.$MockExamPayload<ExtArgs>
        fields: Prisma.MockExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MockExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MockExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockExamPayload>
          }
          findFirst: {
            args: Prisma.MockExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MockExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockExamPayload>
          }
          findMany: {
            args: Prisma.MockExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockExamPayload>[]
          }
          create: {
            args: Prisma.MockExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockExamPayload>
          }
          createMany: {
            args: Prisma.MockExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MockExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockExamPayload>[]
          }
          delete: {
            args: Prisma.MockExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockExamPayload>
          }
          update: {
            args: Prisma.MockExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockExamPayload>
          }
          deleteMany: {
            args: Prisma.MockExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MockExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MockExamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockExamPayload>[]
          }
          upsert: {
            args: Prisma.MockExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockExamPayload>
          }
          aggregate: {
            args: Prisma.MockExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMockExam>
          }
          groupBy: {
            args: Prisma.MockExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<MockExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.MockExamCountArgs<ExtArgs>
            result: $Utils.Optional<MockExamCountAggregateOutputType> | number
          }
        }
      }
      MockAttempt: {
        payload: Prisma.$MockAttemptPayload<ExtArgs>
        fields: Prisma.MockAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MockAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MockAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockAttemptPayload>
          }
          findFirst: {
            args: Prisma.MockAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MockAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockAttemptPayload>
          }
          findMany: {
            args: Prisma.MockAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockAttemptPayload>[]
          }
          create: {
            args: Prisma.MockAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockAttemptPayload>
          }
          createMany: {
            args: Prisma.MockAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MockAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockAttemptPayload>[]
          }
          delete: {
            args: Prisma.MockAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockAttemptPayload>
          }
          update: {
            args: Prisma.MockAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockAttemptPayload>
          }
          deleteMany: {
            args: Prisma.MockAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MockAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MockAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockAttemptPayload>[]
          }
          upsert: {
            args: Prisma.MockAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MockAttemptPayload>
          }
          aggregate: {
            args: Prisma.MockAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMockAttempt>
          }
          groupBy: {
            args: Prisma.MockAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<MockAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.MockAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<MockAttemptCountAggregateOutputType> | number
          }
        }
      }
      TopicMastery: {
        payload: Prisma.$TopicMasteryPayload<ExtArgs>
        fields: Prisma.TopicMasteryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicMasteryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicMasteryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicMasteryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicMasteryPayload>
          }
          findFirst: {
            args: Prisma.TopicMasteryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicMasteryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicMasteryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicMasteryPayload>
          }
          findMany: {
            args: Prisma.TopicMasteryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicMasteryPayload>[]
          }
          create: {
            args: Prisma.TopicMasteryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicMasteryPayload>
          }
          createMany: {
            args: Prisma.TopicMasteryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicMasteryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicMasteryPayload>[]
          }
          delete: {
            args: Prisma.TopicMasteryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicMasteryPayload>
          }
          update: {
            args: Prisma.TopicMasteryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicMasteryPayload>
          }
          deleteMany: {
            args: Prisma.TopicMasteryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicMasteryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TopicMasteryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicMasteryPayload>[]
          }
          upsert: {
            args: Prisma.TopicMasteryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicMasteryPayload>
          }
          aggregate: {
            args: Prisma.TopicMasteryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopicMastery>
          }
          groupBy: {
            args: Prisma.TopicMasteryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicMasteryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicMasteryCountArgs<ExtArgs>
            result: $Utils.Optional<TopicMasteryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    post?: PostOmit
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    studentActivity?: StudentActivityOmit
    learningStreak?: LearningStreakOmit
    achievement?: AchievementOmit
    chatSession?: ChatSessionOmit
    chatMessage?: ChatMessageOmit
    sATStudyPlan?: SATStudyPlanOmit
    sATPracticeSession?: SATPracticeSessionOmit
    sATDiagnosticResult?: SATDiagnosticResultOmit
    question?: QuestionOmit
    mockExam?: MockExamOmit
    mockAttempt?: MockAttemptOmit
    topicMastery?: TopicMasteryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    posts: number
    activities: number
    achievements: number
    chatSessions: number
    satStudyPlans: number
    satPracticeSessions: number
    satDiagnosticResults: number
    generatedQuestions: number
    mockExams: number
    mockAttempts: number
    topicMasteries: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    chatSessions?: boolean | UserCountOutputTypeCountChatSessionsArgs
    satStudyPlans?: boolean | UserCountOutputTypeCountSatStudyPlansArgs
    satPracticeSessions?: boolean | UserCountOutputTypeCountSatPracticeSessionsArgs
    satDiagnosticResults?: boolean | UserCountOutputTypeCountSatDiagnosticResultsArgs
    generatedQuestions?: boolean | UserCountOutputTypeCountGeneratedQuestionsArgs
    mockExams?: boolean | UserCountOutputTypeCountMockExamsArgs
    mockAttempts?: boolean | UserCountOutputTypeCountMockAttemptsArgs
    topicMasteries?: boolean | UserCountOutputTypeCountTopicMasteriesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSatStudyPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SATStudyPlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSatPracticeSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SATPracticeSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSatDiagnosticResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SATDiagnosticResultWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGeneratedQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMockExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockExamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMockAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTopicMasteriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicMasteryWhereInput
  }


  /**
   * Count Type ChatSessionCountOutputType
   */

  export type ChatSessionCountOutputType = {
    messages: number
  }

  export type ChatSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatSessionCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatSessionCountOutputType without action
   */
  export type ChatSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSessionCountOutputType
     */
    select?: ChatSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatSessionCountOutputType without action
   */
  export type ChatSessionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type MockExamCountOutputType
   */

  export type MockExamCountOutputType = {
    attempts: number
  }

  export type MockExamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempts?: boolean | MockExamCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * MockExamCountOutputType without action
   */
  export type MockExamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExamCountOutputType
     */
    select?: MockExamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MockExamCountOutputType without action
   */
  export type MockExamCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockAttemptWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    content: string | null
    userId: string | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    content: string | null
    userId: string | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    title: number
    content: number
    userId: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    content?: true
    userId?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    content?: true
    userId?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    content?: true
    userId?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    title: string
    content: string
    userId: string
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    content?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    content?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    content?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    content?: boolean
    userId?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "title" | "content" | "userId", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      title: string
      content: string
      userId: string
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
    readonly title: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly userId: FieldRef<"Post", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    gradeLevel: number | null
    age: number | null
    sessionDuration: number | null
    pastEngagement: number | null
  }

  export type UserSumAggregateOutputType = {
    gradeLevel: number | null
    age: number | null
    sessionDuration: number | null
    pastEngagement: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    role: $Enums.UserRole | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    isOnboarded: boolean | null
    gradeLevel: number | null
    age: number | null
    school: string | null
    learningStyle: $Enums.LearningStyle | null
    difficultyLevel: $Enums.DifficultyLevel | null
    sessionDuration: number | null
    pastEngagement: number | null
    isInterestedInSATPrep: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    role: $Enums.UserRole | null
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    isOnboarded: boolean | null
    gradeLevel: number | null
    age: number | null
    school: string | null
    learningStyle: $Enums.LearningStyle | null
    difficultyLevel: $Enums.DifficultyLevel | null
    sessionDuration: number | null
    pastEngagement: number | null
    isInterestedInSATPrep: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    email: number
    emailVerified: number
    image: number
    role: number
    banned: number
    banReason: number
    banExpires: number
    isOnboarded: number
    gradeLevel: number
    age: number
    school: number
    subjects: number
    learningGoals: number
    learningStyle: number
    difficultyLevel: number
    sessionDuration: number
    interests: number
    pastEngagement: number
    isInterestedInSATPrep: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    gradeLevel?: true
    age?: true
    sessionDuration?: true
    pastEngagement?: true
  }

  export type UserSumAggregateInputType = {
    gradeLevel?: true
    age?: true
    sessionDuration?: true
    pastEngagement?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    isOnboarded?: true
    gradeLevel?: true
    age?: true
    school?: true
    learningStyle?: true
    difficultyLevel?: true
    sessionDuration?: true
    pastEngagement?: true
    isInterestedInSATPrep?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    isOnboarded?: true
    gradeLevel?: true
    age?: true
    school?: true
    learningStyle?: true
    difficultyLevel?: true
    sessionDuration?: true
    pastEngagement?: true
    isInterestedInSATPrep?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    role?: true
    banned?: true
    banReason?: true
    banExpires?: true
    isOnboarded?: true
    gradeLevel?: true
    age?: true
    school?: true
    subjects?: true
    learningGoals?: true
    learningStyle?: true
    difficultyLevel?: true
    sessionDuration?: true
    interests?: true
    pastEngagement?: true
    isInterestedInSATPrep?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    role: $Enums.UserRole
    banned: boolean | null
    banReason: string | null
    banExpires: Date | null
    isOnboarded: boolean
    gradeLevel: number | null
    age: number | null
    school: string | null
    subjects: string[]
    learningGoals: string[]
    learningStyle: $Enums.LearningStyle
    difficultyLevel: $Enums.DifficultyLevel
    sessionDuration: number | null
    interests: string[]
    pastEngagement: number | null
    isInterestedInSATPrep: boolean | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    isOnboarded?: boolean
    gradeLevel?: boolean
    age?: boolean
    school?: boolean
    subjects?: boolean
    learningGoals?: boolean
    learningStyle?: boolean
    difficultyLevel?: boolean
    sessionDuration?: boolean
    interests?: boolean
    pastEngagement?: boolean
    isInterestedInSATPrep?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    streak?: boolean | User$streakArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    chatSessions?: boolean | User$chatSessionsArgs<ExtArgs>
    satStudyPlans?: boolean | User$satStudyPlansArgs<ExtArgs>
    satPracticeSessions?: boolean | User$satPracticeSessionsArgs<ExtArgs>
    satDiagnosticResults?: boolean | User$satDiagnosticResultsArgs<ExtArgs>
    generatedQuestions?: boolean | User$generatedQuestionsArgs<ExtArgs>
    mockExams?: boolean | User$mockExamsArgs<ExtArgs>
    mockAttempts?: boolean | User$mockAttemptsArgs<ExtArgs>
    topicMasteries?: boolean | User$topicMasteriesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    isOnboarded?: boolean
    gradeLevel?: boolean
    age?: boolean
    school?: boolean
    subjects?: boolean
    learningGoals?: boolean
    learningStyle?: boolean
    difficultyLevel?: boolean
    sessionDuration?: boolean
    interests?: boolean
    pastEngagement?: boolean
    isInterestedInSATPrep?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    isOnboarded?: boolean
    gradeLevel?: boolean
    age?: boolean
    school?: boolean
    subjects?: boolean
    learningGoals?: boolean
    learningStyle?: boolean
    difficultyLevel?: boolean
    sessionDuration?: boolean
    interests?: boolean
    pastEngagement?: boolean
    isInterestedInSATPrep?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    role?: boolean
    banned?: boolean
    banReason?: boolean
    banExpires?: boolean
    isOnboarded?: boolean
    gradeLevel?: boolean
    age?: boolean
    school?: boolean
    subjects?: boolean
    learningGoals?: boolean
    learningStyle?: boolean
    difficultyLevel?: boolean
    sessionDuration?: boolean
    interests?: boolean
    pastEngagement?: boolean
    isInterestedInSATPrep?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "email" | "emailVerified" | "image" | "role" | "banned" | "banReason" | "banExpires" | "isOnboarded" | "gradeLevel" | "age" | "school" | "subjects" | "learningGoals" | "learningStyle" | "difficultyLevel" | "sessionDuration" | "interests" | "pastEngagement" | "isInterestedInSATPrep", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    streak?: boolean | User$streakArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    chatSessions?: boolean | User$chatSessionsArgs<ExtArgs>
    satStudyPlans?: boolean | User$satStudyPlansArgs<ExtArgs>
    satPracticeSessions?: boolean | User$satPracticeSessionsArgs<ExtArgs>
    satDiagnosticResults?: boolean | User$satDiagnosticResultsArgs<ExtArgs>
    generatedQuestions?: boolean | User$generatedQuestionsArgs<ExtArgs>
    mockExams?: boolean | User$mockExamsArgs<ExtArgs>
    mockAttempts?: boolean | User$mockAttemptsArgs<ExtArgs>
    topicMasteries?: boolean | User$topicMasteriesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      activities: Prisma.$StudentActivityPayload<ExtArgs>[]
      streak: Prisma.$LearningStreakPayload<ExtArgs> | null
      achievements: Prisma.$AchievementPayload<ExtArgs>[]
      chatSessions: Prisma.$ChatSessionPayload<ExtArgs>[]
      satStudyPlans: Prisma.$SATStudyPlanPayload<ExtArgs>[]
      satPracticeSessions: Prisma.$SATPracticeSessionPayload<ExtArgs>[]
      satDiagnosticResults: Prisma.$SATDiagnosticResultPayload<ExtArgs>[]
      generatedQuestions: Prisma.$QuestionPayload<ExtArgs>[]
      mockExams: Prisma.$MockExamPayload<ExtArgs>[]
      mockAttempts: Prisma.$MockAttemptPayload<ExtArgs>[]
      topicMasteries: Prisma.$TopicMasteryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      role: $Enums.UserRole
      banned: boolean | null
      banReason: string | null
      banExpires: Date | null
      isOnboarded: boolean
      gradeLevel: number | null
      age: number | null
      school: string | null
      subjects: string[]
      learningGoals: string[]
      learningStyle: $Enums.LearningStyle
      difficultyLevel: $Enums.DifficultyLevel
      sessionDuration: number | null
      interests: string[]
      pastEngagement: number | null
      isInterestedInSATPrep: boolean | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    streak<T extends User$streakArgs<ExtArgs> = {}>(args?: Subset<T, User$streakArgs<ExtArgs>>): Prisma__LearningStreakClient<$Result.GetResult<Prisma.$LearningStreakPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatSessions<T extends User$chatSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    satStudyPlans<T extends User$satStudyPlansArgs<ExtArgs> = {}>(args?: Subset<T, User$satStudyPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SATStudyPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    satPracticeSessions<T extends User$satPracticeSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$satPracticeSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SATPracticeSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    satDiagnosticResults<T extends User$satDiagnosticResultsArgs<ExtArgs> = {}>(args?: Subset<T, User$satDiagnosticResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SATDiagnosticResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedQuestions<T extends User$generatedQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, User$generatedQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mockExams<T extends User$mockExamsArgs<ExtArgs> = {}>(args?: Subset<T, User$mockExamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mockAttempts<T extends User$mockAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$mockAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    topicMasteries<T extends User$topicMasteriesArgs<ExtArgs> = {}>(args?: Subset<T, User$topicMasteriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicMasteryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly banned: FieldRef<"User", 'Boolean'>
    readonly banReason: FieldRef<"User", 'String'>
    readonly banExpires: FieldRef<"User", 'DateTime'>
    readonly isOnboarded: FieldRef<"User", 'Boolean'>
    readonly gradeLevel: FieldRef<"User", 'Int'>
    readonly age: FieldRef<"User", 'Int'>
    readonly school: FieldRef<"User", 'String'>
    readonly subjects: FieldRef<"User", 'String[]'>
    readonly learningGoals: FieldRef<"User", 'String[]'>
    readonly learningStyle: FieldRef<"User", 'LearningStyle'>
    readonly difficultyLevel: FieldRef<"User", 'DifficultyLevel'>
    readonly sessionDuration: FieldRef<"User", 'Int'>
    readonly interests: FieldRef<"User", 'String[]'>
    readonly pastEngagement: FieldRef<"User", 'Float'>
    readonly isInterestedInSATPrep: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentActivity
     */
    select?: StudentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentActivity
     */
    omit?: StudentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentActivityInclude<ExtArgs> | null
    where?: StudentActivityWhereInput
    orderBy?: StudentActivityOrderByWithRelationInput | StudentActivityOrderByWithRelationInput[]
    cursor?: StudentActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentActivityScalarFieldEnum | StudentActivityScalarFieldEnum[]
  }

  /**
   * User.streak
   */
  export type User$streakArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningStreak
     */
    select?: LearningStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningStreak
     */
    omit?: LearningStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningStreakInclude<ExtArgs> | null
    where?: LearningStreakWhereInput
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    cursor?: AchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * User.chatSessions
   */
  export type User$chatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    where?: ChatSessionWhereInput
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    cursor?: ChatSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * User.satStudyPlans
   */
  export type User$satStudyPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATStudyPlan
     */
    select?: SATStudyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATStudyPlan
     */
    omit?: SATStudyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATStudyPlanInclude<ExtArgs> | null
    where?: SATStudyPlanWhereInput
    orderBy?: SATStudyPlanOrderByWithRelationInput | SATStudyPlanOrderByWithRelationInput[]
    cursor?: SATStudyPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SATStudyPlanScalarFieldEnum | SATStudyPlanScalarFieldEnum[]
  }

  /**
   * User.satPracticeSessions
   */
  export type User$satPracticeSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATPracticeSession
     */
    select?: SATPracticeSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATPracticeSession
     */
    omit?: SATPracticeSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATPracticeSessionInclude<ExtArgs> | null
    where?: SATPracticeSessionWhereInput
    orderBy?: SATPracticeSessionOrderByWithRelationInput | SATPracticeSessionOrderByWithRelationInput[]
    cursor?: SATPracticeSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SATPracticeSessionScalarFieldEnum | SATPracticeSessionScalarFieldEnum[]
  }

  /**
   * User.satDiagnosticResults
   */
  export type User$satDiagnosticResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATDiagnosticResult
     */
    select?: SATDiagnosticResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATDiagnosticResult
     */
    omit?: SATDiagnosticResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATDiagnosticResultInclude<ExtArgs> | null
    where?: SATDiagnosticResultWhereInput
    orderBy?: SATDiagnosticResultOrderByWithRelationInput | SATDiagnosticResultOrderByWithRelationInput[]
    cursor?: SATDiagnosticResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SATDiagnosticResultScalarFieldEnum | SATDiagnosticResultScalarFieldEnum[]
  }

  /**
   * User.generatedQuestions
   */
  export type User$generatedQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * User.mockExams
   */
  export type User$mockExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExam
     */
    select?: MockExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockExam
     */
    omit?: MockExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockExamInclude<ExtArgs> | null
    where?: MockExamWhereInput
    orderBy?: MockExamOrderByWithRelationInput | MockExamOrderByWithRelationInput[]
    cursor?: MockExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MockExamScalarFieldEnum | MockExamScalarFieldEnum[]
  }

  /**
   * User.mockAttempts
   */
  export type User$mockAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptInclude<ExtArgs> | null
    where?: MockAttemptWhereInput
    orderBy?: MockAttemptOrderByWithRelationInput | MockAttemptOrderByWithRelationInput[]
    cursor?: MockAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MockAttemptScalarFieldEnum | MockAttemptScalarFieldEnum[]
  }

  /**
   * User.topicMasteries
   */
  export type User$topicMasteriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicMastery
     */
    select?: TopicMasterySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicMastery
     */
    omit?: TopicMasteryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicMasteryInclude<ExtArgs> | null
    where?: TopicMasteryWhereInput
    orderBy?: TopicMasteryOrderByWithRelationInput | TopicMasteryOrderByWithRelationInput[]
    cursor?: TopicMasteryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicMasteryScalarFieldEnum | TopicMasteryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    impersonatedBy: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    impersonatedBy: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    token: number
    ipAddress: number
    userAgent: number
    impersonatedBy: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    impersonatedBy?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    impersonatedBy?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    impersonatedBy?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    expiresAt: Date
    token: string
    ipAddress: string | null
    userAgent: string | null
    impersonatedBy: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    impersonatedBy?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    impersonatedBy?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    impersonatedBy?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    impersonatedBy?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "expiresAt" | "token" | "ipAddress" | "userAgent" | "impersonatedBy" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      expiresAt: Date
      token: string
      ipAddress: string | null
      userAgent: string | null
      impersonatedBy: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly impersonatedBy: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    userId: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    accountId: string | null
    providerId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    userId: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    accountId: number
    providerId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    userId: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    userId?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    userId?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    accountId?: true
    providerId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    userId?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    accountId: string
    providerId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    userId: string
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountId?: boolean
    providerId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    userId?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "accountId" | "providerId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "userId", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      accountId: string
      providerId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      userId: string
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    identifier: number
    value: number
    expiresAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    identifier?: true
    value?: true
    expiresAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    identifier?: true
    value?: true
    expiresAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    identifier?: true
    value?: true
    expiresAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    identifier: string
    value: string
    expiresAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "identifier" | "value" | "expiresAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      identifier: string
      value: string
      expiresAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model StudentActivity
   */

  export type AggregateStudentActivity = {
    _count: StudentActivityCountAggregateOutputType | null
    _avg: StudentActivityAvgAggregateOutputType | null
    _sum: StudentActivitySumAggregateOutputType | null
    _min: StudentActivityMinAggregateOutputType | null
    _max: StudentActivityMaxAggregateOutputType | null
  }

  export type StudentActivityAvgAggregateOutputType = {
    duration: number | null
    score: number | null
  }

  export type StudentActivitySumAggregateOutputType = {
    duration: number | null
    score: number | null
  }

  export type StudentActivityMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    userId: string | null
    type: $Enums.ActivityType | null
    subject: string | null
    topic: string | null
    duration: number | null
    score: number | null
  }

  export type StudentActivityMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    userId: string | null
    type: $Enums.ActivityType | null
    subject: string | null
    topic: string | null
    duration: number | null
    score: number | null
  }

  export type StudentActivityCountAggregateOutputType = {
    id: number
    createdAt: number
    userId: number
    type: number
    subject: number
    topic: number
    duration: number
    score: number
    metadata: number
    _all: number
  }


  export type StudentActivityAvgAggregateInputType = {
    duration?: true
    score?: true
  }

  export type StudentActivitySumAggregateInputType = {
    duration?: true
    score?: true
  }

  export type StudentActivityMinAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    type?: true
    subject?: true
    topic?: true
    duration?: true
    score?: true
  }

  export type StudentActivityMaxAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    type?: true
    subject?: true
    topic?: true
    duration?: true
    score?: true
  }

  export type StudentActivityCountAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    type?: true
    subject?: true
    topic?: true
    duration?: true
    score?: true
    metadata?: true
    _all?: true
  }

  export type StudentActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentActivity to aggregate.
     */
    where?: StudentActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentActivities to fetch.
     */
    orderBy?: StudentActivityOrderByWithRelationInput | StudentActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentActivities
    **/
    _count?: true | StudentActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentActivityMaxAggregateInputType
  }

  export type GetStudentActivityAggregateType<T extends StudentActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentActivity[P]>
      : GetScalarType<T[P], AggregateStudentActivity[P]>
  }




  export type StudentActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentActivityWhereInput
    orderBy?: StudentActivityOrderByWithAggregationInput | StudentActivityOrderByWithAggregationInput[]
    by: StudentActivityScalarFieldEnum[] | StudentActivityScalarFieldEnum
    having?: StudentActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentActivityCountAggregateInputType | true
    _avg?: StudentActivityAvgAggregateInputType
    _sum?: StudentActivitySumAggregateInputType
    _min?: StudentActivityMinAggregateInputType
    _max?: StudentActivityMaxAggregateInputType
  }

  export type StudentActivityGroupByOutputType = {
    id: string
    createdAt: Date
    userId: string
    type: $Enums.ActivityType
    subject: string | null
    topic: string | null
    duration: number | null
    score: number | null
    metadata: JsonValue | null
    _count: StudentActivityCountAggregateOutputType | null
    _avg: StudentActivityAvgAggregateOutputType | null
    _sum: StudentActivitySumAggregateOutputType | null
    _min: StudentActivityMinAggregateOutputType | null
    _max: StudentActivityMaxAggregateOutputType | null
  }

  type GetStudentActivityGroupByPayload<T extends StudentActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentActivityGroupByOutputType[P]>
            : GetScalarType<T[P], StudentActivityGroupByOutputType[P]>
        }
      >
    >


  export type StudentActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    type?: boolean
    subject?: boolean
    topic?: boolean
    duration?: boolean
    score?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentActivity"]>

  export type StudentActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    type?: boolean
    subject?: boolean
    topic?: boolean
    duration?: boolean
    score?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentActivity"]>

  export type StudentActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    type?: boolean
    subject?: boolean
    topic?: boolean
    duration?: boolean
    score?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentActivity"]>

  export type StudentActivitySelectScalar = {
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    type?: boolean
    subject?: boolean
    topic?: boolean
    duration?: boolean
    score?: boolean
    metadata?: boolean
  }

  export type StudentActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "userId" | "type" | "subject" | "topic" | "duration" | "score" | "metadata", ExtArgs["result"]["studentActivity"]>
  export type StudentActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudentActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudentActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudentActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentActivity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      userId: string
      type: $Enums.ActivityType
      subject: string | null
      topic: string | null
      duration: number | null
      score: number | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["studentActivity"]>
    composites: {}
  }

  type StudentActivityGetPayload<S extends boolean | null | undefined | StudentActivityDefaultArgs> = $Result.GetResult<Prisma.$StudentActivityPayload, S>

  type StudentActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentActivityCountAggregateInputType | true
    }

  export interface StudentActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentActivity'], meta: { name: 'StudentActivity' } }
    /**
     * Find zero or one StudentActivity that matches the filter.
     * @param {StudentActivityFindUniqueArgs} args - Arguments to find a StudentActivity
     * @example
     * // Get one StudentActivity
     * const studentActivity = await prisma.studentActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentActivityFindUniqueArgs>(args: SelectSubset<T, StudentActivityFindUniqueArgs<ExtArgs>>): Prisma__StudentActivityClient<$Result.GetResult<Prisma.$StudentActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentActivityFindUniqueOrThrowArgs} args - Arguments to find a StudentActivity
     * @example
     * // Get one StudentActivity
     * const studentActivity = await prisma.studentActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentActivityClient<$Result.GetResult<Prisma.$StudentActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentActivityFindFirstArgs} args - Arguments to find a StudentActivity
     * @example
     * // Get one StudentActivity
     * const studentActivity = await prisma.studentActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentActivityFindFirstArgs>(args?: SelectSubset<T, StudentActivityFindFirstArgs<ExtArgs>>): Prisma__StudentActivityClient<$Result.GetResult<Prisma.$StudentActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentActivityFindFirstOrThrowArgs} args - Arguments to find a StudentActivity
     * @example
     * // Get one StudentActivity
     * const studentActivity = await prisma.studentActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentActivityClient<$Result.GetResult<Prisma.$StudentActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentActivities
     * const studentActivities = await prisma.studentActivity.findMany()
     * 
     * // Get first 10 StudentActivities
     * const studentActivities = await prisma.studentActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentActivityWithIdOnly = await prisma.studentActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentActivityFindManyArgs>(args?: SelectSubset<T, StudentActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentActivity.
     * @param {StudentActivityCreateArgs} args - Arguments to create a StudentActivity.
     * @example
     * // Create one StudentActivity
     * const StudentActivity = await prisma.studentActivity.create({
     *   data: {
     *     // ... data to create a StudentActivity
     *   }
     * })
     * 
     */
    create<T extends StudentActivityCreateArgs>(args: SelectSubset<T, StudentActivityCreateArgs<ExtArgs>>): Prisma__StudentActivityClient<$Result.GetResult<Prisma.$StudentActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentActivities.
     * @param {StudentActivityCreateManyArgs} args - Arguments to create many StudentActivities.
     * @example
     * // Create many StudentActivities
     * const studentActivity = await prisma.studentActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentActivityCreateManyArgs>(args?: SelectSubset<T, StudentActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentActivities and returns the data saved in the database.
     * @param {StudentActivityCreateManyAndReturnArgs} args - Arguments to create many StudentActivities.
     * @example
     * // Create many StudentActivities
     * const studentActivity = await prisma.studentActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentActivities and only return the `id`
     * const studentActivityWithIdOnly = await prisma.studentActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentActivity.
     * @param {StudentActivityDeleteArgs} args - Arguments to delete one StudentActivity.
     * @example
     * // Delete one StudentActivity
     * const StudentActivity = await prisma.studentActivity.delete({
     *   where: {
     *     // ... filter to delete one StudentActivity
     *   }
     * })
     * 
     */
    delete<T extends StudentActivityDeleteArgs>(args: SelectSubset<T, StudentActivityDeleteArgs<ExtArgs>>): Prisma__StudentActivityClient<$Result.GetResult<Prisma.$StudentActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentActivity.
     * @param {StudentActivityUpdateArgs} args - Arguments to update one StudentActivity.
     * @example
     * // Update one StudentActivity
     * const studentActivity = await prisma.studentActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentActivityUpdateArgs>(args: SelectSubset<T, StudentActivityUpdateArgs<ExtArgs>>): Prisma__StudentActivityClient<$Result.GetResult<Prisma.$StudentActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentActivities.
     * @param {StudentActivityDeleteManyArgs} args - Arguments to filter StudentActivities to delete.
     * @example
     * // Delete a few StudentActivities
     * const { count } = await prisma.studentActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentActivityDeleteManyArgs>(args?: SelectSubset<T, StudentActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentActivities
     * const studentActivity = await prisma.studentActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentActivityUpdateManyArgs>(args: SelectSubset<T, StudentActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentActivities and returns the data updated in the database.
     * @param {StudentActivityUpdateManyAndReturnArgs} args - Arguments to update many StudentActivities.
     * @example
     * // Update many StudentActivities
     * const studentActivity = await prisma.studentActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentActivities and only return the `id`
     * const studentActivityWithIdOnly = await prisma.studentActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentActivity.
     * @param {StudentActivityUpsertArgs} args - Arguments to update or create a StudentActivity.
     * @example
     * // Update or create a StudentActivity
     * const studentActivity = await prisma.studentActivity.upsert({
     *   create: {
     *     // ... data to create a StudentActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentActivity we want to update
     *   }
     * })
     */
    upsert<T extends StudentActivityUpsertArgs>(args: SelectSubset<T, StudentActivityUpsertArgs<ExtArgs>>): Prisma__StudentActivityClient<$Result.GetResult<Prisma.$StudentActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentActivityCountArgs} args - Arguments to filter StudentActivities to count.
     * @example
     * // Count the number of StudentActivities
     * const count = await prisma.studentActivity.count({
     *   where: {
     *     // ... the filter for the StudentActivities we want to count
     *   }
     * })
    **/
    count<T extends StudentActivityCountArgs>(
      args?: Subset<T, StudentActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentActivityAggregateArgs>(args: Subset<T, StudentActivityAggregateArgs>): Prisma.PrismaPromise<GetStudentActivityAggregateType<T>>

    /**
     * Group by StudentActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentActivityGroupByArgs['orderBy'] }
        : { orderBy?: StudentActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentActivity model
   */
  readonly fields: StudentActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentActivity model
   */
  interface StudentActivityFieldRefs {
    readonly id: FieldRef<"StudentActivity", 'String'>
    readonly createdAt: FieldRef<"StudentActivity", 'DateTime'>
    readonly userId: FieldRef<"StudentActivity", 'String'>
    readonly type: FieldRef<"StudentActivity", 'ActivityType'>
    readonly subject: FieldRef<"StudentActivity", 'String'>
    readonly topic: FieldRef<"StudentActivity", 'String'>
    readonly duration: FieldRef<"StudentActivity", 'Int'>
    readonly score: FieldRef<"StudentActivity", 'Float'>
    readonly metadata: FieldRef<"StudentActivity", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * StudentActivity findUnique
   */
  export type StudentActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentActivity
     */
    select?: StudentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentActivity
     */
    omit?: StudentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentActivityInclude<ExtArgs> | null
    /**
     * Filter, which StudentActivity to fetch.
     */
    where: StudentActivityWhereUniqueInput
  }

  /**
   * StudentActivity findUniqueOrThrow
   */
  export type StudentActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentActivity
     */
    select?: StudentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentActivity
     */
    omit?: StudentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentActivityInclude<ExtArgs> | null
    /**
     * Filter, which StudentActivity to fetch.
     */
    where: StudentActivityWhereUniqueInput
  }

  /**
   * StudentActivity findFirst
   */
  export type StudentActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentActivity
     */
    select?: StudentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentActivity
     */
    omit?: StudentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentActivityInclude<ExtArgs> | null
    /**
     * Filter, which StudentActivity to fetch.
     */
    where?: StudentActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentActivities to fetch.
     */
    orderBy?: StudentActivityOrderByWithRelationInput | StudentActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentActivities.
     */
    cursor?: StudentActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentActivities.
     */
    distinct?: StudentActivityScalarFieldEnum | StudentActivityScalarFieldEnum[]
  }

  /**
   * StudentActivity findFirstOrThrow
   */
  export type StudentActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentActivity
     */
    select?: StudentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentActivity
     */
    omit?: StudentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentActivityInclude<ExtArgs> | null
    /**
     * Filter, which StudentActivity to fetch.
     */
    where?: StudentActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentActivities to fetch.
     */
    orderBy?: StudentActivityOrderByWithRelationInput | StudentActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentActivities.
     */
    cursor?: StudentActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentActivities.
     */
    distinct?: StudentActivityScalarFieldEnum | StudentActivityScalarFieldEnum[]
  }

  /**
   * StudentActivity findMany
   */
  export type StudentActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentActivity
     */
    select?: StudentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentActivity
     */
    omit?: StudentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentActivityInclude<ExtArgs> | null
    /**
     * Filter, which StudentActivities to fetch.
     */
    where?: StudentActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentActivities to fetch.
     */
    orderBy?: StudentActivityOrderByWithRelationInput | StudentActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentActivities.
     */
    cursor?: StudentActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentActivities.
     */
    skip?: number
    distinct?: StudentActivityScalarFieldEnum | StudentActivityScalarFieldEnum[]
  }

  /**
   * StudentActivity create
   */
  export type StudentActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentActivity
     */
    select?: StudentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentActivity
     */
    omit?: StudentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentActivity.
     */
    data: XOR<StudentActivityCreateInput, StudentActivityUncheckedCreateInput>
  }

  /**
   * StudentActivity createMany
   */
  export type StudentActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentActivities.
     */
    data: StudentActivityCreateManyInput | StudentActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentActivity createManyAndReturn
   */
  export type StudentActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentActivity
     */
    select?: StudentActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentActivity
     */
    omit?: StudentActivityOmit<ExtArgs> | null
    /**
     * The data used to create many StudentActivities.
     */
    data: StudentActivityCreateManyInput | StudentActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentActivity update
   */
  export type StudentActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentActivity
     */
    select?: StudentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentActivity
     */
    omit?: StudentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentActivity.
     */
    data: XOR<StudentActivityUpdateInput, StudentActivityUncheckedUpdateInput>
    /**
     * Choose, which StudentActivity to update.
     */
    where: StudentActivityWhereUniqueInput
  }

  /**
   * StudentActivity updateMany
   */
  export type StudentActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentActivities.
     */
    data: XOR<StudentActivityUpdateManyMutationInput, StudentActivityUncheckedUpdateManyInput>
    /**
     * Filter which StudentActivities to update
     */
    where?: StudentActivityWhereInput
    /**
     * Limit how many StudentActivities to update.
     */
    limit?: number
  }

  /**
   * StudentActivity updateManyAndReturn
   */
  export type StudentActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentActivity
     */
    select?: StudentActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentActivity
     */
    omit?: StudentActivityOmit<ExtArgs> | null
    /**
     * The data used to update StudentActivities.
     */
    data: XOR<StudentActivityUpdateManyMutationInput, StudentActivityUncheckedUpdateManyInput>
    /**
     * Filter which StudentActivities to update
     */
    where?: StudentActivityWhereInput
    /**
     * Limit how many StudentActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentActivity upsert
   */
  export type StudentActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentActivity
     */
    select?: StudentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentActivity
     */
    omit?: StudentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentActivity to update in case it exists.
     */
    where: StudentActivityWhereUniqueInput
    /**
     * In case the StudentActivity found by the `where` argument doesn't exist, create a new StudentActivity with this data.
     */
    create: XOR<StudentActivityCreateInput, StudentActivityUncheckedCreateInput>
    /**
     * In case the StudentActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentActivityUpdateInput, StudentActivityUncheckedUpdateInput>
  }

  /**
   * StudentActivity delete
   */
  export type StudentActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentActivity
     */
    select?: StudentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentActivity
     */
    omit?: StudentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentActivityInclude<ExtArgs> | null
    /**
     * Filter which StudentActivity to delete.
     */
    where: StudentActivityWhereUniqueInput
  }

  /**
   * StudentActivity deleteMany
   */
  export type StudentActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentActivities to delete
     */
    where?: StudentActivityWhereInput
    /**
     * Limit how many StudentActivities to delete.
     */
    limit?: number
  }

  /**
   * StudentActivity without action
   */
  export type StudentActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentActivity
     */
    select?: StudentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentActivity
     */
    omit?: StudentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentActivityInclude<ExtArgs> | null
  }


  /**
   * Model LearningStreak
   */

  export type AggregateLearningStreak = {
    _count: LearningStreakCountAggregateOutputType | null
    _avg: LearningStreakAvgAggregateOutputType | null
    _sum: LearningStreakSumAggregateOutputType | null
    _min: LearningStreakMinAggregateOutputType | null
    _max: LearningStreakMaxAggregateOutputType | null
  }

  export type LearningStreakAvgAggregateOutputType = {
    currentStreak: number | null
    longestStreak: number | null
  }

  export type LearningStreakSumAggregateOutputType = {
    currentStreak: number | null
    longestStreak: number | null
  }

  export type LearningStreakMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currentStreak: number | null
    longestStreak: number | null
    lastActivity: Date | null
  }

  export type LearningStreakMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currentStreak: number | null
    longestStreak: number | null
    lastActivity: Date | null
  }

  export type LearningStreakCountAggregateOutputType = {
    id: number
    userId: number
    currentStreak: number
    longestStreak: number
    lastActivity: number
    _all: number
  }


  export type LearningStreakAvgAggregateInputType = {
    currentStreak?: true
    longestStreak?: true
  }

  export type LearningStreakSumAggregateInputType = {
    currentStreak?: true
    longestStreak?: true
  }

  export type LearningStreakMinAggregateInputType = {
    id?: true
    userId?: true
    currentStreak?: true
    longestStreak?: true
    lastActivity?: true
  }

  export type LearningStreakMaxAggregateInputType = {
    id?: true
    userId?: true
    currentStreak?: true
    longestStreak?: true
    lastActivity?: true
  }

  export type LearningStreakCountAggregateInputType = {
    id?: true
    userId?: true
    currentStreak?: true
    longestStreak?: true
    lastActivity?: true
    _all?: true
  }

  export type LearningStreakAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningStreak to aggregate.
     */
    where?: LearningStreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningStreaks to fetch.
     */
    orderBy?: LearningStreakOrderByWithRelationInput | LearningStreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningStreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningStreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningStreaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningStreaks
    **/
    _count?: true | LearningStreakCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningStreakAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningStreakSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningStreakMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningStreakMaxAggregateInputType
  }

  export type GetLearningStreakAggregateType<T extends LearningStreakAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningStreak]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningStreak[P]>
      : GetScalarType<T[P], AggregateLearningStreak[P]>
  }




  export type LearningStreakGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningStreakWhereInput
    orderBy?: LearningStreakOrderByWithAggregationInput | LearningStreakOrderByWithAggregationInput[]
    by: LearningStreakScalarFieldEnum[] | LearningStreakScalarFieldEnum
    having?: LearningStreakScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningStreakCountAggregateInputType | true
    _avg?: LearningStreakAvgAggregateInputType
    _sum?: LearningStreakSumAggregateInputType
    _min?: LearningStreakMinAggregateInputType
    _max?: LearningStreakMaxAggregateInputType
  }

  export type LearningStreakGroupByOutputType = {
    id: string
    userId: string
    currentStreak: number
    longestStreak: number
    lastActivity: Date
    _count: LearningStreakCountAggregateOutputType | null
    _avg: LearningStreakAvgAggregateOutputType | null
    _sum: LearningStreakSumAggregateOutputType | null
    _min: LearningStreakMinAggregateOutputType | null
    _max: LearningStreakMaxAggregateOutputType | null
  }

  type GetLearningStreakGroupByPayload<T extends LearningStreakGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningStreakGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningStreakGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningStreakGroupByOutputType[P]>
            : GetScalarType<T[P], LearningStreakGroupByOutputType[P]>
        }
      >
    >


  export type LearningStreakSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastActivity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningStreak"]>

  export type LearningStreakSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastActivity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningStreak"]>

  export type LearningStreakSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastActivity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningStreak"]>

  export type LearningStreakSelectScalar = {
    id?: boolean
    userId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastActivity?: boolean
  }

  export type LearningStreakOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "currentStreak" | "longestStreak" | "lastActivity", ExtArgs["result"]["learningStreak"]>
  export type LearningStreakInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LearningStreakIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LearningStreakIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LearningStreakPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningStreak"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currentStreak: number
      longestStreak: number
      lastActivity: Date
    }, ExtArgs["result"]["learningStreak"]>
    composites: {}
  }

  type LearningStreakGetPayload<S extends boolean | null | undefined | LearningStreakDefaultArgs> = $Result.GetResult<Prisma.$LearningStreakPayload, S>

  type LearningStreakCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearningStreakFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearningStreakCountAggregateInputType | true
    }

  export interface LearningStreakDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningStreak'], meta: { name: 'LearningStreak' } }
    /**
     * Find zero or one LearningStreak that matches the filter.
     * @param {LearningStreakFindUniqueArgs} args - Arguments to find a LearningStreak
     * @example
     * // Get one LearningStreak
     * const learningStreak = await prisma.learningStreak.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningStreakFindUniqueArgs>(args: SelectSubset<T, LearningStreakFindUniqueArgs<ExtArgs>>): Prisma__LearningStreakClient<$Result.GetResult<Prisma.$LearningStreakPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LearningStreak that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearningStreakFindUniqueOrThrowArgs} args - Arguments to find a LearningStreak
     * @example
     * // Get one LearningStreak
     * const learningStreak = await prisma.learningStreak.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningStreakFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningStreakFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningStreakClient<$Result.GetResult<Prisma.$LearningStreakPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningStreak that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningStreakFindFirstArgs} args - Arguments to find a LearningStreak
     * @example
     * // Get one LearningStreak
     * const learningStreak = await prisma.learningStreak.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningStreakFindFirstArgs>(args?: SelectSubset<T, LearningStreakFindFirstArgs<ExtArgs>>): Prisma__LearningStreakClient<$Result.GetResult<Prisma.$LearningStreakPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LearningStreak that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningStreakFindFirstOrThrowArgs} args - Arguments to find a LearningStreak
     * @example
     * // Get one LearningStreak
     * const learningStreak = await prisma.learningStreak.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningStreakFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningStreakFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningStreakClient<$Result.GetResult<Prisma.$LearningStreakPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LearningStreaks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningStreakFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningStreaks
     * const learningStreaks = await prisma.learningStreak.findMany()
     * 
     * // Get first 10 LearningStreaks
     * const learningStreaks = await prisma.learningStreak.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningStreakWithIdOnly = await prisma.learningStreak.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningStreakFindManyArgs>(args?: SelectSubset<T, LearningStreakFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningStreakPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LearningStreak.
     * @param {LearningStreakCreateArgs} args - Arguments to create a LearningStreak.
     * @example
     * // Create one LearningStreak
     * const LearningStreak = await prisma.learningStreak.create({
     *   data: {
     *     // ... data to create a LearningStreak
     *   }
     * })
     * 
     */
    create<T extends LearningStreakCreateArgs>(args: SelectSubset<T, LearningStreakCreateArgs<ExtArgs>>): Prisma__LearningStreakClient<$Result.GetResult<Prisma.$LearningStreakPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LearningStreaks.
     * @param {LearningStreakCreateManyArgs} args - Arguments to create many LearningStreaks.
     * @example
     * // Create many LearningStreaks
     * const learningStreak = await prisma.learningStreak.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningStreakCreateManyArgs>(args?: SelectSubset<T, LearningStreakCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningStreaks and returns the data saved in the database.
     * @param {LearningStreakCreateManyAndReturnArgs} args - Arguments to create many LearningStreaks.
     * @example
     * // Create many LearningStreaks
     * const learningStreak = await prisma.learningStreak.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningStreaks and only return the `id`
     * const learningStreakWithIdOnly = await prisma.learningStreak.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningStreakCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningStreakCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningStreakPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LearningStreak.
     * @param {LearningStreakDeleteArgs} args - Arguments to delete one LearningStreak.
     * @example
     * // Delete one LearningStreak
     * const LearningStreak = await prisma.learningStreak.delete({
     *   where: {
     *     // ... filter to delete one LearningStreak
     *   }
     * })
     * 
     */
    delete<T extends LearningStreakDeleteArgs>(args: SelectSubset<T, LearningStreakDeleteArgs<ExtArgs>>): Prisma__LearningStreakClient<$Result.GetResult<Prisma.$LearningStreakPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LearningStreak.
     * @param {LearningStreakUpdateArgs} args - Arguments to update one LearningStreak.
     * @example
     * // Update one LearningStreak
     * const learningStreak = await prisma.learningStreak.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningStreakUpdateArgs>(args: SelectSubset<T, LearningStreakUpdateArgs<ExtArgs>>): Prisma__LearningStreakClient<$Result.GetResult<Prisma.$LearningStreakPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LearningStreaks.
     * @param {LearningStreakDeleteManyArgs} args - Arguments to filter LearningStreaks to delete.
     * @example
     * // Delete a few LearningStreaks
     * const { count } = await prisma.learningStreak.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningStreakDeleteManyArgs>(args?: SelectSubset<T, LearningStreakDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningStreaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningStreakUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningStreaks
     * const learningStreak = await prisma.learningStreak.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningStreakUpdateManyArgs>(args: SelectSubset<T, LearningStreakUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningStreaks and returns the data updated in the database.
     * @param {LearningStreakUpdateManyAndReturnArgs} args - Arguments to update many LearningStreaks.
     * @example
     * // Update many LearningStreaks
     * const learningStreak = await prisma.learningStreak.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LearningStreaks and only return the `id`
     * const learningStreakWithIdOnly = await prisma.learningStreak.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearningStreakUpdateManyAndReturnArgs>(args: SelectSubset<T, LearningStreakUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningStreakPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LearningStreak.
     * @param {LearningStreakUpsertArgs} args - Arguments to update or create a LearningStreak.
     * @example
     * // Update or create a LearningStreak
     * const learningStreak = await prisma.learningStreak.upsert({
     *   create: {
     *     // ... data to create a LearningStreak
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningStreak we want to update
     *   }
     * })
     */
    upsert<T extends LearningStreakUpsertArgs>(args: SelectSubset<T, LearningStreakUpsertArgs<ExtArgs>>): Prisma__LearningStreakClient<$Result.GetResult<Prisma.$LearningStreakPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LearningStreaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningStreakCountArgs} args - Arguments to filter LearningStreaks to count.
     * @example
     * // Count the number of LearningStreaks
     * const count = await prisma.learningStreak.count({
     *   where: {
     *     // ... the filter for the LearningStreaks we want to count
     *   }
     * })
    **/
    count<T extends LearningStreakCountArgs>(
      args?: Subset<T, LearningStreakCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningStreakCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningStreak.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningStreakAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningStreakAggregateArgs>(args: Subset<T, LearningStreakAggregateArgs>): Prisma.PrismaPromise<GetLearningStreakAggregateType<T>>

    /**
     * Group by LearningStreak.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningStreakGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningStreakGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningStreakGroupByArgs['orderBy'] }
        : { orderBy?: LearningStreakGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningStreakGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningStreakGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningStreak model
   */
  readonly fields: LearningStreakFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningStreak.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningStreakClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningStreak model
   */
  interface LearningStreakFieldRefs {
    readonly id: FieldRef<"LearningStreak", 'String'>
    readonly userId: FieldRef<"LearningStreak", 'String'>
    readonly currentStreak: FieldRef<"LearningStreak", 'Int'>
    readonly longestStreak: FieldRef<"LearningStreak", 'Int'>
    readonly lastActivity: FieldRef<"LearningStreak", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearningStreak findUnique
   */
  export type LearningStreakFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningStreak
     */
    select?: LearningStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningStreak
     */
    omit?: LearningStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningStreakInclude<ExtArgs> | null
    /**
     * Filter, which LearningStreak to fetch.
     */
    where: LearningStreakWhereUniqueInput
  }

  /**
   * LearningStreak findUniqueOrThrow
   */
  export type LearningStreakFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningStreak
     */
    select?: LearningStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningStreak
     */
    omit?: LearningStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningStreakInclude<ExtArgs> | null
    /**
     * Filter, which LearningStreak to fetch.
     */
    where: LearningStreakWhereUniqueInput
  }

  /**
   * LearningStreak findFirst
   */
  export type LearningStreakFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningStreak
     */
    select?: LearningStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningStreak
     */
    omit?: LearningStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningStreakInclude<ExtArgs> | null
    /**
     * Filter, which LearningStreak to fetch.
     */
    where?: LearningStreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningStreaks to fetch.
     */
    orderBy?: LearningStreakOrderByWithRelationInput | LearningStreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningStreaks.
     */
    cursor?: LearningStreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningStreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningStreaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningStreaks.
     */
    distinct?: LearningStreakScalarFieldEnum | LearningStreakScalarFieldEnum[]
  }

  /**
   * LearningStreak findFirstOrThrow
   */
  export type LearningStreakFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningStreak
     */
    select?: LearningStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningStreak
     */
    omit?: LearningStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningStreakInclude<ExtArgs> | null
    /**
     * Filter, which LearningStreak to fetch.
     */
    where?: LearningStreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningStreaks to fetch.
     */
    orderBy?: LearningStreakOrderByWithRelationInput | LearningStreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningStreaks.
     */
    cursor?: LearningStreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningStreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningStreaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningStreaks.
     */
    distinct?: LearningStreakScalarFieldEnum | LearningStreakScalarFieldEnum[]
  }

  /**
   * LearningStreak findMany
   */
  export type LearningStreakFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningStreak
     */
    select?: LearningStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningStreak
     */
    omit?: LearningStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningStreakInclude<ExtArgs> | null
    /**
     * Filter, which LearningStreaks to fetch.
     */
    where?: LearningStreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningStreaks to fetch.
     */
    orderBy?: LearningStreakOrderByWithRelationInput | LearningStreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningStreaks.
     */
    cursor?: LearningStreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningStreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningStreaks.
     */
    skip?: number
    distinct?: LearningStreakScalarFieldEnum | LearningStreakScalarFieldEnum[]
  }

  /**
   * LearningStreak create
   */
  export type LearningStreakCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningStreak
     */
    select?: LearningStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningStreak
     */
    omit?: LearningStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningStreakInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningStreak.
     */
    data: XOR<LearningStreakCreateInput, LearningStreakUncheckedCreateInput>
  }

  /**
   * LearningStreak createMany
   */
  export type LearningStreakCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningStreaks.
     */
    data: LearningStreakCreateManyInput | LearningStreakCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningStreak createManyAndReturn
   */
  export type LearningStreakCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningStreak
     */
    select?: LearningStreakSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningStreak
     */
    omit?: LearningStreakOmit<ExtArgs> | null
    /**
     * The data used to create many LearningStreaks.
     */
    data: LearningStreakCreateManyInput | LearningStreakCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningStreakIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningStreak update
   */
  export type LearningStreakUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningStreak
     */
    select?: LearningStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningStreak
     */
    omit?: LearningStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningStreakInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningStreak.
     */
    data: XOR<LearningStreakUpdateInput, LearningStreakUncheckedUpdateInput>
    /**
     * Choose, which LearningStreak to update.
     */
    where: LearningStreakWhereUniqueInput
  }

  /**
   * LearningStreak updateMany
   */
  export type LearningStreakUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningStreaks.
     */
    data: XOR<LearningStreakUpdateManyMutationInput, LearningStreakUncheckedUpdateManyInput>
    /**
     * Filter which LearningStreaks to update
     */
    where?: LearningStreakWhereInput
    /**
     * Limit how many LearningStreaks to update.
     */
    limit?: number
  }

  /**
   * LearningStreak updateManyAndReturn
   */
  export type LearningStreakUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningStreak
     */
    select?: LearningStreakSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LearningStreak
     */
    omit?: LearningStreakOmit<ExtArgs> | null
    /**
     * The data used to update LearningStreaks.
     */
    data: XOR<LearningStreakUpdateManyMutationInput, LearningStreakUncheckedUpdateManyInput>
    /**
     * Filter which LearningStreaks to update
     */
    where?: LearningStreakWhereInput
    /**
     * Limit how many LearningStreaks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningStreakIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningStreak upsert
   */
  export type LearningStreakUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningStreak
     */
    select?: LearningStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningStreak
     */
    omit?: LearningStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningStreakInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningStreak to update in case it exists.
     */
    where: LearningStreakWhereUniqueInput
    /**
     * In case the LearningStreak found by the `where` argument doesn't exist, create a new LearningStreak with this data.
     */
    create: XOR<LearningStreakCreateInput, LearningStreakUncheckedCreateInput>
    /**
     * In case the LearningStreak was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningStreakUpdateInput, LearningStreakUncheckedUpdateInput>
  }

  /**
   * LearningStreak delete
   */
  export type LearningStreakDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningStreak
     */
    select?: LearningStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningStreak
     */
    omit?: LearningStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningStreakInclude<ExtArgs> | null
    /**
     * Filter which LearningStreak to delete.
     */
    where: LearningStreakWhereUniqueInput
  }

  /**
   * LearningStreak deleteMany
   */
  export type LearningStreakDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningStreaks to delete
     */
    where?: LearningStreakWhereInput
    /**
     * Limit how many LearningStreaks to delete.
     */
    limit?: number
  }

  /**
   * LearningStreak without action
   */
  export type LearningStreakDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningStreak
     */
    select?: LearningStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LearningStreak
     */
    omit?: LearningStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningStreakInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    progress: number | null
  }

  export type AchievementSumAggregateOutputType = {
    progress: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    userId: string | null
    title: string | null
    description: string | null
    icon: string | null
    category: $Enums.AchievementCategory | null
    progress: number | null
    completed: boolean | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    userId: string | null
    title: string | null
    description: string | null
    icon: string | null
    category: $Enums.AchievementCategory | null
    progress: number | null
    completed: boolean | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    createdAt: number
    userId: number
    title: number
    description: number
    icon: number
    category: number
    progress: number
    completed: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    progress?: true
  }

  export type AchievementSumAggregateInputType = {
    progress?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    title?: true
    description?: true
    icon?: true
    category?: true
    progress?: true
    completed?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    title?: true
    description?: true
    icon?: true
    category?: true
    progress?: true
    completed?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    title?: true
    description?: true
    icon?: true
    category?: true
    progress?: true
    completed?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    createdAt: Date
    userId: string
    title: string
    description: string
    icon: string
    category: $Enums.AchievementCategory
    progress: number
    completed: boolean
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    progress?: boolean
    completed?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    progress?: boolean
    completed?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    progress?: boolean
    completed?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    progress?: boolean
    completed?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "userId" | "title" | "description" | "icon" | "category" | "progress" | "completed", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      userId: string
      title: string
      description: string
      icon: string
      category: $Enums.AchievementCategory
      progress: number
      completed: boolean
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
    readonly userId: FieldRef<"Achievement", 'String'>
    readonly title: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly icon: FieldRef<"Achievement", 'String'>
    readonly category: FieldRef<"Achievement", 'AchievementCategory'>
    readonly progress: FieldRef<"Achievement", 'Float'>
    readonly completed: FieldRef<"Achievement", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model ChatSession
   */

  export type AggregateChatSession = {
    _count: ChatSessionCountAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  export type ChatSessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    title: string | null
    topic: string | null
    isActive: boolean | null
  }

  export type ChatSessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    title: string | null
    topic: string | null
    isActive: boolean | null
  }

  export type ChatSessionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    title: number
    topic: number
    isActive: number
    _all: number
  }


  export type ChatSessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    title?: true
    topic?: true
    isActive?: true
  }

  export type ChatSessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    title?: true
    topic?: true
    isActive?: true
  }

  export type ChatSessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    title?: true
    topic?: true
    isActive?: true
    _all?: true
  }

  export type ChatSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatSession to aggregate.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatSessions
    **/
    _count?: true | ChatSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatSessionMaxAggregateInputType
  }

  export type GetChatSessionAggregateType<T extends ChatSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateChatSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatSession[P]>
      : GetScalarType<T[P], AggregateChatSession[P]>
  }




  export type ChatSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatSessionWhereInput
    orderBy?: ChatSessionOrderByWithAggregationInput | ChatSessionOrderByWithAggregationInput[]
    by: ChatSessionScalarFieldEnum[] | ChatSessionScalarFieldEnum
    having?: ChatSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatSessionCountAggregateInputType | true
    _min?: ChatSessionMinAggregateInputType
    _max?: ChatSessionMaxAggregateInputType
  }

  export type ChatSessionGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    userId: string
    title: string | null
    topic: string | null
    isActive: boolean
    _count: ChatSessionCountAggregateOutputType | null
    _min: ChatSessionMinAggregateOutputType | null
    _max: ChatSessionMaxAggregateOutputType | null
  }

  type GetChatSessionGroupByPayload<T extends ChatSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ChatSessionGroupByOutputType[P]>
        }
      >
    >


  export type ChatSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    title?: boolean
    topic?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | ChatSession$messagesArgs<ExtArgs>
    _count?: boolean | ChatSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    title?: boolean
    topic?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    title?: boolean
    topic?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatSession"]>

  export type ChatSessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    title?: boolean
    topic?: boolean
    isActive?: boolean
  }

  export type ChatSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "userId" | "title" | "topic" | "isActive", ExtArgs["result"]["chatSession"]>
  export type ChatSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | ChatSession$messagesArgs<ExtArgs>
    _count?: boolean | ChatSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      userId: string
      title: string | null
      topic: string | null
      isActive: boolean
    }, ExtArgs["result"]["chatSession"]>
    composites: {}
  }

  type ChatSessionGetPayload<S extends boolean | null | undefined | ChatSessionDefaultArgs> = $Result.GetResult<Prisma.$ChatSessionPayload, S>

  type ChatSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatSessionCountAggregateInputType | true
    }

  export interface ChatSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatSession'], meta: { name: 'ChatSession' } }
    /**
     * Find zero or one ChatSession that matches the filter.
     * @param {ChatSessionFindUniqueArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatSessionFindUniqueArgs>(args: SelectSubset<T, ChatSessionFindUniqueArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatSessionFindUniqueOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatSessionFindFirstArgs>(args?: SelectSubset<T, ChatSessionFindFirstArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindFirstOrThrowArgs} args - Arguments to find a ChatSession
     * @example
     * // Get one ChatSession
     * const chatSession = await prisma.chatSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatSessions
     * const chatSessions = await prisma.chatSession.findMany()
     * 
     * // Get first 10 ChatSessions
     * const chatSessions = await prisma.chatSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatSessionFindManyArgs>(args?: SelectSubset<T, ChatSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatSession.
     * @param {ChatSessionCreateArgs} args - Arguments to create a ChatSession.
     * @example
     * // Create one ChatSession
     * const ChatSession = await prisma.chatSession.create({
     *   data: {
     *     // ... data to create a ChatSession
     *   }
     * })
     * 
     */
    create<T extends ChatSessionCreateArgs>(args: SelectSubset<T, ChatSessionCreateArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatSessions.
     * @param {ChatSessionCreateManyArgs} args - Arguments to create many ChatSessions.
     * @example
     * // Create many ChatSessions
     * const chatSession = await prisma.chatSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatSessionCreateManyArgs>(args?: SelectSubset<T, ChatSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatSessions and returns the data saved in the database.
     * @param {ChatSessionCreateManyAndReturnArgs} args - Arguments to create many ChatSessions.
     * @example
     * // Create many ChatSessions
     * const chatSession = await prisma.chatSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatSessions and only return the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatSession.
     * @param {ChatSessionDeleteArgs} args - Arguments to delete one ChatSession.
     * @example
     * // Delete one ChatSession
     * const ChatSession = await prisma.chatSession.delete({
     *   where: {
     *     // ... filter to delete one ChatSession
     *   }
     * })
     * 
     */
    delete<T extends ChatSessionDeleteArgs>(args: SelectSubset<T, ChatSessionDeleteArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatSession.
     * @param {ChatSessionUpdateArgs} args - Arguments to update one ChatSession.
     * @example
     * // Update one ChatSession
     * const chatSession = await prisma.chatSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatSessionUpdateArgs>(args: SelectSubset<T, ChatSessionUpdateArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatSessions.
     * @param {ChatSessionDeleteManyArgs} args - Arguments to filter ChatSessions to delete.
     * @example
     * // Delete a few ChatSessions
     * const { count } = await prisma.chatSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatSessionDeleteManyArgs>(args?: SelectSubset<T, ChatSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatSessions
     * const chatSession = await prisma.chatSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatSessionUpdateManyArgs>(args: SelectSubset<T, ChatSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatSessions and returns the data updated in the database.
     * @param {ChatSessionUpdateManyAndReturnArgs} args - Arguments to update many ChatSessions.
     * @example
     * // Update many ChatSessions
     * const chatSession = await prisma.chatSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatSessions and only return the `id`
     * const chatSessionWithIdOnly = await prisma.chatSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatSession.
     * @param {ChatSessionUpsertArgs} args - Arguments to update or create a ChatSession.
     * @example
     * // Update or create a ChatSession
     * const chatSession = await prisma.chatSession.upsert({
     *   create: {
     *     // ... data to create a ChatSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatSession we want to update
     *   }
     * })
     */
    upsert<T extends ChatSessionUpsertArgs>(args: SelectSubset<T, ChatSessionUpsertArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionCountArgs} args - Arguments to filter ChatSessions to count.
     * @example
     * // Count the number of ChatSessions
     * const count = await prisma.chatSession.count({
     *   where: {
     *     // ... the filter for the ChatSessions we want to count
     *   }
     * })
    **/
    count<T extends ChatSessionCountArgs>(
      args?: Subset<T, ChatSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatSessionAggregateArgs>(args: Subset<T, ChatSessionAggregateArgs>): Prisma.PrismaPromise<GetChatSessionAggregateType<T>>

    /**
     * Group by ChatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatSessionGroupByArgs['orderBy'] }
        : { orderBy?: ChatSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatSession model
   */
  readonly fields: ChatSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends ChatSession$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatSession$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatSession model
   */
  interface ChatSessionFieldRefs {
    readonly id: FieldRef<"ChatSession", 'String'>
    readonly createdAt: FieldRef<"ChatSession", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatSession", 'DateTime'>
    readonly userId: FieldRef<"ChatSession", 'String'>
    readonly title: FieldRef<"ChatSession", 'String'>
    readonly topic: FieldRef<"ChatSession", 'String'>
    readonly isActive: FieldRef<"ChatSession", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ChatSession findUnique
   */
  export type ChatSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession findUniqueOrThrow
   */
  export type ChatSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession findFirst
   */
  export type ChatSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession findFirstOrThrow
   */
  export type ChatSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSession to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatSessions.
     */
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession findMany
   */
  export type ChatSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter, which ChatSessions to fetch.
     */
    where?: ChatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatSessions to fetch.
     */
    orderBy?: ChatSessionOrderByWithRelationInput | ChatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatSessions.
     */
    cursor?: ChatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatSessions.
     */
    skip?: number
    distinct?: ChatSessionScalarFieldEnum | ChatSessionScalarFieldEnum[]
  }

  /**
   * ChatSession create
   */
  export type ChatSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatSession.
     */
    data: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
  }

  /**
   * ChatSession createMany
   */
  export type ChatSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatSessions.
     */
    data: ChatSessionCreateManyInput | ChatSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatSession createManyAndReturn
   */
  export type ChatSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * The data used to create many ChatSessions.
     */
    data: ChatSessionCreateManyInput | ChatSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatSession update
   */
  export type ChatSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatSession.
     */
    data: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
    /**
     * Choose, which ChatSession to update.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession updateMany
   */
  export type ChatSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatSessions.
     */
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyInput>
    /**
     * Filter which ChatSessions to update
     */
    where?: ChatSessionWhereInput
    /**
     * Limit how many ChatSessions to update.
     */
    limit?: number
  }

  /**
   * ChatSession updateManyAndReturn
   */
  export type ChatSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * The data used to update ChatSessions.
     */
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyInput>
    /**
     * Filter which ChatSessions to update
     */
    where?: ChatSessionWhereInput
    /**
     * Limit how many ChatSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatSession upsert
   */
  export type ChatSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatSession to update in case it exists.
     */
    where: ChatSessionWhereUniqueInput
    /**
     * In case the ChatSession found by the `where` argument doesn't exist, create a new ChatSession with this data.
     */
    create: XOR<ChatSessionCreateInput, ChatSessionUncheckedCreateInput>
    /**
     * In case the ChatSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatSessionUpdateInput, ChatSessionUncheckedUpdateInput>
  }

  /**
   * ChatSession delete
   */
  export type ChatSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
    /**
     * Filter which ChatSession to delete.
     */
    where: ChatSessionWhereUniqueInput
  }

  /**
   * ChatSession deleteMany
   */
  export type ChatSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatSessions to delete
     */
    where?: ChatSessionWhereInput
    /**
     * Limit how many ChatSessions to delete.
     */
    limit?: number
  }

  /**
   * ChatSession.messages
   */
  export type ChatSession$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatSession without action
   */
  export type ChatSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatSession
     */
    select?: ChatSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatSession
     */
    omit?: ChatSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatSessionInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    sessionId: string | null
    content: string | null
    type: string | null
    imageUrl: string | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    sessionId: string | null
    content: string | null
    type: string | null
    imageUrl: string | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    createdAt: number
    sessionId: number
    content: number
    type: number
    metadata: number
    imageUrl: number
    links: number
    keywords: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    createdAt?: true
    sessionId?: true
    content?: true
    type?: true
    imageUrl?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    sessionId?: true
    content?: true
    type?: true
    imageUrl?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    createdAt?: true
    sessionId?: true
    content?: true
    type?: true
    metadata?: true
    imageUrl?: true
    links?: true
    keywords?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    createdAt: Date
    sessionId: string
    content: string
    type: string
    metadata: JsonValue | null
    imageUrl: string | null
    links: JsonValue | null
    keywords: string[]
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    sessionId?: boolean
    content?: boolean
    type?: boolean
    metadata?: boolean
    imageUrl?: boolean
    links?: boolean
    keywords?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    sessionId?: boolean
    content?: boolean
    type?: boolean
    metadata?: boolean
    imageUrl?: boolean
    links?: boolean
    keywords?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    sessionId?: boolean
    content?: boolean
    type?: boolean
    metadata?: boolean
    imageUrl?: boolean
    links?: boolean
    keywords?: boolean
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    sessionId?: boolean
    content?: boolean
    type?: boolean
    metadata?: boolean
    imageUrl?: boolean
    links?: boolean
    keywords?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "sessionId" | "content" | "type" | "metadata" | "imageUrl" | "links" | "keywords", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | ChatSessionDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      session: Prisma.$ChatSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      sessionId: string
      content: string
      type: string
      metadata: Prisma.JsonValue | null
      imageUrl: string | null
      links: Prisma.JsonValue | null
      keywords: string[]
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends ChatSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatSessionDefaultArgs<ExtArgs>>): Prisma__ChatSessionClient<$Result.GetResult<Prisma.$ChatSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
    readonly sessionId: FieldRef<"ChatMessage", 'String'>
    readonly content: FieldRef<"ChatMessage", 'String'>
    readonly type: FieldRef<"ChatMessage", 'String'>
    readonly metadata: FieldRef<"ChatMessage", 'Json'>
    readonly imageUrl: FieldRef<"ChatMessage", 'String'>
    readonly links: FieldRef<"ChatMessage", 'Json'>
    readonly keywords: FieldRef<"ChatMessage", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model SATStudyPlan
   */

  export type AggregateSATStudyPlan = {
    _count: SATStudyPlanCountAggregateOutputType | null
    _avg: SATStudyPlanAvgAggregateOutputType | null
    _sum: SATStudyPlanSumAggregateOutputType | null
    _min: SATStudyPlanMinAggregateOutputType | null
    _max: SATStudyPlanMaxAggregateOutputType | null
  }

  export type SATStudyPlanAvgAggregateOutputType = {
    completedWeeks: number | null
  }

  export type SATStudyPlanSumAggregateOutputType = {
    completedWeeks: number[]
  }

  export type SATStudyPlanMinAggregateOutputType = {
    id: string | null
    userId: string | null
    timeline: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SATStudyPlanMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    timeline: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SATStudyPlanCountAggregateOutputType = {
    id: number
    userId: number
    timeline: number
    focusAreas: number
    weeklySchedule: number
    resourceRecommendations: number
    aiGeneratedPlan: number
    completedWeeks: number
    completedTasks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SATStudyPlanAvgAggregateInputType = {
    completedWeeks?: true
  }

  export type SATStudyPlanSumAggregateInputType = {
    completedWeeks?: true
  }

  export type SATStudyPlanMinAggregateInputType = {
    id?: true
    userId?: true
    timeline?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SATStudyPlanMaxAggregateInputType = {
    id?: true
    userId?: true
    timeline?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SATStudyPlanCountAggregateInputType = {
    id?: true
    userId?: true
    timeline?: true
    focusAreas?: true
    weeklySchedule?: true
    resourceRecommendations?: true
    aiGeneratedPlan?: true
    completedWeeks?: true
    completedTasks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SATStudyPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SATStudyPlan to aggregate.
     */
    where?: SATStudyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SATStudyPlans to fetch.
     */
    orderBy?: SATStudyPlanOrderByWithRelationInput | SATStudyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SATStudyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SATStudyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SATStudyPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SATStudyPlans
    **/
    _count?: true | SATStudyPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SATStudyPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SATStudyPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SATStudyPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SATStudyPlanMaxAggregateInputType
  }

  export type GetSATStudyPlanAggregateType<T extends SATStudyPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateSATStudyPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSATStudyPlan[P]>
      : GetScalarType<T[P], AggregateSATStudyPlan[P]>
  }




  export type SATStudyPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SATStudyPlanWhereInput
    orderBy?: SATStudyPlanOrderByWithAggregationInput | SATStudyPlanOrderByWithAggregationInput[]
    by: SATStudyPlanScalarFieldEnum[] | SATStudyPlanScalarFieldEnum
    having?: SATStudyPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SATStudyPlanCountAggregateInputType | true
    _avg?: SATStudyPlanAvgAggregateInputType
    _sum?: SATStudyPlanSumAggregateInputType
    _min?: SATStudyPlanMinAggregateInputType
    _max?: SATStudyPlanMaxAggregateInputType
  }

  export type SATStudyPlanGroupByOutputType = {
    id: string
    userId: string
    timeline: string
    focusAreas: JsonValue
    weeklySchedule: JsonValue
    resourceRecommendations: JsonValue
    aiGeneratedPlan: JsonValue | null
    completedWeeks: number[]
    completedTasks: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: SATStudyPlanCountAggregateOutputType | null
    _avg: SATStudyPlanAvgAggregateOutputType | null
    _sum: SATStudyPlanSumAggregateOutputType | null
    _min: SATStudyPlanMinAggregateOutputType | null
    _max: SATStudyPlanMaxAggregateOutputType | null
  }

  type GetSATStudyPlanGroupByPayload<T extends SATStudyPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SATStudyPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SATStudyPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SATStudyPlanGroupByOutputType[P]>
            : GetScalarType<T[P], SATStudyPlanGroupByOutputType[P]>
        }
      >
    >


  export type SATStudyPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    timeline?: boolean
    focusAreas?: boolean
    weeklySchedule?: boolean
    resourceRecommendations?: boolean
    aiGeneratedPlan?: boolean
    completedWeeks?: boolean
    completedTasks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sATStudyPlan"]>

  export type SATStudyPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    timeline?: boolean
    focusAreas?: boolean
    weeklySchedule?: boolean
    resourceRecommendations?: boolean
    aiGeneratedPlan?: boolean
    completedWeeks?: boolean
    completedTasks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sATStudyPlan"]>

  export type SATStudyPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    timeline?: boolean
    focusAreas?: boolean
    weeklySchedule?: boolean
    resourceRecommendations?: boolean
    aiGeneratedPlan?: boolean
    completedWeeks?: boolean
    completedTasks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sATStudyPlan"]>

  export type SATStudyPlanSelectScalar = {
    id?: boolean
    userId?: boolean
    timeline?: boolean
    focusAreas?: boolean
    weeklySchedule?: boolean
    resourceRecommendations?: boolean
    aiGeneratedPlan?: boolean
    completedWeeks?: boolean
    completedTasks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SATStudyPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "timeline" | "focusAreas" | "weeklySchedule" | "resourceRecommendations" | "aiGeneratedPlan" | "completedWeeks" | "completedTasks" | "createdAt" | "updatedAt", ExtArgs["result"]["sATStudyPlan"]>
  export type SATStudyPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SATStudyPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SATStudyPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SATStudyPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SATStudyPlan"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      timeline: string
      focusAreas: Prisma.JsonValue
      weeklySchedule: Prisma.JsonValue
      resourceRecommendations: Prisma.JsonValue
      aiGeneratedPlan: Prisma.JsonValue | null
      completedWeeks: number[]
      completedTasks: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sATStudyPlan"]>
    composites: {}
  }

  type SATStudyPlanGetPayload<S extends boolean | null | undefined | SATStudyPlanDefaultArgs> = $Result.GetResult<Prisma.$SATStudyPlanPayload, S>

  type SATStudyPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SATStudyPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SATStudyPlanCountAggregateInputType | true
    }

  export interface SATStudyPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SATStudyPlan'], meta: { name: 'SATStudyPlan' } }
    /**
     * Find zero or one SATStudyPlan that matches the filter.
     * @param {SATStudyPlanFindUniqueArgs} args - Arguments to find a SATStudyPlan
     * @example
     * // Get one SATStudyPlan
     * const sATStudyPlan = await prisma.sATStudyPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SATStudyPlanFindUniqueArgs>(args: SelectSubset<T, SATStudyPlanFindUniqueArgs<ExtArgs>>): Prisma__SATStudyPlanClient<$Result.GetResult<Prisma.$SATStudyPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SATStudyPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SATStudyPlanFindUniqueOrThrowArgs} args - Arguments to find a SATStudyPlan
     * @example
     * // Get one SATStudyPlan
     * const sATStudyPlan = await prisma.sATStudyPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SATStudyPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, SATStudyPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SATStudyPlanClient<$Result.GetResult<Prisma.$SATStudyPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SATStudyPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATStudyPlanFindFirstArgs} args - Arguments to find a SATStudyPlan
     * @example
     * // Get one SATStudyPlan
     * const sATStudyPlan = await prisma.sATStudyPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SATStudyPlanFindFirstArgs>(args?: SelectSubset<T, SATStudyPlanFindFirstArgs<ExtArgs>>): Prisma__SATStudyPlanClient<$Result.GetResult<Prisma.$SATStudyPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SATStudyPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATStudyPlanFindFirstOrThrowArgs} args - Arguments to find a SATStudyPlan
     * @example
     * // Get one SATStudyPlan
     * const sATStudyPlan = await prisma.sATStudyPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SATStudyPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, SATStudyPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__SATStudyPlanClient<$Result.GetResult<Prisma.$SATStudyPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SATStudyPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATStudyPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SATStudyPlans
     * const sATStudyPlans = await prisma.sATStudyPlan.findMany()
     * 
     * // Get first 10 SATStudyPlans
     * const sATStudyPlans = await prisma.sATStudyPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sATStudyPlanWithIdOnly = await prisma.sATStudyPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SATStudyPlanFindManyArgs>(args?: SelectSubset<T, SATStudyPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SATStudyPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SATStudyPlan.
     * @param {SATStudyPlanCreateArgs} args - Arguments to create a SATStudyPlan.
     * @example
     * // Create one SATStudyPlan
     * const SATStudyPlan = await prisma.sATStudyPlan.create({
     *   data: {
     *     // ... data to create a SATStudyPlan
     *   }
     * })
     * 
     */
    create<T extends SATStudyPlanCreateArgs>(args: SelectSubset<T, SATStudyPlanCreateArgs<ExtArgs>>): Prisma__SATStudyPlanClient<$Result.GetResult<Prisma.$SATStudyPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SATStudyPlans.
     * @param {SATStudyPlanCreateManyArgs} args - Arguments to create many SATStudyPlans.
     * @example
     * // Create many SATStudyPlans
     * const sATStudyPlan = await prisma.sATStudyPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SATStudyPlanCreateManyArgs>(args?: SelectSubset<T, SATStudyPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SATStudyPlans and returns the data saved in the database.
     * @param {SATStudyPlanCreateManyAndReturnArgs} args - Arguments to create many SATStudyPlans.
     * @example
     * // Create many SATStudyPlans
     * const sATStudyPlan = await prisma.sATStudyPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SATStudyPlans and only return the `id`
     * const sATStudyPlanWithIdOnly = await prisma.sATStudyPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SATStudyPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, SATStudyPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SATStudyPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SATStudyPlan.
     * @param {SATStudyPlanDeleteArgs} args - Arguments to delete one SATStudyPlan.
     * @example
     * // Delete one SATStudyPlan
     * const SATStudyPlan = await prisma.sATStudyPlan.delete({
     *   where: {
     *     // ... filter to delete one SATStudyPlan
     *   }
     * })
     * 
     */
    delete<T extends SATStudyPlanDeleteArgs>(args: SelectSubset<T, SATStudyPlanDeleteArgs<ExtArgs>>): Prisma__SATStudyPlanClient<$Result.GetResult<Prisma.$SATStudyPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SATStudyPlan.
     * @param {SATStudyPlanUpdateArgs} args - Arguments to update one SATStudyPlan.
     * @example
     * // Update one SATStudyPlan
     * const sATStudyPlan = await prisma.sATStudyPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SATStudyPlanUpdateArgs>(args: SelectSubset<T, SATStudyPlanUpdateArgs<ExtArgs>>): Prisma__SATStudyPlanClient<$Result.GetResult<Prisma.$SATStudyPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SATStudyPlans.
     * @param {SATStudyPlanDeleteManyArgs} args - Arguments to filter SATStudyPlans to delete.
     * @example
     * // Delete a few SATStudyPlans
     * const { count } = await prisma.sATStudyPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SATStudyPlanDeleteManyArgs>(args?: SelectSubset<T, SATStudyPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SATStudyPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATStudyPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SATStudyPlans
     * const sATStudyPlan = await prisma.sATStudyPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SATStudyPlanUpdateManyArgs>(args: SelectSubset<T, SATStudyPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SATStudyPlans and returns the data updated in the database.
     * @param {SATStudyPlanUpdateManyAndReturnArgs} args - Arguments to update many SATStudyPlans.
     * @example
     * // Update many SATStudyPlans
     * const sATStudyPlan = await prisma.sATStudyPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SATStudyPlans and only return the `id`
     * const sATStudyPlanWithIdOnly = await prisma.sATStudyPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SATStudyPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, SATStudyPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SATStudyPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SATStudyPlan.
     * @param {SATStudyPlanUpsertArgs} args - Arguments to update or create a SATStudyPlan.
     * @example
     * // Update or create a SATStudyPlan
     * const sATStudyPlan = await prisma.sATStudyPlan.upsert({
     *   create: {
     *     // ... data to create a SATStudyPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SATStudyPlan we want to update
     *   }
     * })
     */
    upsert<T extends SATStudyPlanUpsertArgs>(args: SelectSubset<T, SATStudyPlanUpsertArgs<ExtArgs>>): Prisma__SATStudyPlanClient<$Result.GetResult<Prisma.$SATStudyPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SATStudyPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATStudyPlanCountArgs} args - Arguments to filter SATStudyPlans to count.
     * @example
     * // Count the number of SATStudyPlans
     * const count = await prisma.sATStudyPlan.count({
     *   where: {
     *     // ... the filter for the SATStudyPlans we want to count
     *   }
     * })
    **/
    count<T extends SATStudyPlanCountArgs>(
      args?: Subset<T, SATStudyPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SATStudyPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SATStudyPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATStudyPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SATStudyPlanAggregateArgs>(args: Subset<T, SATStudyPlanAggregateArgs>): Prisma.PrismaPromise<GetSATStudyPlanAggregateType<T>>

    /**
     * Group by SATStudyPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATStudyPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SATStudyPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SATStudyPlanGroupByArgs['orderBy'] }
        : { orderBy?: SATStudyPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SATStudyPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSATStudyPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SATStudyPlan model
   */
  readonly fields: SATStudyPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SATStudyPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SATStudyPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SATStudyPlan model
   */
  interface SATStudyPlanFieldRefs {
    readonly id: FieldRef<"SATStudyPlan", 'String'>
    readonly userId: FieldRef<"SATStudyPlan", 'String'>
    readonly timeline: FieldRef<"SATStudyPlan", 'String'>
    readonly focusAreas: FieldRef<"SATStudyPlan", 'Json'>
    readonly weeklySchedule: FieldRef<"SATStudyPlan", 'Json'>
    readonly resourceRecommendations: FieldRef<"SATStudyPlan", 'Json'>
    readonly aiGeneratedPlan: FieldRef<"SATStudyPlan", 'Json'>
    readonly completedWeeks: FieldRef<"SATStudyPlan", 'Int[]'>
    readonly completedTasks: FieldRef<"SATStudyPlan", 'Json'>
    readonly createdAt: FieldRef<"SATStudyPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"SATStudyPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SATStudyPlan findUnique
   */
  export type SATStudyPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATStudyPlan
     */
    select?: SATStudyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATStudyPlan
     */
    omit?: SATStudyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATStudyPlanInclude<ExtArgs> | null
    /**
     * Filter, which SATStudyPlan to fetch.
     */
    where: SATStudyPlanWhereUniqueInput
  }

  /**
   * SATStudyPlan findUniqueOrThrow
   */
  export type SATStudyPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATStudyPlan
     */
    select?: SATStudyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATStudyPlan
     */
    omit?: SATStudyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATStudyPlanInclude<ExtArgs> | null
    /**
     * Filter, which SATStudyPlan to fetch.
     */
    where: SATStudyPlanWhereUniqueInput
  }

  /**
   * SATStudyPlan findFirst
   */
  export type SATStudyPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATStudyPlan
     */
    select?: SATStudyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATStudyPlan
     */
    omit?: SATStudyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATStudyPlanInclude<ExtArgs> | null
    /**
     * Filter, which SATStudyPlan to fetch.
     */
    where?: SATStudyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SATStudyPlans to fetch.
     */
    orderBy?: SATStudyPlanOrderByWithRelationInput | SATStudyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SATStudyPlans.
     */
    cursor?: SATStudyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SATStudyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SATStudyPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SATStudyPlans.
     */
    distinct?: SATStudyPlanScalarFieldEnum | SATStudyPlanScalarFieldEnum[]
  }

  /**
   * SATStudyPlan findFirstOrThrow
   */
  export type SATStudyPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATStudyPlan
     */
    select?: SATStudyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATStudyPlan
     */
    omit?: SATStudyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATStudyPlanInclude<ExtArgs> | null
    /**
     * Filter, which SATStudyPlan to fetch.
     */
    where?: SATStudyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SATStudyPlans to fetch.
     */
    orderBy?: SATStudyPlanOrderByWithRelationInput | SATStudyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SATStudyPlans.
     */
    cursor?: SATStudyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SATStudyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SATStudyPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SATStudyPlans.
     */
    distinct?: SATStudyPlanScalarFieldEnum | SATStudyPlanScalarFieldEnum[]
  }

  /**
   * SATStudyPlan findMany
   */
  export type SATStudyPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATStudyPlan
     */
    select?: SATStudyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATStudyPlan
     */
    omit?: SATStudyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATStudyPlanInclude<ExtArgs> | null
    /**
     * Filter, which SATStudyPlans to fetch.
     */
    where?: SATStudyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SATStudyPlans to fetch.
     */
    orderBy?: SATStudyPlanOrderByWithRelationInput | SATStudyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SATStudyPlans.
     */
    cursor?: SATStudyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SATStudyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SATStudyPlans.
     */
    skip?: number
    distinct?: SATStudyPlanScalarFieldEnum | SATStudyPlanScalarFieldEnum[]
  }

  /**
   * SATStudyPlan create
   */
  export type SATStudyPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATStudyPlan
     */
    select?: SATStudyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATStudyPlan
     */
    omit?: SATStudyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATStudyPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a SATStudyPlan.
     */
    data: XOR<SATStudyPlanCreateInput, SATStudyPlanUncheckedCreateInput>
  }

  /**
   * SATStudyPlan createMany
   */
  export type SATStudyPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SATStudyPlans.
     */
    data: SATStudyPlanCreateManyInput | SATStudyPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SATStudyPlan createManyAndReturn
   */
  export type SATStudyPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATStudyPlan
     */
    select?: SATStudyPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SATStudyPlan
     */
    omit?: SATStudyPlanOmit<ExtArgs> | null
    /**
     * The data used to create many SATStudyPlans.
     */
    data: SATStudyPlanCreateManyInput | SATStudyPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATStudyPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SATStudyPlan update
   */
  export type SATStudyPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATStudyPlan
     */
    select?: SATStudyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATStudyPlan
     */
    omit?: SATStudyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATStudyPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a SATStudyPlan.
     */
    data: XOR<SATStudyPlanUpdateInput, SATStudyPlanUncheckedUpdateInput>
    /**
     * Choose, which SATStudyPlan to update.
     */
    where: SATStudyPlanWhereUniqueInput
  }

  /**
   * SATStudyPlan updateMany
   */
  export type SATStudyPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SATStudyPlans.
     */
    data: XOR<SATStudyPlanUpdateManyMutationInput, SATStudyPlanUncheckedUpdateManyInput>
    /**
     * Filter which SATStudyPlans to update
     */
    where?: SATStudyPlanWhereInput
    /**
     * Limit how many SATStudyPlans to update.
     */
    limit?: number
  }

  /**
   * SATStudyPlan updateManyAndReturn
   */
  export type SATStudyPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATStudyPlan
     */
    select?: SATStudyPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SATStudyPlan
     */
    omit?: SATStudyPlanOmit<ExtArgs> | null
    /**
     * The data used to update SATStudyPlans.
     */
    data: XOR<SATStudyPlanUpdateManyMutationInput, SATStudyPlanUncheckedUpdateManyInput>
    /**
     * Filter which SATStudyPlans to update
     */
    where?: SATStudyPlanWhereInput
    /**
     * Limit how many SATStudyPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATStudyPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SATStudyPlan upsert
   */
  export type SATStudyPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATStudyPlan
     */
    select?: SATStudyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATStudyPlan
     */
    omit?: SATStudyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATStudyPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the SATStudyPlan to update in case it exists.
     */
    where: SATStudyPlanWhereUniqueInput
    /**
     * In case the SATStudyPlan found by the `where` argument doesn't exist, create a new SATStudyPlan with this data.
     */
    create: XOR<SATStudyPlanCreateInput, SATStudyPlanUncheckedCreateInput>
    /**
     * In case the SATStudyPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SATStudyPlanUpdateInput, SATStudyPlanUncheckedUpdateInput>
  }

  /**
   * SATStudyPlan delete
   */
  export type SATStudyPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATStudyPlan
     */
    select?: SATStudyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATStudyPlan
     */
    omit?: SATStudyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATStudyPlanInclude<ExtArgs> | null
    /**
     * Filter which SATStudyPlan to delete.
     */
    where: SATStudyPlanWhereUniqueInput
  }

  /**
   * SATStudyPlan deleteMany
   */
  export type SATStudyPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SATStudyPlans to delete
     */
    where?: SATStudyPlanWhereInput
    /**
     * Limit how many SATStudyPlans to delete.
     */
    limit?: number
  }

  /**
   * SATStudyPlan without action
   */
  export type SATStudyPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATStudyPlan
     */
    select?: SATStudyPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATStudyPlan
     */
    omit?: SATStudyPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATStudyPlanInclude<ExtArgs> | null
  }


  /**
   * Model SATPracticeSession
   */

  export type AggregateSATPracticeSession = {
    _count: SATPracticeSessionCountAggregateOutputType | null
    _avg: SATPracticeSessionAvgAggregateOutputType | null
    _sum: SATPracticeSessionSumAggregateOutputType | null
    _min: SATPracticeSessionMinAggregateOutputType | null
    _max: SATPracticeSessionMaxAggregateOutputType | null
  }

  export type SATPracticeSessionAvgAggregateOutputType = {
    score: number | null
    maxScore: number | null
    timeSpent: number | null
  }

  export type SATPracticeSessionSumAggregateOutputType = {
    score: number | null
    maxScore: number | null
    timeSpent: number | null
  }

  export type SATPracticeSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    section: string | null
    score: number | null
    maxScore: number | null
    timeSpent: number | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type SATPracticeSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    section: string | null
    score: number | null
    maxScore: number | null
    timeSpent: number | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type SATPracticeSessionCountAggregateOutputType = {
    id: number
    userId: number
    section: number
    score: number
    maxScore: number
    answers: number
    timeSpent: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type SATPracticeSessionAvgAggregateInputType = {
    score?: true
    maxScore?: true
    timeSpent?: true
  }

  export type SATPracticeSessionSumAggregateInputType = {
    score?: true
    maxScore?: true
    timeSpent?: true
  }

  export type SATPracticeSessionMinAggregateInputType = {
    id?: true
    userId?: true
    section?: true
    score?: true
    maxScore?: true
    timeSpent?: true
    completedAt?: true
    createdAt?: true
  }

  export type SATPracticeSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    section?: true
    score?: true
    maxScore?: true
    timeSpent?: true
    completedAt?: true
    createdAt?: true
  }

  export type SATPracticeSessionCountAggregateInputType = {
    id?: true
    userId?: true
    section?: true
    score?: true
    maxScore?: true
    answers?: true
    timeSpent?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type SATPracticeSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SATPracticeSession to aggregate.
     */
    where?: SATPracticeSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SATPracticeSessions to fetch.
     */
    orderBy?: SATPracticeSessionOrderByWithRelationInput | SATPracticeSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SATPracticeSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SATPracticeSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SATPracticeSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SATPracticeSessions
    **/
    _count?: true | SATPracticeSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SATPracticeSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SATPracticeSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SATPracticeSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SATPracticeSessionMaxAggregateInputType
  }

  export type GetSATPracticeSessionAggregateType<T extends SATPracticeSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSATPracticeSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSATPracticeSession[P]>
      : GetScalarType<T[P], AggregateSATPracticeSession[P]>
  }




  export type SATPracticeSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SATPracticeSessionWhereInput
    orderBy?: SATPracticeSessionOrderByWithAggregationInput | SATPracticeSessionOrderByWithAggregationInput[]
    by: SATPracticeSessionScalarFieldEnum[] | SATPracticeSessionScalarFieldEnum
    having?: SATPracticeSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SATPracticeSessionCountAggregateInputType | true
    _avg?: SATPracticeSessionAvgAggregateInputType
    _sum?: SATPracticeSessionSumAggregateInputType
    _min?: SATPracticeSessionMinAggregateInputType
    _max?: SATPracticeSessionMaxAggregateInputType
  }

  export type SATPracticeSessionGroupByOutputType = {
    id: string
    userId: string
    section: string
    score: number | null
    maxScore: number | null
    answers: JsonValue | null
    timeSpent: number | null
    completedAt: Date | null
    createdAt: Date
    _count: SATPracticeSessionCountAggregateOutputType | null
    _avg: SATPracticeSessionAvgAggregateOutputType | null
    _sum: SATPracticeSessionSumAggregateOutputType | null
    _min: SATPracticeSessionMinAggregateOutputType | null
    _max: SATPracticeSessionMaxAggregateOutputType | null
  }

  type GetSATPracticeSessionGroupByPayload<T extends SATPracticeSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SATPracticeSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SATPracticeSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SATPracticeSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SATPracticeSessionGroupByOutputType[P]>
        }
      >
    >


  export type SATPracticeSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    section?: boolean
    score?: boolean
    maxScore?: boolean
    answers?: boolean
    timeSpent?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sATPracticeSession"]>

  export type SATPracticeSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    section?: boolean
    score?: boolean
    maxScore?: boolean
    answers?: boolean
    timeSpent?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sATPracticeSession"]>

  export type SATPracticeSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    section?: boolean
    score?: boolean
    maxScore?: boolean
    answers?: boolean
    timeSpent?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sATPracticeSession"]>

  export type SATPracticeSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    section?: boolean
    score?: boolean
    maxScore?: boolean
    answers?: boolean
    timeSpent?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type SATPracticeSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "section" | "score" | "maxScore" | "answers" | "timeSpent" | "completedAt" | "createdAt", ExtArgs["result"]["sATPracticeSession"]>
  export type SATPracticeSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SATPracticeSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SATPracticeSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SATPracticeSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SATPracticeSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      section: string
      score: number | null
      maxScore: number | null
      answers: Prisma.JsonValue | null
      timeSpent: number | null
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["sATPracticeSession"]>
    composites: {}
  }

  type SATPracticeSessionGetPayload<S extends boolean | null | undefined | SATPracticeSessionDefaultArgs> = $Result.GetResult<Prisma.$SATPracticeSessionPayload, S>

  type SATPracticeSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SATPracticeSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SATPracticeSessionCountAggregateInputType | true
    }

  export interface SATPracticeSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SATPracticeSession'], meta: { name: 'SATPracticeSession' } }
    /**
     * Find zero or one SATPracticeSession that matches the filter.
     * @param {SATPracticeSessionFindUniqueArgs} args - Arguments to find a SATPracticeSession
     * @example
     * // Get one SATPracticeSession
     * const sATPracticeSession = await prisma.sATPracticeSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SATPracticeSessionFindUniqueArgs>(args: SelectSubset<T, SATPracticeSessionFindUniqueArgs<ExtArgs>>): Prisma__SATPracticeSessionClient<$Result.GetResult<Prisma.$SATPracticeSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SATPracticeSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SATPracticeSessionFindUniqueOrThrowArgs} args - Arguments to find a SATPracticeSession
     * @example
     * // Get one SATPracticeSession
     * const sATPracticeSession = await prisma.sATPracticeSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SATPracticeSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SATPracticeSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SATPracticeSessionClient<$Result.GetResult<Prisma.$SATPracticeSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SATPracticeSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATPracticeSessionFindFirstArgs} args - Arguments to find a SATPracticeSession
     * @example
     * // Get one SATPracticeSession
     * const sATPracticeSession = await prisma.sATPracticeSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SATPracticeSessionFindFirstArgs>(args?: SelectSubset<T, SATPracticeSessionFindFirstArgs<ExtArgs>>): Prisma__SATPracticeSessionClient<$Result.GetResult<Prisma.$SATPracticeSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SATPracticeSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATPracticeSessionFindFirstOrThrowArgs} args - Arguments to find a SATPracticeSession
     * @example
     * // Get one SATPracticeSession
     * const sATPracticeSession = await prisma.sATPracticeSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SATPracticeSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SATPracticeSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SATPracticeSessionClient<$Result.GetResult<Prisma.$SATPracticeSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SATPracticeSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATPracticeSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SATPracticeSessions
     * const sATPracticeSessions = await prisma.sATPracticeSession.findMany()
     * 
     * // Get first 10 SATPracticeSessions
     * const sATPracticeSessions = await prisma.sATPracticeSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sATPracticeSessionWithIdOnly = await prisma.sATPracticeSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SATPracticeSessionFindManyArgs>(args?: SelectSubset<T, SATPracticeSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SATPracticeSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SATPracticeSession.
     * @param {SATPracticeSessionCreateArgs} args - Arguments to create a SATPracticeSession.
     * @example
     * // Create one SATPracticeSession
     * const SATPracticeSession = await prisma.sATPracticeSession.create({
     *   data: {
     *     // ... data to create a SATPracticeSession
     *   }
     * })
     * 
     */
    create<T extends SATPracticeSessionCreateArgs>(args: SelectSubset<T, SATPracticeSessionCreateArgs<ExtArgs>>): Prisma__SATPracticeSessionClient<$Result.GetResult<Prisma.$SATPracticeSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SATPracticeSessions.
     * @param {SATPracticeSessionCreateManyArgs} args - Arguments to create many SATPracticeSessions.
     * @example
     * // Create many SATPracticeSessions
     * const sATPracticeSession = await prisma.sATPracticeSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SATPracticeSessionCreateManyArgs>(args?: SelectSubset<T, SATPracticeSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SATPracticeSessions and returns the data saved in the database.
     * @param {SATPracticeSessionCreateManyAndReturnArgs} args - Arguments to create many SATPracticeSessions.
     * @example
     * // Create many SATPracticeSessions
     * const sATPracticeSession = await prisma.sATPracticeSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SATPracticeSessions and only return the `id`
     * const sATPracticeSessionWithIdOnly = await prisma.sATPracticeSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SATPracticeSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SATPracticeSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SATPracticeSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SATPracticeSession.
     * @param {SATPracticeSessionDeleteArgs} args - Arguments to delete one SATPracticeSession.
     * @example
     * // Delete one SATPracticeSession
     * const SATPracticeSession = await prisma.sATPracticeSession.delete({
     *   where: {
     *     // ... filter to delete one SATPracticeSession
     *   }
     * })
     * 
     */
    delete<T extends SATPracticeSessionDeleteArgs>(args: SelectSubset<T, SATPracticeSessionDeleteArgs<ExtArgs>>): Prisma__SATPracticeSessionClient<$Result.GetResult<Prisma.$SATPracticeSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SATPracticeSession.
     * @param {SATPracticeSessionUpdateArgs} args - Arguments to update one SATPracticeSession.
     * @example
     * // Update one SATPracticeSession
     * const sATPracticeSession = await prisma.sATPracticeSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SATPracticeSessionUpdateArgs>(args: SelectSubset<T, SATPracticeSessionUpdateArgs<ExtArgs>>): Prisma__SATPracticeSessionClient<$Result.GetResult<Prisma.$SATPracticeSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SATPracticeSessions.
     * @param {SATPracticeSessionDeleteManyArgs} args - Arguments to filter SATPracticeSessions to delete.
     * @example
     * // Delete a few SATPracticeSessions
     * const { count } = await prisma.sATPracticeSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SATPracticeSessionDeleteManyArgs>(args?: SelectSubset<T, SATPracticeSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SATPracticeSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATPracticeSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SATPracticeSessions
     * const sATPracticeSession = await prisma.sATPracticeSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SATPracticeSessionUpdateManyArgs>(args: SelectSubset<T, SATPracticeSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SATPracticeSessions and returns the data updated in the database.
     * @param {SATPracticeSessionUpdateManyAndReturnArgs} args - Arguments to update many SATPracticeSessions.
     * @example
     * // Update many SATPracticeSessions
     * const sATPracticeSession = await prisma.sATPracticeSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SATPracticeSessions and only return the `id`
     * const sATPracticeSessionWithIdOnly = await prisma.sATPracticeSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SATPracticeSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SATPracticeSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SATPracticeSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SATPracticeSession.
     * @param {SATPracticeSessionUpsertArgs} args - Arguments to update or create a SATPracticeSession.
     * @example
     * // Update or create a SATPracticeSession
     * const sATPracticeSession = await prisma.sATPracticeSession.upsert({
     *   create: {
     *     // ... data to create a SATPracticeSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SATPracticeSession we want to update
     *   }
     * })
     */
    upsert<T extends SATPracticeSessionUpsertArgs>(args: SelectSubset<T, SATPracticeSessionUpsertArgs<ExtArgs>>): Prisma__SATPracticeSessionClient<$Result.GetResult<Prisma.$SATPracticeSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SATPracticeSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATPracticeSessionCountArgs} args - Arguments to filter SATPracticeSessions to count.
     * @example
     * // Count the number of SATPracticeSessions
     * const count = await prisma.sATPracticeSession.count({
     *   where: {
     *     // ... the filter for the SATPracticeSessions we want to count
     *   }
     * })
    **/
    count<T extends SATPracticeSessionCountArgs>(
      args?: Subset<T, SATPracticeSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SATPracticeSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SATPracticeSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATPracticeSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SATPracticeSessionAggregateArgs>(args: Subset<T, SATPracticeSessionAggregateArgs>): Prisma.PrismaPromise<GetSATPracticeSessionAggregateType<T>>

    /**
     * Group by SATPracticeSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATPracticeSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SATPracticeSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SATPracticeSessionGroupByArgs['orderBy'] }
        : { orderBy?: SATPracticeSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SATPracticeSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSATPracticeSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SATPracticeSession model
   */
  readonly fields: SATPracticeSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SATPracticeSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SATPracticeSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SATPracticeSession model
   */
  interface SATPracticeSessionFieldRefs {
    readonly id: FieldRef<"SATPracticeSession", 'String'>
    readonly userId: FieldRef<"SATPracticeSession", 'String'>
    readonly section: FieldRef<"SATPracticeSession", 'String'>
    readonly score: FieldRef<"SATPracticeSession", 'Int'>
    readonly maxScore: FieldRef<"SATPracticeSession", 'Int'>
    readonly answers: FieldRef<"SATPracticeSession", 'Json'>
    readonly timeSpent: FieldRef<"SATPracticeSession", 'Int'>
    readonly completedAt: FieldRef<"SATPracticeSession", 'DateTime'>
    readonly createdAt: FieldRef<"SATPracticeSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SATPracticeSession findUnique
   */
  export type SATPracticeSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATPracticeSession
     */
    select?: SATPracticeSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATPracticeSession
     */
    omit?: SATPracticeSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATPracticeSessionInclude<ExtArgs> | null
    /**
     * Filter, which SATPracticeSession to fetch.
     */
    where: SATPracticeSessionWhereUniqueInput
  }

  /**
   * SATPracticeSession findUniqueOrThrow
   */
  export type SATPracticeSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATPracticeSession
     */
    select?: SATPracticeSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATPracticeSession
     */
    omit?: SATPracticeSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATPracticeSessionInclude<ExtArgs> | null
    /**
     * Filter, which SATPracticeSession to fetch.
     */
    where: SATPracticeSessionWhereUniqueInput
  }

  /**
   * SATPracticeSession findFirst
   */
  export type SATPracticeSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATPracticeSession
     */
    select?: SATPracticeSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATPracticeSession
     */
    omit?: SATPracticeSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATPracticeSessionInclude<ExtArgs> | null
    /**
     * Filter, which SATPracticeSession to fetch.
     */
    where?: SATPracticeSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SATPracticeSessions to fetch.
     */
    orderBy?: SATPracticeSessionOrderByWithRelationInput | SATPracticeSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SATPracticeSessions.
     */
    cursor?: SATPracticeSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SATPracticeSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SATPracticeSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SATPracticeSessions.
     */
    distinct?: SATPracticeSessionScalarFieldEnum | SATPracticeSessionScalarFieldEnum[]
  }

  /**
   * SATPracticeSession findFirstOrThrow
   */
  export type SATPracticeSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATPracticeSession
     */
    select?: SATPracticeSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATPracticeSession
     */
    omit?: SATPracticeSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATPracticeSessionInclude<ExtArgs> | null
    /**
     * Filter, which SATPracticeSession to fetch.
     */
    where?: SATPracticeSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SATPracticeSessions to fetch.
     */
    orderBy?: SATPracticeSessionOrderByWithRelationInput | SATPracticeSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SATPracticeSessions.
     */
    cursor?: SATPracticeSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SATPracticeSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SATPracticeSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SATPracticeSessions.
     */
    distinct?: SATPracticeSessionScalarFieldEnum | SATPracticeSessionScalarFieldEnum[]
  }

  /**
   * SATPracticeSession findMany
   */
  export type SATPracticeSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATPracticeSession
     */
    select?: SATPracticeSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATPracticeSession
     */
    omit?: SATPracticeSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATPracticeSessionInclude<ExtArgs> | null
    /**
     * Filter, which SATPracticeSessions to fetch.
     */
    where?: SATPracticeSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SATPracticeSessions to fetch.
     */
    orderBy?: SATPracticeSessionOrderByWithRelationInput | SATPracticeSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SATPracticeSessions.
     */
    cursor?: SATPracticeSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SATPracticeSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SATPracticeSessions.
     */
    skip?: number
    distinct?: SATPracticeSessionScalarFieldEnum | SATPracticeSessionScalarFieldEnum[]
  }

  /**
   * SATPracticeSession create
   */
  export type SATPracticeSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATPracticeSession
     */
    select?: SATPracticeSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATPracticeSession
     */
    omit?: SATPracticeSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATPracticeSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a SATPracticeSession.
     */
    data: XOR<SATPracticeSessionCreateInput, SATPracticeSessionUncheckedCreateInput>
  }

  /**
   * SATPracticeSession createMany
   */
  export type SATPracticeSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SATPracticeSessions.
     */
    data: SATPracticeSessionCreateManyInput | SATPracticeSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SATPracticeSession createManyAndReturn
   */
  export type SATPracticeSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATPracticeSession
     */
    select?: SATPracticeSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SATPracticeSession
     */
    omit?: SATPracticeSessionOmit<ExtArgs> | null
    /**
     * The data used to create many SATPracticeSessions.
     */
    data: SATPracticeSessionCreateManyInput | SATPracticeSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATPracticeSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SATPracticeSession update
   */
  export type SATPracticeSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATPracticeSession
     */
    select?: SATPracticeSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATPracticeSession
     */
    omit?: SATPracticeSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATPracticeSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a SATPracticeSession.
     */
    data: XOR<SATPracticeSessionUpdateInput, SATPracticeSessionUncheckedUpdateInput>
    /**
     * Choose, which SATPracticeSession to update.
     */
    where: SATPracticeSessionWhereUniqueInput
  }

  /**
   * SATPracticeSession updateMany
   */
  export type SATPracticeSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SATPracticeSessions.
     */
    data: XOR<SATPracticeSessionUpdateManyMutationInput, SATPracticeSessionUncheckedUpdateManyInput>
    /**
     * Filter which SATPracticeSessions to update
     */
    where?: SATPracticeSessionWhereInput
    /**
     * Limit how many SATPracticeSessions to update.
     */
    limit?: number
  }

  /**
   * SATPracticeSession updateManyAndReturn
   */
  export type SATPracticeSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATPracticeSession
     */
    select?: SATPracticeSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SATPracticeSession
     */
    omit?: SATPracticeSessionOmit<ExtArgs> | null
    /**
     * The data used to update SATPracticeSessions.
     */
    data: XOR<SATPracticeSessionUpdateManyMutationInput, SATPracticeSessionUncheckedUpdateManyInput>
    /**
     * Filter which SATPracticeSessions to update
     */
    where?: SATPracticeSessionWhereInput
    /**
     * Limit how many SATPracticeSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATPracticeSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SATPracticeSession upsert
   */
  export type SATPracticeSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATPracticeSession
     */
    select?: SATPracticeSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATPracticeSession
     */
    omit?: SATPracticeSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATPracticeSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the SATPracticeSession to update in case it exists.
     */
    where: SATPracticeSessionWhereUniqueInput
    /**
     * In case the SATPracticeSession found by the `where` argument doesn't exist, create a new SATPracticeSession with this data.
     */
    create: XOR<SATPracticeSessionCreateInput, SATPracticeSessionUncheckedCreateInput>
    /**
     * In case the SATPracticeSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SATPracticeSessionUpdateInput, SATPracticeSessionUncheckedUpdateInput>
  }

  /**
   * SATPracticeSession delete
   */
  export type SATPracticeSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATPracticeSession
     */
    select?: SATPracticeSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATPracticeSession
     */
    omit?: SATPracticeSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATPracticeSessionInclude<ExtArgs> | null
    /**
     * Filter which SATPracticeSession to delete.
     */
    where: SATPracticeSessionWhereUniqueInput
  }

  /**
   * SATPracticeSession deleteMany
   */
  export type SATPracticeSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SATPracticeSessions to delete
     */
    where?: SATPracticeSessionWhereInput
    /**
     * Limit how many SATPracticeSessions to delete.
     */
    limit?: number
  }

  /**
   * SATPracticeSession without action
   */
  export type SATPracticeSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATPracticeSession
     */
    select?: SATPracticeSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATPracticeSession
     */
    omit?: SATPracticeSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATPracticeSessionInclude<ExtArgs> | null
  }


  /**
   * Model SATDiagnosticResult
   */

  export type AggregateSATDiagnosticResult = {
    _count: SATDiagnosticResultCountAggregateOutputType | null
    _avg: SATDiagnosticResultAvgAggregateOutputType | null
    _sum: SATDiagnosticResultSumAggregateOutputType | null
    _min: SATDiagnosticResultMinAggregateOutputType | null
    _max: SATDiagnosticResultMaxAggregateOutputType | null
  }

  export type SATDiagnosticResultAvgAggregateOutputType = {
    mathScore: number | null
    readingScore: number | null
    writingScore: number | null
    totalScore: number | null
  }

  export type SATDiagnosticResultSumAggregateOutputType = {
    mathScore: number | null
    readingScore: number | null
    writingScore: number | null
    totalScore: number | null
  }

  export type SATDiagnosticResultMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mathScore: number | null
    readingScore: number | null
    writingScore: number | null
    totalScore: number | null
    createdAt: Date | null
  }

  export type SATDiagnosticResultMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mathScore: number | null
    readingScore: number | null
    writingScore: number | null
    totalScore: number | null
    createdAt: Date | null
  }

  export type SATDiagnosticResultCountAggregateOutputType = {
    id: number
    userId: number
    mathScore: number
    readingScore: number
    writingScore: number
    totalScore: number
    strengths: number
    weaknesses: number
    createdAt: number
    _all: number
  }


  export type SATDiagnosticResultAvgAggregateInputType = {
    mathScore?: true
    readingScore?: true
    writingScore?: true
    totalScore?: true
  }

  export type SATDiagnosticResultSumAggregateInputType = {
    mathScore?: true
    readingScore?: true
    writingScore?: true
    totalScore?: true
  }

  export type SATDiagnosticResultMinAggregateInputType = {
    id?: true
    userId?: true
    mathScore?: true
    readingScore?: true
    writingScore?: true
    totalScore?: true
    createdAt?: true
  }

  export type SATDiagnosticResultMaxAggregateInputType = {
    id?: true
    userId?: true
    mathScore?: true
    readingScore?: true
    writingScore?: true
    totalScore?: true
    createdAt?: true
  }

  export type SATDiagnosticResultCountAggregateInputType = {
    id?: true
    userId?: true
    mathScore?: true
    readingScore?: true
    writingScore?: true
    totalScore?: true
    strengths?: true
    weaknesses?: true
    createdAt?: true
    _all?: true
  }

  export type SATDiagnosticResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SATDiagnosticResult to aggregate.
     */
    where?: SATDiagnosticResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SATDiagnosticResults to fetch.
     */
    orderBy?: SATDiagnosticResultOrderByWithRelationInput | SATDiagnosticResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SATDiagnosticResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SATDiagnosticResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SATDiagnosticResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SATDiagnosticResults
    **/
    _count?: true | SATDiagnosticResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SATDiagnosticResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SATDiagnosticResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SATDiagnosticResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SATDiagnosticResultMaxAggregateInputType
  }

  export type GetSATDiagnosticResultAggregateType<T extends SATDiagnosticResultAggregateArgs> = {
        [P in keyof T & keyof AggregateSATDiagnosticResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSATDiagnosticResult[P]>
      : GetScalarType<T[P], AggregateSATDiagnosticResult[P]>
  }




  export type SATDiagnosticResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SATDiagnosticResultWhereInput
    orderBy?: SATDiagnosticResultOrderByWithAggregationInput | SATDiagnosticResultOrderByWithAggregationInput[]
    by: SATDiagnosticResultScalarFieldEnum[] | SATDiagnosticResultScalarFieldEnum
    having?: SATDiagnosticResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SATDiagnosticResultCountAggregateInputType | true
    _avg?: SATDiagnosticResultAvgAggregateInputType
    _sum?: SATDiagnosticResultSumAggregateInputType
    _min?: SATDiagnosticResultMinAggregateInputType
    _max?: SATDiagnosticResultMaxAggregateInputType
  }

  export type SATDiagnosticResultGroupByOutputType = {
    id: string
    userId: string
    mathScore: number | null
    readingScore: number | null
    writingScore: number | null
    totalScore: number | null
    strengths: JsonValue | null
    weaknesses: JsonValue | null
    createdAt: Date
    _count: SATDiagnosticResultCountAggregateOutputType | null
    _avg: SATDiagnosticResultAvgAggregateOutputType | null
    _sum: SATDiagnosticResultSumAggregateOutputType | null
    _min: SATDiagnosticResultMinAggregateOutputType | null
    _max: SATDiagnosticResultMaxAggregateOutputType | null
  }

  type GetSATDiagnosticResultGroupByPayload<T extends SATDiagnosticResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SATDiagnosticResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SATDiagnosticResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SATDiagnosticResultGroupByOutputType[P]>
            : GetScalarType<T[P], SATDiagnosticResultGroupByOutputType[P]>
        }
      >
    >


  export type SATDiagnosticResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mathScore?: boolean
    readingScore?: boolean
    writingScore?: boolean
    totalScore?: boolean
    strengths?: boolean
    weaknesses?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sATDiagnosticResult"]>

  export type SATDiagnosticResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mathScore?: boolean
    readingScore?: boolean
    writingScore?: boolean
    totalScore?: boolean
    strengths?: boolean
    weaknesses?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sATDiagnosticResult"]>

  export type SATDiagnosticResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mathScore?: boolean
    readingScore?: boolean
    writingScore?: boolean
    totalScore?: boolean
    strengths?: boolean
    weaknesses?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sATDiagnosticResult"]>

  export type SATDiagnosticResultSelectScalar = {
    id?: boolean
    userId?: boolean
    mathScore?: boolean
    readingScore?: boolean
    writingScore?: boolean
    totalScore?: boolean
    strengths?: boolean
    weaknesses?: boolean
    createdAt?: boolean
  }

  export type SATDiagnosticResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mathScore" | "readingScore" | "writingScore" | "totalScore" | "strengths" | "weaknesses" | "createdAt", ExtArgs["result"]["sATDiagnosticResult"]>
  export type SATDiagnosticResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SATDiagnosticResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SATDiagnosticResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SATDiagnosticResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SATDiagnosticResult"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mathScore: number | null
      readingScore: number | null
      writingScore: number | null
      totalScore: number | null
      strengths: Prisma.JsonValue | null
      weaknesses: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["sATDiagnosticResult"]>
    composites: {}
  }

  type SATDiagnosticResultGetPayload<S extends boolean | null | undefined | SATDiagnosticResultDefaultArgs> = $Result.GetResult<Prisma.$SATDiagnosticResultPayload, S>

  type SATDiagnosticResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SATDiagnosticResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SATDiagnosticResultCountAggregateInputType | true
    }

  export interface SATDiagnosticResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SATDiagnosticResult'], meta: { name: 'SATDiagnosticResult' } }
    /**
     * Find zero or one SATDiagnosticResult that matches the filter.
     * @param {SATDiagnosticResultFindUniqueArgs} args - Arguments to find a SATDiagnosticResult
     * @example
     * // Get one SATDiagnosticResult
     * const sATDiagnosticResult = await prisma.sATDiagnosticResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SATDiagnosticResultFindUniqueArgs>(args: SelectSubset<T, SATDiagnosticResultFindUniqueArgs<ExtArgs>>): Prisma__SATDiagnosticResultClient<$Result.GetResult<Prisma.$SATDiagnosticResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SATDiagnosticResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SATDiagnosticResultFindUniqueOrThrowArgs} args - Arguments to find a SATDiagnosticResult
     * @example
     * // Get one SATDiagnosticResult
     * const sATDiagnosticResult = await prisma.sATDiagnosticResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SATDiagnosticResultFindUniqueOrThrowArgs>(args: SelectSubset<T, SATDiagnosticResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SATDiagnosticResultClient<$Result.GetResult<Prisma.$SATDiagnosticResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SATDiagnosticResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATDiagnosticResultFindFirstArgs} args - Arguments to find a SATDiagnosticResult
     * @example
     * // Get one SATDiagnosticResult
     * const sATDiagnosticResult = await prisma.sATDiagnosticResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SATDiagnosticResultFindFirstArgs>(args?: SelectSubset<T, SATDiagnosticResultFindFirstArgs<ExtArgs>>): Prisma__SATDiagnosticResultClient<$Result.GetResult<Prisma.$SATDiagnosticResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SATDiagnosticResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATDiagnosticResultFindFirstOrThrowArgs} args - Arguments to find a SATDiagnosticResult
     * @example
     * // Get one SATDiagnosticResult
     * const sATDiagnosticResult = await prisma.sATDiagnosticResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SATDiagnosticResultFindFirstOrThrowArgs>(args?: SelectSubset<T, SATDiagnosticResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__SATDiagnosticResultClient<$Result.GetResult<Prisma.$SATDiagnosticResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SATDiagnosticResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATDiagnosticResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SATDiagnosticResults
     * const sATDiagnosticResults = await prisma.sATDiagnosticResult.findMany()
     * 
     * // Get first 10 SATDiagnosticResults
     * const sATDiagnosticResults = await prisma.sATDiagnosticResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sATDiagnosticResultWithIdOnly = await prisma.sATDiagnosticResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SATDiagnosticResultFindManyArgs>(args?: SelectSubset<T, SATDiagnosticResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SATDiagnosticResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SATDiagnosticResult.
     * @param {SATDiagnosticResultCreateArgs} args - Arguments to create a SATDiagnosticResult.
     * @example
     * // Create one SATDiagnosticResult
     * const SATDiagnosticResult = await prisma.sATDiagnosticResult.create({
     *   data: {
     *     // ... data to create a SATDiagnosticResult
     *   }
     * })
     * 
     */
    create<T extends SATDiagnosticResultCreateArgs>(args: SelectSubset<T, SATDiagnosticResultCreateArgs<ExtArgs>>): Prisma__SATDiagnosticResultClient<$Result.GetResult<Prisma.$SATDiagnosticResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SATDiagnosticResults.
     * @param {SATDiagnosticResultCreateManyArgs} args - Arguments to create many SATDiagnosticResults.
     * @example
     * // Create many SATDiagnosticResults
     * const sATDiagnosticResult = await prisma.sATDiagnosticResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SATDiagnosticResultCreateManyArgs>(args?: SelectSubset<T, SATDiagnosticResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SATDiagnosticResults and returns the data saved in the database.
     * @param {SATDiagnosticResultCreateManyAndReturnArgs} args - Arguments to create many SATDiagnosticResults.
     * @example
     * // Create many SATDiagnosticResults
     * const sATDiagnosticResult = await prisma.sATDiagnosticResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SATDiagnosticResults and only return the `id`
     * const sATDiagnosticResultWithIdOnly = await prisma.sATDiagnosticResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SATDiagnosticResultCreateManyAndReturnArgs>(args?: SelectSubset<T, SATDiagnosticResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SATDiagnosticResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SATDiagnosticResult.
     * @param {SATDiagnosticResultDeleteArgs} args - Arguments to delete one SATDiagnosticResult.
     * @example
     * // Delete one SATDiagnosticResult
     * const SATDiagnosticResult = await prisma.sATDiagnosticResult.delete({
     *   where: {
     *     // ... filter to delete one SATDiagnosticResult
     *   }
     * })
     * 
     */
    delete<T extends SATDiagnosticResultDeleteArgs>(args: SelectSubset<T, SATDiagnosticResultDeleteArgs<ExtArgs>>): Prisma__SATDiagnosticResultClient<$Result.GetResult<Prisma.$SATDiagnosticResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SATDiagnosticResult.
     * @param {SATDiagnosticResultUpdateArgs} args - Arguments to update one SATDiagnosticResult.
     * @example
     * // Update one SATDiagnosticResult
     * const sATDiagnosticResult = await prisma.sATDiagnosticResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SATDiagnosticResultUpdateArgs>(args: SelectSubset<T, SATDiagnosticResultUpdateArgs<ExtArgs>>): Prisma__SATDiagnosticResultClient<$Result.GetResult<Prisma.$SATDiagnosticResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SATDiagnosticResults.
     * @param {SATDiagnosticResultDeleteManyArgs} args - Arguments to filter SATDiagnosticResults to delete.
     * @example
     * // Delete a few SATDiagnosticResults
     * const { count } = await prisma.sATDiagnosticResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SATDiagnosticResultDeleteManyArgs>(args?: SelectSubset<T, SATDiagnosticResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SATDiagnosticResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATDiagnosticResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SATDiagnosticResults
     * const sATDiagnosticResult = await prisma.sATDiagnosticResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SATDiagnosticResultUpdateManyArgs>(args: SelectSubset<T, SATDiagnosticResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SATDiagnosticResults and returns the data updated in the database.
     * @param {SATDiagnosticResultUpdateManyAndReturnArgs} args - Arguments to update many SATDiagnosticResults.
     * @example
     * // Update many SATDiagnosticResults
     * const sATDiagnosticResult = await prisma.sATDiagnosticResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SATDiagnosticResults and only return the `id`
     * const sATDiagnosticResultWithIdOnly = await prisma.sATDiagnosticResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SATDiagnosticResultUpdateManyAndReturnArgs>(args: SelectSubset<T, SATDiagnosticResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SATDiagnosticResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SATDiagnosticResult.
     * @param {SATDiagnosticResultUpsertArgs} args - Arguments to update or create a SATDiagnosticResult.
     * @example
     * // Update or create a SATDiagnosticResult
     * const sATDiagnosticResult = await prisma.sATDiagnosticResult.upsert({
     *   create: {
     *     // ... data to create a SATDiagnosticResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SATDiagnosticResult we want to update
     *   }
     * })
     */
    upsert<T extends SATDiagnosticResultUpsertArgs>(args: SelectSubset<T, SATDiagnosticResultUpsertArgs<ExtArgs>>): Prisma__SATDiagnosticResultClient<$Result.GetResult<Prisma.$SATDiagnosticResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SATDiagnosticResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATDiagnosticResultCountArgs} args - Arguments to filter SATDiagnosticResults to count.
     * @example
     * // Count the number of SATDiagnosticResults
     * const count = await prisma.sATDiagnosticResult.count({
     *   where: {
     *     // ... the filter for the SATDiagnosticResults we want to count
     *   }
     * })
    **/
    count<T extends SATDiagnosticResultCountArgs>(
      args?: Subset<T, SATDiagnosticResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SATDiagnosticResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SATDiagnosticResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATDiagnosticResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SATDiagnosticResultAggregateArgs>(args: Subset<T, SATDiagnosticResultAggregateArgs>): Prisma.PrismaPromise<GetSATDiagnosticResultAggregateType<T>>

    /**
     * Group by SATDiagnosticResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SATDiagnosticResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SATDiagnosticResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SATDiagnosticResultGroupByArgs['orderBy'] }
        : { orderBy?: SATDiagnosticResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SATDiagnosticResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSATDiagnosticResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SATDiagnosticResult model
   */
  readonly fields: SATDiagnosticResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SATDiagnosticResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SATDiagnosticResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SATDiagnosticResult model
   */
  interface SATDiagnosticResultFieldRefs {
    readonly id: FieldRef<"SATDiagnosticResult", 'String'>
    readonly userId: FieldRef<"SATDiagnosticResult", 'String'>
    readonly mathScore: FieldRef<"SATDiagnosticResult", 'Int'>
    readonly readingScore: FieldRef<"SATDiagnosticResult", 'Int'>
    readonly writingScore: FieldRef<"SATDiagnosticResult", 'Int'>
    readonly totalScore: FieldRef<"SATDiagnosticResult", 'Int'>
    readonly strengths: FieldRef<"SATDiagnosticResult", 'Json'>
    readonly weaknesses: FieldRef<"SATDiagnosticResult", 'Json'>
    readonly createdAt: FieldRef<"SATDiagnosticResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SATDiagnosticResult findUnique
   */
  export type SATDiagnosticResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATDiagnosticResult
     */
    select?: SATDiagnosticResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATDiagnosticResult
     */
    omit?: SATDiagnosticResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATDiagnosticResultInclude<ExtArgs> | null
    /**
     * Filter, which SATDiagnosticResult to fetch.
     */
    where: SATDiagnosticResultWhereUniqueInput
  }

  /**
   * SATDiagnosticResult findUniqueOrThrow
   */
  export type SATDiagnosticResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATDiagnosticResult
     */
    select?: SATDiagnosticResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATDiagnosticResult
     */
    omit?: SATDiagnosticResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATDiagnosticResultInclude<ExtArgs> | null
    /**
     * Filter, which SATDiagnosticResult to fetch.
     */
    where: SATDiagnosticResultWhereUniqueInput
  }

  /**
   * SATDiagnosticResult findFirst
   */
  export type SATDiagnosticResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATDiagnosticResult
     */
    select?: SATDiagnosticResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATDiagnosticResult
     */
    omit?: SATDiagnosticResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATDiagnosticResultInclude<ExtArgs> | null
    /**
     * Filter, which SATDiagnosticResult to fetch.
     */
    where?: SATDiagnosticResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SATDiagnosticResults to fetch.
     */
    orderBy?: SATDiagnosticResultOrderByWithRelationInput | SATDiagnosticResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SATDiagnosticResults.
     */
    cursor?: SATDiagnosticResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SATDiagnosticResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SATDiagnosticResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SATDiagnosticResults.
     */
    distinct?: SATDiagnosticResultScalarFieldEnum | SATDiagnosticResultScalarFieldEnum[]
  }

  /**
   * SATDiagnosticResult findFirstOrThrow
   */
  export type SATDiagnosticResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATDiagnosticResult
     */
    select?: SATDiagnosticResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATDiagnosticResult
     */
    omit?: SATDiagnosticResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATDiagnosticResultInclude<ExtArgs> | null
    /**
     * Filter, which SATDiagnosticResult to fetch.
     */
    where?: SATDiagnosticResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SATDiagnosticResults to fetch.
     */
    orderBy?: SATDiagnosticResultOrderByWithRelationInput | SATDiagnosticResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SATDiagnosticResults.
     */
    cursor?: SATDiagnosticResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SATDiagnosticResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SATDiagnosticResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SATDiagnosticResults.
     */
    distinct?: SATDiagnosticResultScalarFieldEnum | SATDiagnosticResultScalarFieldEnum[]
  }

  /**
   * SATDiagnosticResult findMany
   */
  export type SATDiagnosticResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATDiagnosticResult
     */
    select?: SATDiagnosticResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATDiagnosticResult
     */
    omit?: SATDiagnosticResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATDiagnosticResultInclude<ExtArgs> | null
    /**
     * Filter, which SATDiagnosticResults to fetch.
     */
    where?: SATDiagnosticResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SATDiagnosticResults to fetch.
     */
    orderBy?: SATDiagnosticResultOrderByWithRelationInput | SATDiagnosticResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SATDiagnosticResults.
     */
    cursor?: SATDiagnosticResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SATDiagnosticResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SATDiagnosticResults.
     */
    skip?: number
    distinct?: SATDiagnosticResultScalarFieldEnum | SATDiagnosticResultScalarFieldEnum[]
  }

  /**
   * SATDiagnosticResult create
   */
  export type SATDiagnosticResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATDiagnosticResult
     */
    select?: SATDiagnosticResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATDiagnosticResult
     */
    omit?: SATDiagnosticResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATDiagnosticResultInclude<ExtArgs> | null
    /**
     * The data needed to create a SATDiagnosticResult.
     */
    data: XOR<SATDiagnosticResultCreateInput, SATDiagnosticResultUncheckedCreateInput>
  }

  /**
   * SATDiagnosticResult createMany
   */
  export type SATDiagnosticResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SATDiagnosticResults.
     */
    data: SATDiagnosticResultCreateManyInput | SATDiagnosticResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SATDiagnosticResult createManyAndReturn
   */
  export type SATDiagnosticResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATDiagnosticResult
     */
    select?: SATDiagnosticResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SATDiagnosticResult
     */
    omit?: SATDiagnosticResultOmit<ExtArgs> | null
    /**
     * The data used to create many SATDiagnosticResults.
     */
    data: SATDiagnosticResultCreateManyInput | SATDiagnosticResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATDiagnosticResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SATDiagnosticResult update
   */
  export type SATDiagnosticResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATDiagnosticResult
     */
    select?: SATDiagnosticResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATDiagnosticResult
     */
    omit?: SATDiagnosticResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATDiagnosticResultInclude<ExtArgs> | null
    /**
     * The data needed to update a SATDiagnosticResult.
     */
    data: XOR<SATDiagnosticResultUpdateInput, SATDiagnosticResultUncheckedUpdateInput>
    /**
     * Choose, which SATDiagnosticResult to update.
     */
    where: SATDiagnosticResultWhereUniqueInput
  }

  /**
   * SATDiagnosticResult updateMany
   */
  export type SATDiagnosticResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SATDiagnosticResults.
     */
    data: XOR<SATDiagnosticResultUpdateManyMutationInput, SATDiagnosticResultUncheckedUpdateManyInput>
    /**
     * Filter which SATDiagnosticResults to update
     */
    where?: SATDiagnosticResultWhereInput
    /**
     * Limit how many SATDiagnosticResults to update.
     */
    limit?: number
  }

  /**
   * SATDiagnosticResult updateManyAndReturn
   */
  export type SATDiagnosticResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATDiagnosticResult
     */
    select?: SATDiagnosticResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SATDiagnosticResult
     */
    omit?: SATDiagnosticResultOmit<ExtArgs> | null
    /**
     * The data used to update SATDiagnosticResults.
     */
    data: XOR<SATDiagnosticResultUpdateManyMutationInput, SATDiagnosticResultUncheckedUpdateManyInput>
    /**
     * Filter which SATDiagnosticResults to update
     */
    where?: SATDiagnosticResultWhereInput
    /**
     * Limit how many SATDiagnosticResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATDiagnosticResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SATDiagnosticResult upsert
   */
  export type SATDiagnosticResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATDiagnosticResult
     */
    select?: SATDiagnosticResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATDiagnosticResult
     */
    omit?: SATDiagnosticResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATDiagnosticResultInclude<ExtArgs> | null
    /**
     * The filter to search for the SATDiagnosticResult to update in case it exists.
     */
    where: SATDiagnosticResultWhereUniqueInput
    /**
     * In case the SATDiagnosticResult found by the `where` argument doesn't exist, create a new SATDiagnosticResult with this data.
     */
    create: XOR<SATDiagnosticResultCreateInput, SATDiagnosticResultUncheckedCreateInput>
    /**
     * In case the SATDiagnosticResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SATDiagnosticResultUpdateInput, SATDiagnosticResultUncheckedUpdateInput>
  }

  /**
   * SATDiagnosticResult delete
   */
  export type SATDiagnosticResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATDiagnosticResult
     */
    select?: SATDiagnosticResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATDiagnosticResult
     */
    omit?: SATDiagnosticResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATDiagnosticResultInclude<ExtArgs> | null
    /**
     * Filter which SATDiagnosticResult to delete.
     */
    where: SATDiagnosticResultWhereUniqueInput
  }

  /**
   * SATDiagnosticResult deleteMany
   */
  export type SATDiagnosticResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SATDiagnosticResults to delete
     */
    where?: SATDiagnosticResultWhereInput
    /**
     * Limit how many SATDiagnosticResults to delete.
     */
    limit?: number
  }

  /**
   * SATDiagnosticResult without action
   */
  export type SATDiagnosticResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SATDiagnosticResult
     */
    select?: SATDiagnosticResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SATDiagnosticResult
     */
    omit?: SATDiagnosticResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SATDiagnosticResultInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    topic: string | null
    subject: string | null
    difficulty: string | null
    question: string | null
    answer: string | null
    explanation: string | null
    source: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userGeneratedBy: string | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    topic: string | null
    subject: string | null
    difficulty: string | null
    question: string | null
    answer: string | null
    explanation: string | null
    source: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userGeneratedBy: string | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    topic: number
    subject: number
    difficulty: number
    question: number
    choices: number
    answer: number
    explanation: number
    source: number
    status: number
    createdAt: number
    updatedAt: number
    userGeneratedBy: number
    _all: number
  }


  export type QuestionMinAggregateInputType = {
    id?: true
    topic?: true
    subject?: true
    difficulty?: true
    question?: true
    answer?: true
    explanation?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userGeneratedBy?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    topic?: true
    subject?: true
    difficulty?: true
    question?: true
    answer?: true
    explanation?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userGeneratedBy?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    topic?: true
    subject?: true
    difficulty?: true
    question?: true
    choices?: true
    answer?: true
    explanation?: true
    source?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userGeneratedBy?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: string
    topic: string
    subject: string
    difficulty: string
    question: string
    choices: JsonValue
    answer: string
    explanation: string
    source: string
    status: string
    createdAt: Date
    updatedAt: Date
    userGeneratedBy: string | null
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    subject?: boolean
    difficulty?: boolean
    question?: boolean
    choices?: boolean
    answer?: boolean
    explanation?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userGeneratedBy?: boolean
    user?: boolean | Question$userArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    subject?: boolean
    difficulty?: boolean
    question?: boolean
    choices?: boolean
    answer?: boolean
    explanation?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userGeneratedBy?: boolean
    user?: boolean | Question$userArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    subject?: boolean
    difficulty?: boolean
    question?: boolean
    choices?: boolean
    answer?: boolean
    explanation?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userGeneratedBy?: boolean
    user?: boolean | Question$userArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectScalar = {
    id?: boolean
    topic?: boolean
    subject?: boolean
    difficulty?: boolean
    question?: boolean
    choices?: boolean
    answer?: boolean
    explanation?: boolean
    source?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userGeneratedBy?: boolean
  }

  export type QuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "topic" | "subject" | "difficulty" | "question" | "choices" | "answer" | "explanation" | "source" | "status" | "createdAt" | "updatedAt" | "userGeneratedBy", ExtArgs["result"]["question"]>
  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Question$userArgs<ExtArgs>
  }
  export type QuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Question$userArgs<ExtArgs>
  }
  export type QuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Question$userArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topic: string
      subject: string
      difficulty: string
      question: string
      choices: Prisma.JsonValue
      answer: string
      explanation: string
      source: string
      status: string
      createdAt: Date
      updatedAt: Date
      userGeneratedBy: string | null
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions and returns the data updated in the database.
     * @param {QuestionUpdateManyAndReturnArgs} args - Arguments to update many Questions.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Question$userArgs<ExtArgs> = {}>(args?: Subset<T, Question$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'String'>
    readonly topic: FieldRef<"Question", 'String'>
    readonly subject: FieldRef<"Question", 'String'>
    readonly difficulty: FieldRef<"Question", 'String'>
    readonly question: FieldRef<"Question", 'String'>
    readonly choices: FieldRef<"Question", 'Json'>
    readonly answer: FieldRef<"Question", 'String'>
    readonly explanation: FieldRef<"Question", 'String'>
    readonly source: FieldRef<"Question", 'String'>
    readonly status: FieldRef<"Question", 'String'>
    readonly createdAt: FieldRef<"Question", 'DateTime'>
    readonly updatedAt: FieldRef<"Question", 'DateTime'>
    readonly userGeneratedBy: FieldRef<"Question", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question createManyAndReturn
   */
  export type QuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
  }

  /**
   * Question updateManyAndReturn
   */
  export type QuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to delete.
     */
    limit?: number
  }

  /**
   * Question.user
   */
  export type Question$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model MockExam
   */

  export type AggregateMockExam = {
    _count: MockExamCountAggregateOutputType | null
    _avg: MockExamAvgAggregateOutputType | null
    _sum: MockExamSumAggregateOutputType | null
    _min: MockExamMinAggregateOutputType | null
    _max: MockExamMaxAggregateOutputType | null
  }

  export type MockExamAvgAggregateOutputType = {
    grade: number | null
    totalTime: number | null
  }

  export type MockExamSumAggregateOutputType = {
    grade: number | null
    totalTime: number | null
  }

  export type MockExamMinAggregateOutputType = {
    id: string | null
    userId: string | null
    goal: string | null
    grade: number | null
    totalTime: number | null
    createdAt: Date | null
  }

  export type MockExamMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    goal: string | null
    grade: number | null
    totalTime: number | null
    createdAt: Date | null
  }

  export type MockExamCountAggregateOutputType = {
    id: number
    userId: number
    goal: number
    grade: number
    sections: number
    totalTime: number
    createdAt: number
    _all: number
  }


  export type MockExamAvgAggregateInputType = {
    grade?: true
    totalTime?: true
  }

  export type MockExamSumAggregateInputType = {
    grade?: true
    totalTime?: true
  }

  export type MockExamMinAggregateInputType = {
    id?: true
    userId?: true
    goal?: true
    grade?: true
    totalTime?: true
    createdAt?: true
  }

  export type MockExamMaxAggregateInputType = {
    id?: true
    userId?: true
    goal?: true
    grade?: true
    totalTime?: true
    createdAt?: true
  }

  export type MockExamCountAggregateInputType = {
    id?: true
    userId?: true
    goal?: true
    grade?: true
    sections?: true
    totalTime?: true
    createdAt?: true
    _all?: true
  }

  export type MockExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MockExam to aggregate.
     */
    where?: MockExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockExams to fetch.
     */
    orderBy?: MockExamOrderByWithRelationInput | MockExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MockExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MockExams
    **/
    _count?: true | MockExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MockExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MockExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MockExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MockExamMaxAggregateInputType
  }

  export type GetMockExamAggregateType<T extends MockExamAggregateArgs> = {
        [P in keyof T & keyof AggregateMockExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMockExam[P]>
      : GetScalarType<T[P], AggregateMockExam[P]>
  }




  export type MockExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockExamWhereInput
    orderBy?: MockExamOrderByWithAggregationInput | MockExamOrderByWithAggregationInput[]
    by: MockExamScalarFieldEnum[] | MockExamScalarFieldEnum
    having?: MockExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MockExamCountAggregateInputType | true
    _avg?: MockExamAvgAggregateInputType
    _sum?: MockExamSumAggregateInputType
    _min?: MockExamMinAggregateInputType
    _max?: MockExamMaxAggregateInputType
  }

  export type MockExamGroupByOutputType = {
    id: string
    userId: string
    goal: string
    grade: number
    sections: JsonValue
    totalTime: number
    createdAt: Date
    _count: MockExamCountAggregateOutputType | null
    _avg: MockExamAvgAggregateOutputType | null
    _sum: MockExamSumAggregateOutputType | null
    _min: MockExamMinAggregateOutputType | null
    _max: MockExamMaxAggregateOutputType | null
  }

  type GetMockExamGroupByPayload<T extends MockExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MockExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MockExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MockExamGroupByOutputType[P]>
            : GetScalarType<T[P], MockExamGroupByOutputType[P]>
        }
      >
    >


  export type MockExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    goal?: boolean
    grade?: boolean
    sections?: boolean
    totalTime?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempts?: boolean | MockExam$attemptsArgs<ExtArgs>
    _count?: boolean | MockExamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mockExam"]>

  export type MockExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    goal?: boolean
    grade?: boolean
    sections?: boolean
    totalTime?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mockExam"]>

  export type MockExamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    goal?: boolean
    grade?: boolean
    sections?: boolean
    totalTime?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mockExam"]>

  export type MockExamSelectScalar = {
    id?: boolean
    userId?: boolean
    goal?: boolean
    grade?: boolean
    sections?: boolean
    totalTime?: boolean
    createdAt?: boolean
  }

  export type MockExamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "goal" | "grade" | "sections" | "totalTime" | "createdAt", ExtArgs["result"]["mockExam"]>
  export type MockExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempts?: boolean | MockExam$attemptsArgs<ExtArgs>
    _count?: boolean | MockExamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MockExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MockExamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MockExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MockExam"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      attempts: Prisma.$MockAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      goal: string
      grade: number
      sections: Prisma.JsonValue
      totalTime: number
      createdAt: Date
    }, ExtArgs["result"]["mockExam"]>
    composites: {}
  }

  type MockExamGetPayload<S extends boolean | null | undefined | MockExamDefaultArgs> = $Result.GetResult<Prisma.$MockExamPayload, S>

  type MockExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MockExamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MockExamCountAggregateInputType | true
    }

  export interface MockExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MockExam'], meta: { name: 'MockExam' } }
    /**
     * Find zero or one MockExam that matches the filter.
     * @param {MockExamFindUniqueArgs} args - Arguments to find a MockExam
     * @example
     * // Get one MockExam
     * const mockExam = await prisma.mockExam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MockExamFindUniqueArgs>(args: SelectSubset<T, MockExamFindUniqueArgs<ExtArgs>>): Prisma__MockExamClient<$Result.GetResult<Prisma.$MockExamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MockExam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MockExamFindUniqueOrThrowArgs} args - Arguments to find a MockExam
     * @example
     * // Get one MockExam
     * const mockExam = await prisma.mockExam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MockExamFindUniqueOrThrowArgs>(args: SelectSubset<T, MockExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MockExamClient<$Result.GetResult<Prisma.$MockExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MockExam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockExamFindFirstArgs} args - Arguments to find a MockExam
     * @example
     * // Get one MockExam
     * const mockExam = await prisma.mockExam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MockExamFindFirstArgs>(args?: SelectSubset<T, MockExamFindFirstArgs<ExtArgs>>): Prisma__MockExamClient<$Result.GetResult<Prisma.$MockExamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MockExam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockExamFindFirstOrThrowArgs} args - Arguments to find a MockExam
     * @example
     * // Get one MockExam
     * const mockExam = await prisma.mockExam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MockExamFindFirstOrThrowArgs>(args?: SelectSubset<T, MockExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__MockExamClient<$Result.GetResult<Prisma.$MockExamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MockExams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MockExams
     * const mockExams = await prisma.mockExam.findMany()
     * 
     * // Get first 10 MockExams
     * const mockExams = await prisma.mockExam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mockExamWithIdOnly = await prisma.mockExam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MockExamFindManyArgs>(args?: SelectSubset<T, MockExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MockExam.
     * @param {MockExamCreateArgs} args - Arguments to create a MockExam.
     * @example
     * // Create one MockExam
     * const MockExam = await prisma.mockExam.create({
     *   data: {
     *     // ... data to create a MockExam
     *   }
     * })
     * 
     */
    create<T extends MockExamCreateArgs>(args: SelectSubset<T, MockExamCreateArgs<ExtArgs>>): Prisma__MockExamClient<$Result.GetResult<Prisma.$MockExamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MockExams.
     * @param {MockExamCreateManyArgs} args - Arguments to create many MockExams.
     * @example
     * // Create many MockExams
     * const mockExam = await prisma.mockExam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MockExamCreateManyArgs>(args?: SelectSubset<T, MockExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MockExams and returns the data saved in the database.
     * @param {MockExamCreateManyAndReturnArgs} args - Arguments to create many MockExams.
     * @example
     * // Create many MockExams
     * const mockExam = await prisma.mockExam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MockExams and only return the `id`
     * const mockExamWithIdOnly = await prisma.mockExam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MockExamCreateManyAndReturnArgs>(args?: SelectSubset<T, MockExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockExamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MockExam.
     * @param {MockExamDeleteArgs} args - Arguments to delete one MockExam.
     * @example
     * // Delete one MockExam
     * const MockExam = await prisma.mockExam.delete({
     *   where: {
     *     // ... filter to delete one MockExam
     *   }
     * })
     * 
     */
    delete<T extends MockExamDeleteArgs>(args: SelectSubset<T, MockExamDeleteArgs<ExtArgs>>): Prisma__MockExamClient<$Result.GetResult<Prisma.$MockExamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MockExam.
     * @param {MockExamUpdateArgs} args - Arguments to update one MockExam.
     * @example
     * // Update one MockExam
     * const mockExam = await prisma.mockExam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MockExamUpdateArgs>(args: SelectSubset<T, MockExamUpdateArgs<ExtArgs>>): Prisma__MockExamClient<$Result.GetResult<Prisma.$MockExamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MockExams.
     * @param {MockExamDeleteManyArgs} args - Arguments to filter MockExams to delete.
     * @example
     * // Delete a few MockExams
     * const { count } = await prisma.mockExam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MockExamDeleteManyArgs>(args?: SelectSubset<T, MockExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MockExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MockExams
     * const mockExam = await prisma.mockExam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MockExamUpdateManyArgs>(args: SelectSubset<T, MockExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MockExams and returns the data updated in the database.
     * @param {MockExamUpdateManyAndReturnArgs} args - Arguments to update many MockExams.
     * @example
     * // Update many MockExams
     * const mockExam = await prisma.mockExam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MockExams and only return the `id`
     * const mockExamWithIdOnly = await prisma.mockExam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MockExamUpdateManyAndReturnArgs>(args: SelectSubset<T, MockExamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockExamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MockExam.
     * @param {MockExamUpsertArgs} args - Arguments to update or create a MockExam.
     * @example
     * // Update or create a MockExam
     * const mockExam = await prisma.mockExam.upsert({
     *   create: {
     *     // ... data to create a MockExam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MockExam we want to update
     *   }
     * })
     */
    upsert<T extends MockExamUpsertArgs>(args: SelectSubset<T, MockExamUpsertArgs<ExtArgs>>): Prisma__MockExamClient<$Result.GetResult<Prisma.$MockExamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MockExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockExamCountArgs} args - Arguments to filter MockExams to count.
     * @example
     * // Count the number of MockExams
     * const count = await prisma.mockExam.count({
     *   where: {
     *     // ... the filter for the MockExams we want to count
     *   }
     * })
    **/
    count<T extends MockExamCountArgs>(
      args?: Subset<T, MockExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MockExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MockExam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MockExamAggregateArgs>(args: Subset<T, MockExamAggregateArgs>): Prisma.PrismaPromise<GetMockExamAggregateType<T>>

    /**
     * Group by MockExam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MockExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MockExamGroupByArgs['orderBy'] }
        : { orderBy?: MockExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MockExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMockExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MockExam model
   */
  readonly fields: MockExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MockExam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MockExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attempts<T extends MockExam$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, MockExam$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MockExam model
   */
  interface MockExamFieldRefs {
    readonly id: FieldRef<"MockExam", 'String'>
    readonly userId: FieldRef<"MockExam", 'String'>
    readonly goal: FieldRef<"MockExam", 'String'>
    readonly grade: FieldRef<"MockExam", 'Int'>
    readonly sections: FieldRef<"MockExam", 'Json'>
    readonly totalTime: FieldRef<"MockExam", 'Int'>
    readonly createdAt: FieldRef<"MockExam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MockExam findUnique
   */
  export type MockExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExam
     */
    select?: MockExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockExam
     */
    omit?: MockExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockExamInclude<ExtArgs> | null
    /**
     * Filter, which MockExam to fetch.
     */
    where: MockExamWhereUniqueInput
  }

  /**
   * MockExam findUniqueOrThrow
   */
  export type MockExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExam
     */
    select?: MockExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockExam
     */
    omit?: MockExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockExamInclude<ExtArgs> | null
    /**
     * Filter, which MockExam to fetch.
     */
    where: MockExamWhereUniqueInput
  }

  /**
   * MockExam findFirst
   */
  export type MockExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExam
     */
    select?: MockExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockExam
     */
    omit?: MockExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockExamInclude<ExtArgs> | null
    /**
     * Filter, which MockExam to fetch.
     */
    where?: MockExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockExams to fetch.
     */
    orderBy?: MockExamOrderByWithRelationInput | MockExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MockExams.
     */
    cursor?: MockExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MockExams.
     */
    distinct?: MockExamScalarFieldEnum | MockExamScalarFieldEnum[]
  }

  /**
   * MockExam findFirstOrThrow
   */
  export type MockExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExam
     */
    select?: MockExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockExam
     */
    omit?: MockExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockExamInclude<ExtArgs> | null
    /**
     * Filter, which MockExam to fetch.
     */
    where?: MockExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockExams to fetch.
     */
    orderBy?: MockExamOrderByWithRelationInput | MockExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MockExams.
     */
    cursor?: MockExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MockExams.
     */
    distinct?: MockExamScalarFieldEnum | MockExamScalarFieldEnum[]
  }

  /**
   * MockExam findMany
   */
  export type MockExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExam
     */
    select?: MockExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockExam
     */
    omit?: MockExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockExamInclude<ExtArgs> | null
    /**
     * Filter, which MockExams to fetch.
     */
    where?: MockExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockExams to fetch.
     */
    orderBy?: MockExamOrderByWithRelationInput | MockExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MockExams.
     */
    cursor?: MockExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockExams.
     */
    skip?: number
    distinct?: MockExamScalarFieldEnum | MockExamScalarFieldEnum[]
  }

  /**
   * MockExam create
   */
  export type MockExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExam
     */
    select?: MockExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockExam
     */
    omit?: MockExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockExamInclude<ExtArgs> | null
    /**
     * The data needed to create a MockExam.
     */
    data: XOR<MockExamCreateInput, MockExamUncheckedCreateInput>
  }

  /**
   * MockExam createMany
   */
  export type MockExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MockExams.
     */
    data: MockExamCreateManyInput | MockExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MockExam createManyAndReturn
   */
  export type MockExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExam
     */
    select?: MockExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MockExam
     */
    omit?: MockExamOmit<ExtArgs> | null
    /**
     * The data used to create many MockExams.
     */
    data: MockExamCreateManyInput | MockExamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MockExam update
   */
  export type MockExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExam
     */
    select?: MockExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockExam
     */
    omit?: MockExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockExamInclude<ExtArgs> | null
    /**
     * The data needed to update a MockExam.
     */
    data: XOR<MockExamUpdateInput, MockExamUncheckedUpdateInput>
    /**
     * Choose, which MockExam to update.
     */
    where: MockExamWhereUniqueInput
  }

  /**
   * MockExam updateMany
   */
  export type MockExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MockExams.
     */
    data: XOR<MockExamUpdateManyMutationInput, MockExamUncheckedUpdateManyInput>
    /**
     * Filter which MockExams to update
     */
    where?: MockExamWhereInput
    /**
     * Limit how many MockExams to update.
     */
    limit?: number
  }

  /**
   * MockExam updateManyAndReturn
   */
  export type MockExamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExam
     */
    select?: MockExamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MockExam
     */
    omit?: MockExamOmit<ExtArgs> | null
    /**
     * The data used to update MockExams.
     */
    data: XOR<MockExamUpdateManyMutationInput, MockExamUncheckedUpdateManyInput>
    /**
     * Filter which MockExams to update
     */
    where?: MockExamWhereInput
    /**
     * Limit how many MockExams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockExamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MockExam upsert
   */
  export type MockExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExam
     */
    select?: MockExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockExam
     */
    omit?: MockExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockExamInclude<ExtArgs> | null
    /**
     * The filter to search for the MockExam to update in case it exists.
     */
    where: MockExamWhereUniqueInput
    /**
     * In case the MockExam found by the `where` argument doesn't exist, create a new MockExam with this data.
     */
    create: XOR<MockExamCreateInput, MockExamUncheckedCreateInput>
    /**
     * In case the MockExam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MockExamUpdateInput, MockExamUncheckedUpdateInput>
  }

  /**
   * MockExam delete
   */
  export type MockExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExam
     */
    select?: MockExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockExam
     */
    omit?: MockExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockExamInclude<ExtArgs> | null
    /**
     * Filter which MockExam to delete.
     */
    where: MockExamWhereUniqueInput
  }

  /**
   * MockExam deleteMany
   */
  export type MockExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MockExams to delete
     */
    where?: MockExamWhereInput
    /**
     * Limit how many MockExams to delete.
     */
    limit?: number
  }

  /**
   * MockExam.attempts
   */
  export type MockExam$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptInclude<ExtArgs> | null
    where?: MockAttemptWhereInput
    orderBy?: MockAttemptOrderByWithRelationInput | MockAttemptOrderByWithRelationInput[]
    cursor?: MockAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MockAttemptScalarFieldEnum | MockAttemptScalarFieldEnum[]
  }

  /**
   * MockExam without action
   */
  export type MockExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockExam
     */
    select?: MockExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockExam
     */
    omit?: MockExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockExamInclude<ExtArgs> | null
  }


  /**
   * Model MockAttempt
   */

  export type AggregateMockAttempt = {
    _count: MockAttemptCountAggregateOutputType | null
    _min: MockAttemptMinAggregateOutputType | null
    _max: MockAttemptMaxAggregateOutputType | null
  }

  export type MockAttemptMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mockExamId: string | null
    startedAt: Date | null
    finishedAt: Date | null
    createdAt: Date | null
  }

  export type MockAttemptMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mockExamId: string | null
    startedAt: Date | null
    finishedAt: Date | null
    createdAt: Date | null
  }

  export type MockAttemptCountAggregateOutputType = {
    id: number
    userId: number
    mockExamId: number
    answers: number
    scored: number
    summary: number
    startedAt: number
    finishedAt: number
    createdAt: number
    _all: number
  }


  export type MockAttemptMinAggregateInputType = {
    id?: true
    userId?: true
    mockExamId?: true
    startedAt?: true
    finishedAt?: true
    createdAt?: true
  }

  export type MockAttemptMaxAggregateInputType = {
    id?: true
    userId?: true
    mockExamId?: true
    startedAt?: true
    finishedAt?: true
    createdAt?: true
  }

  export type MockAttemptCountAggregateInputType = {
    id?: true
    userId?: true
    mockExamId?: true
    answers?: true
    scored?: true
    summary?: true
    startedAt?: true
    finishedAt?: true
    createdAt?: true
    _all?: true
  }

  export type MockAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MockAttempt to aggregate.
     */
    where?: MockAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockAttempts to fetch.
     */
    orderBy?: MockAttemptOrderByWithRelationInput | MockAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MockAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MockAttempts
    **/
    _count?: true | MockAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MockAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MockAttemptMaxAggregateInputType
  }

  export type GetMockAttemptAggregateType<T extends MockAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateMockAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMockAttempt[P]>
      : GetScalarType<T[P], AggregateMockAttempt[P]>
  }




  export type MockAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MockAttemptWhereInput
    orderBy?: MockAttemptOrderByWithAggregationInput | MockAttemptOrderByWithAggregationInput[]
    by: MockAttemptScalarFieldEnum[] | MockAttemptScalarFieldEnum
    having?: MockAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MockAttemptCountAggregateInputType | true
    _min?: MockAttemptMinAggregateInputType
    _max?: MockAttemptMaxAggregateInputType
  }

  export type MockAttemptGroupByOutputType = {
    id: string
    userId: string
    mockExamId: string
    answers: JsonValue
    scored: JsonValue
    summary: JsonValue
    startedAt: Date
    finishedAt: Date
    createdAt: Date
    _count: MockAttemptCountAggregateOutputType | null
    _min: MockAttemptMinAggregateOutputType | null
    _max: MockAttemptMaxAggregateOutputType | null
  }

  type GetMockAttemptGroupByPayload<T extends MockAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MockAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MockAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MockAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], MockAttemptGroupByOutputType[P]>
        }
      >
    >


  export type MockAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mockExamId?: boolean
    answers?: boolean
    scored?: boolean
    summary?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mockExam?: boolean | MockExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mockAttempt"]>

  export type MockAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mockExamId?: boolean
    answers?: boolean
    scored?: boolean
    summary?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mockExam?: boolean | MockExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mockAttempt"]>

  export type MockAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mockExamId?: boolean
    answers?: boolean
    scored?: boolean
    summary?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mockExam?: boolean | MockExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mockAttempt"]>

  export type MockAttemptSelectScalar = {
    id?: boolean
    userId?: boolean
    mockExamId?: boolean
    answers?: boolean
    scored?: boolean
    summary?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    createdAt?: boolean
  }

  export type MockAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mockExamId" | "answers" | "scored" | "summary" | "startedAt" | "finishedAt" | "createdAt", ExtArgs["result"]["mockAttempt"]>
  export type MockAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mockExam?: boolean | MockExamDefaultArgs<ExtArgs>
  }
  export type MockAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mockExam?: boolean | MockExamDefaultArgs<ExtArgs>
  }
  export type MockAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mockExam?: boolean | MockExamDefaultArgs<ExtArgs>
  }

  export type $MockAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MockAttempt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      mockExam: Prisma.$MockExamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mockExamId: string
      answers: Prisma.JsonValue
      scored: Prisma.JsonValue
      summary: Prisma.JsonValue
      startedAt: Date
      finishedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["mockAttempt"]>
    composites: {}
  }

  type MockAttemptGetPayload<S extends boolean | null | undefined | MockAttemptDefaultArgs> = $Result.GetResult<Prisma.$MockAttemptPayload, S>

  type MockAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MockAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MockAttemptCountAggregateInputType | true
    }

  export interface MockAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MockAttempt'], meta: { name: 'MockAttempt' } }
    /**
     * Find zero or one MockAttempt that matches the filter.
     * @param {MockAttemptFindUniqueArgs} args - Arguments to find a MockAttempt
     * @example
     * // Get one MockAttempt
     * const mockAttempt = await prisma.mockAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MockAttemptFindUniqueArgs>(args: SelectSubset<T, MockAttemptFindUniqueArgs<ExtArgs>>): Prisma__MockAttemptClient<$Result.GetResult<Prisma.$MockAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MockAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MockAttemptFindUniqueOrThrowArgs} args - Arguments to find a MockAttempt
     * @example
     * // Get one MockAttempt
     * const mockAttempt = await prisma.mockAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MockAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, MockAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MockAttemptClient<$Result.GetResult<Prisma.$MockAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MockAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockAttemptFindFirstArgs} args - Arguments to find a MockAttempt
     * @example
     * // Get one MockAttempt
     * const mockAttempt = await prisma.mockAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MockAttemptFindFirstArgs>(args?: SelectSubset<T, MockAttemptFindFirstArgs<ExtArgs>>): Prisma__MockAttemptClient<$Result.GetResult<Prisma.$MockAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MockAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockAttemptFindFirstOrThrowArgs} args - Arguments to find a MockAttempt
     * @example
     * // Get one MockAttempt
     * const mockAttempt = await prisma.mockAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MockAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, MockAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__MockAttemptClient<$Result.GetResult<Prisma.$MockAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MockAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MockAttempts
     * const mockAttempts = await prisma.mockAttempt.findMany()
     * 
     * // Get first 10 MockAttempts
     * const mockAttempts = await prisma.mockAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mockAttemptWithIdOnly = await prisma.mockAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MockAttemptFindManyArgs>(args?: SelectSubset<T, MockAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MockAttempt.
     * @param {MockAttemptCreateArgs} args - Arguments to create a MockAttempt.
     * @example
     * // Create one MockAttempt
     * const MockAttempt = await prisma.mockAttempt.create({
     *   data: {
     *     // ... data to create a MockAttempt
     *   }
     * })
     * 
     */
    create<T extends MockAttemptCreateArgs>(args: SelectSubset<T, MockAttemptCreateArgs<ExtArgs>>): Prisma__MockAttemptClient<$Result.GetResult<Prisma.$MockAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MockAttempts.
     * @param {MockAttemptCreateManyArgs} args - Arguments to create many MockAttempts.
     * @example
     * // Create many MockAttempts
     * const mockAttempt = await prisma.mockAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MockAttemptCreateManyArgs>(args?: SelectSubset<T, MockAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MockAttempts and returns the data saved in the database.
     * @param {MockAttemptCreateManyAndReturnArgs} args - Arguments to create many MockAttempts.
     * @example
     * // Create many MockAttempts
     * const mockAttempt = await prisma.mockAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MockAttempts and only return the `id`
     * const mockAttemptWithIdOnly = await prisma.mockAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MockAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, MockAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MockAttempt.
     * @param {MockAttemptDeleteArgs} args - Arguments to delete one MockAttempt.
     * @example
     * // Delete one MockAttempt
     * const MockAttempt = await prisma.mockAttempt.delete({
     *   where: {
     *     // ... filter to delete one MockAttempt
     *   }
     * })
     * 
     */
    delete<T extends MockAttemptDeleteArgs>(args: SelectSubset<T, MockAttemptDeleteArgs<ExtArgs>>): Prisma__MockAttemptClient<$Result.GetResult<Prisma.$MockAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MockAttempt.
     * @param {MockAttemptUpdateArgs} args - Arguments to update one MockAttempt.
     * @example
     * // Update one MockAttempt
     * const mockAttempt = await prisma.mockAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MockAttemptUpdateArgs>(args: SelectSubset<T, MockAttemptUpdateArgs<ExtArgs>>): Prisma__MockAttemptClient<$Result.GetResult<Prisma.$MockAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MockAttempts.
     * @param {MockAttemptDeleteManyArgs} args - Arguments to filter MockAttempts to delete.
     * @example
     * // Delete a few MockAttempts
     * const { count } = await prisma.mockAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MockAttemptDeleteManyArgs>(args?: SelectSubset<T, MockAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MockAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MockAttempts
     * const mockAttempt = await prisma.mockAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MockAttemptUpdateManyArgs>(args: SelectSubset<T, MockAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MockAttempts and returns the data updated in the database.
     * @param {MockAttemptUpdateManyAndReturnArgs} args - Arguments to update many MockAttempts.
     * @example
     * // Update many MockAttempts
     * const mockAttempt = await prisma.mockAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MockAttempts and only return the `id`
     * const mockAttemptWithIdOnly = await prisma.mockAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MockAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, MockAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MockAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MockAttempt.
     * @param {MockAttemptUpsertArgs} args - Arguments to update or create a MockAttempt.
     * @example
     * // Update or create a MockAttempt
     * const mockAttempt = await prisma.mockAttempt.upsert({
     *   create: {
     *     // ... data to create a MockAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MockAttempt we want to update
     *   }
     * })
     */
    upsert<T extends MockAttemptUpsertArgs>(args: SelectSubset<T, MockAttemptUpsertArgs<ExtArgs>>): Prisma__MockAttemptClient<$Result.GetResult<Prisma.$MockAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MockAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockAttemptCountArgs} args - Arguments to filter MockAttempts to count.
     * @example
     * // Count the number of MockAttempts
     * const count = await prisma.mockAttempt.count({
     *   where: {
     *     // ... the filter for the MockAttempts we want to count
     *   }
     * })
    **/
    count<T extends MockAttemptCountArgs>(
      args?: Subset<T, MockAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MockAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MockAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MockAttemptAggregateArgs>(args: Subset<T, MockAttemptAggregateArgs>): Prisma.PrismaPromise<GetMockAttemptAggregateType<T>>

    /**
     * Group by MockAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MockAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MockAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MockAttemptGroupByArgs['orderBy'] }
        : { orderBy?: MockAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MockAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMockAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MockAttempt model
   */
  readonly fields: MockAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MockAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MockAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mockExam<T extends MockExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MockExamDefaultArgs<ExtArgs>>): Prisma__MockExamClient<$Result.GetResult<Prisma.$MockExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MockAttempt model
   */
  interface MockAttemptFieldRefs {
    readonly id: FieldRef<"MockAttempt", 'String'>
    readonly userId: FieldRef<"MockAttempt", 'String'>
    readonly mockExamId: FieldRef<"MockAttempt", 'String'>
    readonly answers: FieldRef<"MockAttempt", 'Json'>
    readonly scored: FieldRef<"MockAttempt", 'Json'>
    readonly summary: FieldRef<"MockAttempt", 'Json'>
    readonly startedAt: FieldRef<"MockAttempt", 'DateTime'>
    readonly finishedAt: FieldRef<"MockAttempt", 'DateTime'>
    readonly createdAt: FieldRef<"MockAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MockAttempt findUnique
   */
  export type MockAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptInclude<ExtArgs> | null
    /**
     * Filter, which MockAttempt to fetch.
     */
    where: MockAttemptWhereUniqueInput
  }

  /**
   * MockAttempt findUniqueOrThrow
   */
  export type MockAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptInclude<ExtArgs> | null
    /**
     * Filter, which MockAttempt to fetch.
     */
    where: MockAttemptWhereUniqueInput
  }

  /**
   * MockAttempt findFirst
   */
  export type MockAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptInclude<ExtArgs> | null
    /**
     * Filter, which MockAttempt to fetch.
     */
    where?: MockAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockAttempts to fetch.
     */
    orderBy?: MockAttemptOrderByWithRelationInput | MockAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MockAttempts.
     */
    cursor?: MockAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MockAttempts.
     */
    distinct?: MockAttemptScalarFieldEnum | MockAttemptScalarFieldEnum[]
  }

  /**
   * MockAttempt findFirstOrThrow
   */
  export type MockAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptInclude<ExtArgs> | null
    /**
     * Filter, which MockAttempt to fetch.
     */
    where?: MockAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockAttempts to fetch.
     */
    orderBy?: MockAttemptOrderByWithRelationInput | MockAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MockAttempts.
     */
    cursor?: MockAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MockAttempts.
     */
    distinct?: MockAttemptScalarFieldEnum | MockAttemptScalarFieldEnum[]
  }

  /**
   * MockAttempt findMany
   */
  export type MockAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptInclude<ExtArgs> | null
    /**
     * Filter, which MockAttempts to fetch.
     */
    where?: MockAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MockAttempts to fetch.
     */
    orderBy?: MockAttemptOrderByWithRelationInput | MockAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MockAttempts.
     */
    cursor?: MockAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MockAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MockAttempts.
     */
    skip?: number
    distinct?: MockAttemptScalarFieldEnum | MockAttemptScalarFieldEnum[]
  }

  /**
   * MockAttempt create
   */
  export type MockAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a MockAttempt.
     */
    data: XOR<MockAttemptCreateInput, MockAttemptUncheckedCreateInput>
  }

  /**
   * MockAttempt createMany
   */
  export type MockAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MockAttempts.
     */
    data: MockAttemptCreateManyInput | MockAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MockAttempt createManyAndReturn
   */
  export type MockAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many MockAttempts.
     */
    data: MockAttemptCreateManyInput | MockAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MockAttempt update
   */
  export type MockAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a MockAttempt.
     */
    data: XOR<MockAttemptUpdateInput, MockAttemptUncheckedUpdateInput>
    /**
     * Choose, which MockAttempt to update.
     */
    where: MockAttemptWhereUniqueInput
  }

  /**
   * MockAttempt updateMany
   */
  export type MockAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MockAttempts.
     */
    data: XOR<MockAttemptUpdateManyMutationInput, MockAttemptUncheckedUpdateManyInput>
    /**
     * Filter which MockAttempts to update
     */
    where?: MockAttemptWhereInput
    /**
     * Limit how many MockAttempts to update.
     */
    limit?: number
  }

  /**
   * MockAttempt updateManyAndReturn
   */
  export type MockAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * The data used to update MockAttempts.
     */
    data: XOR<MockAttemptUpdateManyMutationInput, MockAttemptUncheckedUpdateManyInput>
    /**
     * Filter which MockAttempts to update
     */
    where?: MockAttemptWhereInput
    /**
     * Limit how many MockAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MockAttempt upsert
   */
  export type MockAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the MockAttempt to update in case it exists.
     */
    where: MockAttemptWhereUniqueInput
    /**
     * In case the MockAttempt found by the `where` argument doesn't exist, create a new MockAttempt with this data.
     */
    create: XOR<MockAttemptCreateInput, MockAttemptUncheckedCreateInput>
    /**
     * In case the MockAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MockAttemptUpdateInput, MockAttemptUncheckedUpdateInput>
  }

  /**
   * MockAttempt delete
   */
  export type MockAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptInclude<ExtArgs> | null
    /**
     * Filter which MockAttempt to delete.
     */
    where: MockAttemptWhereUniqueInput
  }

  /**
   * MockAttempt deleteMany
   */
  export type MockAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MockAttempts to delete
     */
    where?: MockAttemptWhereInput
    /**
     * Limit how many MockAttempts to delete.
     */
    limit?: number
  }

  /**
   * MockAttempt without action
   */
  export type MockAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MockAttempt
     */
    select?: MockAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MockAttempt
     */
    omit?: MockAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MockAttemptInclude<ExtArgs> | null
  }


  /**
   * Model TopicMastery
   */

  export type AggregateTopicMastery = {
    _count: TopicMasteryCountAggregateOutputType | null
    _avg: TopicMasteryAvgAggregateOutputType | null
    _sum: TopicMasterySumAggregateOutputType | null
    _min: TopicMasteryMinAggregateOutputType | null
    _max: TopicMasteryMaxAggregateOutputType | null
  }

  export type TopicMasteryAvgAggregateOutputType = {
    correct: number | null
    total: number | null
  }

  export type TopicMasterySumAggregateOutputType = {
    correct: number | null
    total: number | null
  }

  export type TopicMasteryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    topic: string | null
    correct: number | null
    total: number | null
    lastSeenAt: Date | null
    updatedAt: Date | null
  }

  export type TopicMasteryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    topic: string | null
    correct: number | null
    total: number | null
    lastSeenAt: Date | null
    updatedAt: Date | null
  }

  export type TopicMasteryCountAggregateOutputType = {
    id: number
    userId: number
    topic: number
    correct: number
    total: number
    lastSeenAt: number
    updatedAt: number
    _all: number
  }


  export type TopicMasteryAvgAggregateInputType = {
    correct?: true
    total?: true
  }

  export type TopicMasterySumAggregateInputType = {
    correct?: true
    total?: true
  }

  export type TopicMasteryMinAggregateInputType = {
    id?: true
    userId?: true
    topic?: true
    correct?: true
    total?: true
    lastSeenAt?: true
    updatedAt?: true
  }

  export type TopicMasteryMaxAggregateInputType = {
    id?: true
    userId?: true
    topic?: true
    correct?: true
    total?: true
    lastSeenAt?: true
    updatedAt?: true
  }

  export type TopicMasteryCountAggregateInputType = {
    id?: true
    userId?: true
    topic?: true
    correct?: true
    total?: true
    lastSeenAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TopicMasteryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopicMastery to aggregate.
     */
    where?: TopicMasteryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicMasteries to fetch.
     */
    orderBy?: TopicMasteryOrderByWithRelationInput | TopicMasteryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicMasteryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicMasteries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicMasteries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TopicMasteries
    **/
    _count?: true | TopicMasteryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicMasteryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicMasterySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMasteryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMasteryMaxAggregateInputType
  }

  export type GetTopicMasteryAggregateType<T extends TopicMasteryAggregateArgs> = {
        [P in keyof T & keyof AggregateTopicMastery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopicMastery[P]>
      : GetScalarType<T[P], AggregateTopicMastery[P]>
  }




  export type TopicMasteryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicMasteryWhereInput
    orderBy?: TopicMasteryOrderByWithAggregationInput | TopicMasteryOrderByWithAggregationInput[]
    by: TopicMasteryScalarFieldEnum[] | TopicMasteryScalarFieldEnum
    having?: TopicMasteryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicMasteryCountAggregateInputType | true
    _avg?: TopicMasteryAvgAggregateInputType
    _sum?: TopicMasterySumAggregateInputType
    _min?: TopicMasteryMinAggregateInputType
    _max?: TopicMasteryMaxAggregateInputType
  }

  export type TopicMasteryGroupByOutputType = {
    id: string
    userId: string
    topic: string
    correct: number
    total: number
    lastSeenAt: Date
    updatedAt: Date
    _count: TopicMasteryCountAggregateOutputType | null
    _avg: TopicMasteryAvgAggregateOutputType | null
    _sum: TopicMasterySumAggregateOutputType | null
    _min: TopicMasteryMinAggregateOutputType | null
    _max: TopicMasteryMaxAggregateOutputType | null
  }

  type GetTopicMasteryGroupByPayload<T extends TopicMasteryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicMasteryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicMasteryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicMasteryGroupByOutputType[P]>
            : GetScalarType<T[P], TopicMasteryGroupByOutputType[P]>
        }
      >
    >


  export type TopicMasterySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topic?: boolean
    correct?: boolean
    total?: boolean
    lastSeenAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topicMastery"]>

  export type TopicMasterySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topic?: boolean
    correct?: boolean
    total?: boolean
    lastSeenAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topicMastery"]>

  export type TopicMasterySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    topic?: boolean
    correct?: boolean
    total?: boolean
    lastSeenAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topicMastery"]>

  export type TopicMasterySelectScalar = {
    id?: boolean
    userId?: boolean
    topic?: boolean
    correct?: boolean
    total?: boolean
    lastSeenAt?: boolean
    updatedAt?: boolean
  }

  export type TopicMasteryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "topic" | "correct" | "total" | "lastSeenAt" | "updatedAt", ExtArgs["result"]["topicMastery"]>
  export type TopicMasteryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TopicMasteryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TopicMasteryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TopicMasteryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TopicMastery"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      topic: string
      correct: number
      total: number
      lastSeenAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["topicMastery"]>
    composites: {}
  }

  type TopicMasteryGetPayload<S extends boolean | null | undefined | TopicMasteryDefaultArgs> = $Result.GetResult<Prisma.$TopicMasteryPayload, S>

  type TopicMasteryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicMasteryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicMasteryCountAggregateInputType | true
    }

  export interface TopicMasteryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TopicMastery'], meta: { name: 'TopicMastery' } }
    /**
     * Find zero or one TopicMastery that matches the filter.
     * @param {TopicMasteryFindUniqueArgs} args - Arguments to find a TopicMastery
     * @example
     * // Get one TopicMastery
     * const topicMastery = await prisma.topicMastery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicMasteryFindUniqueArgs>(args: SelectSubset<T, TopicMasteryFindUniqueArgs<ExtArgs>>): Prisma__TopicMasteryClient<$Result.GetResult<Prisma.$TopicMasteryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TopicMastery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicMasteryFindUniqueOrThrowArgs} args - Arguments to find a TopicMastery
     * @example
     * // Get one TopicMastery
     * const topicMastery = await prisma.topicMastery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicMasteryFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicMasteryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicMasteryClient<$Result.GetResult<Prisma.$TopicMasteryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TopicMastery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicMasteryFindFirstArgs} args - Arguments to find a TopicMastery
     * @example
     * // Get one TopicMastery
     * const topicMastery = await prisma.topicMastery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicMasteryFindFirstArgs>(args?: SelectSubset<T, TopicMasteryFindFirstArgs<ExtArgs>>): Prisma__TopicMasteryClient<$Result.GetResult<Prisma.$TopicMasteryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TopicMastery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicMasteryFindFirstOrThrowArgs} args - Arguments to find a TopicMastery
     * @example
     * // Get one TopicMastery
     * const topicMastery = await prisma.topicMastery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicMasteryFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicMasteryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicMasteryClient<$Result.GetResult<Prisma.$TopicMasteryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TopicMasteries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicMasteryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TopicMasteries
     * const topicMasteries = await prisma.topicMastery.findMany()
     * 
     * // Get first 10 TopicMasteries
     * const topicMasteries = await prisma.topicMastery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicMasteryWithIdOnly = await prisma.topicMastery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicMasteryFindManyArgs>(args?: SelectSubset<T, TopicMasteryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicMasteryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TopicMastery.
     * @param {TopicMasteryCreateArgs} args - Arguments to create a TopicMastery.
     * @example
     * // Create one TopicMastery
     * const TopicMastery = await prisma.topicMastery.create({
     *   data: {
     *     // ... data to create a TopicMastery
     *   }
     * })
     * 
     */
    create<T extends TopicMasteryCreateArgs>(args: SelectSubset<T, TopicMasteryCreateArgs<ExtArgs>>): Prisma__TopicMasteryClient<$Result.GetResult<Prisma.$TopicMasteryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TopicMasteries.
     * @param {TopicMasteryCreateManyArgs} args - Arguments to create many TopicMasteries.
     * @example
     * // Create many TopicMasteries
     * const topicMastery = await prisma.topicMastery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicMasteryCreateManyArgs>(args?: SelectSubset<T, TopicMasteryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TopicMasteries and returns the data saved in the database.
     * @param {TopicMasteryCreateManyAndReturnArgs} args - Arguments to create many TopicMasteries.
     * @example
     * // Create many TopicMasteries
     * const topicMastery = await prisma.topicMastery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TopicMasteries and only return the `id`
     * const topicMasteryWithIdOnly = await prisma.topicMastery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicMasteryCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicMasteryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicMasteryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TopicMastery.
     * @param {TopicMasteryDeleteArgs} args - Arguments to delete one TopicMastery.
     * @example
     * // Delete one TopicMastery
     * const TopicMastery = await prisma.topicMastery.delete({
     *   where: {
     *     // ... filter to delete one TopicMastery
     *   }
     * })
     * 
     */
    delete<T extends TopicMasteryDeleteArgs>(args: SelectSubset<T, TopicMasteryDeleteArgs<ExtArgs>>): Prisma__TopicMasteryClient<$Result.GetResult<Prisma.$TopicMasteryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TopicMastery.
     * @param {TopicMasteryUpdateArgs} args - Arguments to update one TopicMastery.
     * @example
     * // Update one TopicMastery
     * const topicMastery = await prisma.topicMastery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicMasteryUpdateArgs>(args: SelectSubset<T, TopicMasteryUpdateArgs<ExtArgs>>): Prisma__TopicMasteryClient<$Result.GetResult<Prisma.$TopicMasteryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TopicMasteries.
     * @param {TopicMasteryDeleteManyArgs} args - Arguments to filter TopicMasteries to delete.
     * @example
     * // Delete a few TopicMasteries
     * const { count } = await prisma.topicMastery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicMasteryDeleteManyArgs>(args?: SelectSubset<T, TopicMasteryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopicMasteries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicMasteryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TopicMasteries
     * const topicMastery = await prisma.topicMastery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicMasteryUpdateManyArgs>(args: SelectSubset<T, TopicMasteryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopicMasteries and returns the data updated in the database.
     * @param {TopicMasteryUpdateManyAndReturnArgs} args - Arguments to update many TopicMasteries.
     * @example
     * // Update many TopicMasteries
     * const topicMastery = await prisma.topicMastery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TopicMasteries and only return the `id`
     * const topicMasteryWithIdOnly = await prisma.topicMastery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TopicMasteryUpdateManyAndReturnArgs>(args: SelectSubset<T, TopicMasteryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicMasteryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TopicMastery.
     * @param {TopicMasteryUpsertArgs} args - Arguments to update or create a TopicMastery.
     * @example
     * // Update or create a TopicMastery
     * const topicMastery = await prisma.topicMastery.upsert({
     *   create: {
     *     // ... data to create a TopicMastery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TopicMastery we want to update
     *   }
     * })
     */
    upsert<T extends TopicMasteryUpsertArgs>(args: SelectSubset<T, TopicMasteryUpsertArgs<ExtArgs>>): Prisma__TopicMasteryClient<$Result.GetResult<Prisma.$TopicMasteryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TopicMasteries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicMasteryCountArgs} args - Arguments to filter TopicMasteries to count.
     * @example
     * // Count the number of TopicMasteries
     * const count = await prisma.topicMastery.count({
     *   where: {
     *     // ... the filter for the TopicMasteries we want to count
     *   }
     * })
    **/
    count<T extends TopicMasteryCountArgs>(
      args?: Subset<T, TopicMasteryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicMasteryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TopicMastery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicMasteryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicMasteryAggregateArgs>(args: Subset<T, TopicMasteryAggregateArgs>): Prisma.PrismaPromise<GetTopicMasteryAggregateType<T>>

    /**
     * Group by TopicMastery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicMasteryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicMasteryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicMasteryGroupByArgs['orderBy'] }
        : { orderBy?: TopicMasteryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicMasteryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicMasteryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TopicMastery model
   */
  readonly fields: TopicMasteryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TopicMastery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicMasteryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TopicMastery model
   */
  interface TopicMasteryFieldRefs {
    readonly id: FieldRef<"TopicMastery", 'String'>
    readonly userId: FieldRef<"TopicMastery", 'String'>
    readonly topic: FieldRef<"TopicMastery", 'String'>
    readonly correct: FieldRef<"TopicMastery", 'Int'>
    readonly total: FieldRef<"TopicMastery", 'Int'>
    readonly lastSeenAt: FieldRef<"TopicMastery", 'DateTime'>
    readonly updatedAt: FieldRef<"TopicMastery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TopicMastery findUnique
   */
  export type TopicMasteryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicMastery
     */
    select?: TopicMasterySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicMastery
     */
    omit?: TopicMasteryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicMasteryInclude<ExtArgs> | null
    /**
     * Filter, which TopicMastery to fetch.
     */
    where: TopicMasteryWhereUniqueInput
  }

  /**
   * TopicMastery findUniqueOrThrow
   */
  export type TopicMasteryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicMastery
     */
    select?: TopicMasterySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicMastery
     */
    omit?: TopicMasteryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicMasteryInclude<ExtArgs> | null
    /**
     * Filter, which TopicMastery to fetch.
     */
    where: TopicMasteryWhereUniqueInput
  }

  /**
   * TopicMastery findFirst
   */
  export type TopicMasteryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicMastery
     */
    select?: TopicMasterySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicMastery
     */
    omit?: TopicMasteryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicMasteryInclude<ExtArgs> | null
    /**
     * Filter, which TopicMastery to fetch.
     */
    where?: TopicMasteryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicMasteries to fetch.
     */
    orderBy?: TopicMasteryOrderByWithRelationInput | TopicMasteryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopicMasteries.
     */
    cursor?: TopicMasteryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicMasteries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicMasteries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopicMasteries.
     */
    distinct?: TopicMasteryScalarFieldEnum | TopicMasteryScalarFieldEnum[]
  }

  /**
   * TopicMastery findFirstOrThrow
   */
  export type TopicMasteryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicMastery
     */
    select?: TopicMasterySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicMastery
     */
    omit?: TopicMasteryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicMasteryInclude<ExtArgs> | null
    /**
     * Filter, which TopicMastery to fetch.
     */
    where?: TopicMasteryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicMasteries to fetch.
     */
    orderBy?: TopicMasteryOrderByWithRelationInput | TopicMasteryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopicMasteries.
     */
    cursor?: TopicMasteryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicMasteries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicMasteries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopicMasteries.
     */
    distinct?: TopicMasteryScalarFieldEnum | TopicMasteryScalarFieldEnum[]
  }

  /**
   * TopicMastery findMany
   */
  export type TopicMasteryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicMastery
     */
    select?: TopicMasterySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicMastery
     */
    omit?: TopicMasteryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicMasteryInclude<ExtArgs> | null
    /**
     * Filter, which TopicMasteries to fetch.
     */
    where?: TopicMasteryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicMasteries to fetch.
     */
    orderBy?: TopicMasteryOrderByWithRelationInput | TopicMasteryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TopicMasteries.
     */
    cursor?: TopicMasteryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicMasteries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicMasteries.
     */
    skip?: number
    distinct?: TopicMasteryScalarFieldEnum | TopicMasteryScalarFieldEnum[]
  }

  /**
   * TopicMastery create
   */
  export type TopicMasteryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicMastery
     */
    select?: TopicMasterySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicMastery
     */
    omit?: TopicMasteryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicMasteryInclude<ExtArgs> | null
    /**
     * The data needed to create a TopicMastery.
     */
    data: XOR<TopicMasteryCreateInput, TopicMasteryUncheckedCreateInput>
  }

  /**
   * TopicMastery createMany
   */
  export type TopicMasteryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TopicMasteries.
     */
    data: TopicMasteryCreateManyInput | TopicMasteryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TopicMastery createManyAndReturn
   */
  export type TopicMasteryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicMastery
     */
    select?: TopicMasterySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TopicMastery
     */
    omit?: TopicMasteryOmit<ExtArgs> | null
    /**
     * The data used to create many TopicMasteries.
     */
    data: TopicMasteryCreateManyInput | TopicMasteryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicMasteryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TopicMastery update
   */
  export type TopicMasteryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicMastery
     */
    select?: TopicMasterySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicMastery
     */
    omit?: TopicMasteryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicMasteryInclude<ExtArgs> | null
    /**
     * The data needed to update a TopicMastery.
     */
    data: XOR<TopicMasteryUpdateInput, TopicMasteryUncheckedUpdateInput>
    /**
     * Choose, which TopicMastery to update.
     */
    where: TopicMasteryWhereUniqueInput
  }

  /**
   * TopicMastery updateMany
   */
  export type TopicMasteryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TopicMasteries.
     */
    data: XOR<TopicMasteryUpdateManyMutationInput, TopicMasteryUncheckedUpdateManyInput>
    /**
     * Filter which TopicMasteries to update
     */
    where?: TopicMasteryWhereInput
    /**
     * Limit how many TopicMasteries to update.
     */
    limit?: number
  }

  /**
   * TopicMastery updateManyAndReturn
   */
  export type TopicMasteryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicMastery
     */
    select?: TopicMasterySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TopicMastery
     */
    omit?: TopicMasteryOmit<ExtArgs> | null
    /**
     * The data used to update TopicMasteries.
     */
    data: XOR<TopicMasteryUpdateManyMutationInput, TopicMasteryUncheckedUpdateManyInput>
    /**
     * Filter which TopicMasteries to update
     */
    where?: TopicMasteryWhereInput
    /**
     * Limit how many TopicMasteries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicMasteryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TopicMastery upsert
   */
  export type TopicMasteryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicMastery
     */
    select?: TopicMasterySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicMastery
     */
    omit?: TopicMasteryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicMasteryInclude<ExtArgs> | null
    /**
     * The filter to search for the TopicMastery to update in case it exists.
     */
    where: TopicMasteryWhereUniqueInput
    /**
     * In case the TopicMastery found by the `where` argument doesn't exist, create a new TopicMastery with this data.
     */
    create: XOR<TopicMasteryCreateInput, TopicMasteryUncheckedCreateInput>
    /**
     * In case the TopicMastery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicMasteryUpdateInput, TopicMasteryUncheckedUpdateInput>
  }

  /**
   * TopicMastery delete
   */
  export type TopicMasteryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicMastery
     */
    select?: TopicMasterySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicMastery
     */
    omit?: TopicMasteryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicMasteryInclude<ExtArgs> | null
    /**
     * Filter which TopicMastery to delete.
     */
    where: TopicMasteryWhereUniqueInput
  }

  /**
   * TopicMastery deleteMany
   */
  export type TopicMasteryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopicMasteries to delete
     */
    where?: TopicMasteryWhereInput
    /**
     * Limit how many TopicMasteries to delete.
     */
    limit?: number
  }

  /**
   * TopicMastery without action
   */
  export type TopicMasteryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicMastery
     */
    select?: TopicMasterySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicMastery
     */
    omit?: TopicMasteryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicMasteryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    title: 'title',
    content: 'content',
    userId: 'userId'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    role: 'role',
    banned: 'banned',
    banReason: 'banReason',
    banExpires: 'banExpires',
    isOnboarded: 'isOnboarded',
    gradeLevel: 'gradeLevel',
    age: 'age',
    school: 'school',
    subjects: 'subjects',
    learningGoals: 'learningGoals',
    learningStyle: 'learningStyle',
    difficultyLevel: 'difficultyLevel',
    sessionDuration: 'sessionDuration',
    interests: 'interests',
    pastEngagement: 'pastEngagement',
    isInterestedInSATPrep: 'isInterestedInSATPrep'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    impersonatedBy: 'impersonatedBy',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    accountId: 'accountId',
    providerId: 'providerId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    userId: 'userId'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const StudentActivityScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    userId: 'userId',
    type: 'type',
    subject: 'subject',
    topic: 'topic',
    duration: 'duration',
    score: 'score',
    metadata: 'metadata'
  };

  export type StudentActivityScalarFieldEnum = (typeof StudentActivityScalarFieldEnum)[keyof typeof StudentActivityScalarFieldEnum]


  export const LearningStreakScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currentStreak: 'currentStreak',
    longestStreak: 'longestStreak',
    lastActivity: 'lastActivity'
  };

  export type LearningStreakScalarFieldEnum = (typeof LearningStreakScalarFieldEnum)[keyof typeof LearningStreakScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    userId: 'userId',
    title: 'title',
    description: 'description',
    icon: 'icon',
    category: 'category',
    progress: 'progress',
    completed: 'completed'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const ChatSessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    title: 'title',
    topic: 'topic',
    isActive: 'isActive'
  };

  export type ChatSessionScalarFieldEnum = (typeof ChatSessionScalarFieldEnum)[keyof typeof ChatSessionScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    sessionId: 'sessionId',
    content: 'content',
    type: 'type',
    metadata: 'metadata',
    imageUrl: 'imageUrl',
    links: 'links',
    keywords: 'keywords'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const SATStudyPlanScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    timeline: 'timeline',
    focusAreas: 'focusAreas',
    weeklySchedule: 'weeklySchedule',
    resourceRecommendations: 'resourceRecommendations',
    aiGeneratedPlan: 'aiGeneratedPlan',
    completedWeeks: 'completedWeeks',
    completedTasks: 'completedTasks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SATStudyPlanScalarFieldEnum = (typeof SATStudyPlanScalarFieldEnum)[keyof typeof SATStudyPlanScalarFieldEnum]


  export const SATPracticeSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    section: 'section',
    score: 'score',
    maxScore: 'maxScore',
    answers: 'answers',
    timeSpent: 'timeSpent',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type SATPracticeSessionScalarFieldEnum = (typeof SATPracticeSessionScalarFieldEnum)[keyof typeof SATPracticeSessionScalarFieldEnum]


  export const SATDiagnosticResultScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mathScore: 'mathScore',
    readingScore: 'readingScore',
    writingScore: 'writingScore',
    totalScore: 'totalScore',
    strengths: 'strengths',
    weaknesses: 'weaknesses',
    createdAt: 'createdAt'
  };

  export type SATDiagnosticResultScalarFieldEnum = (typeof SATDiagnosticResultScalarFieldEnum)[keyof typeof SATDiagnosticResultScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    topic: 'topic',
    subject: 'subject',
    difficulty: 'difficulty',
    question: 'question',
    choices: 'choices',
    answer: 'answer',
    explanation: 'explanation',
    source: 'source',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userGeneratedBy: 'userGeneratedBy'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const MockExamScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    goal: 'goal',
    grade: 'grade',
    sections: 'sections',
    totalTime: 'totalTime',
    createdAt: 'createdAt'
  };

  export type MockExamScalarFieldEnum = (typeof MockExamScalarFieldEnum)[keyof typeof MockExamScalarFieldEnum]


  export const MockAttemptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mockExamId: 'mockExamId',
    answers: 'answers',
    scored: 'scored',
    summary: 'summary',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    createdAt: 'createdAt'
  };

  export type MockAttemptScalarFieldEnum = (typeof MockAttemptScalarFieldEnum)[keyof typeof MockAttemptScalarFieldEnum]


  export const TopicMasteryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    topic: 'topic',
    correct: 'correct',
    total: 'total',
    lastSeenAt: 'lastSeenAt',
    updatedAt: 'updatedAt'
  };

  export type TopicMasteryScalarFieldEnum = (typeof TopicMasteryScalarFieldEnum)[keyof typeof TopicMasteryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'LearningStyle'
   */
  export type EnumLearningStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LearningStyle'>
    


  /**
   * Reference to a field of type 'LearningStyle[]'
   */
  export type ListEnumLearningStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LearningStyle[]'>
    


  /**
   * Reference to a field of type 'DifficultyLevel'
   */
  export type EnumDifficultyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DifficultyLevel'>
    


  /**
   * Reference to a field of type 'DifficultyLevel[]'
   */
  export type ListEnumDifficultyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DifficultyLevel[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'AchievementCategory'
   */
  export type EnumAchievementCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementCategory'>
    


  /**
   * Reference to a field of type 'AchievementCategory[]'
   */
  export type ListEnumAchievementCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementCategory[]'>
    
  /**
   * Deep Input Types
   */


  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    userId?: StringFilter<"Post"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    userId?: StringFilter<"Post"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    userId?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    title?: StringWithAggregatesFilter<"Post"> | string
    content?: StringWithAggregatesFilter<"Post"> | string
    userId?: StringWithAggregatesFilter<"Post"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    isOnboarded?: BoolFilter<"User"> | boolean
    gradeLevel?: IntNullableFilter<"User"> | number | null
    age?: IntNullableFilter<"User"> | number | null
    school?: StringNullableFilter<"User"> | string | null
    subjects?: StringNullableListFilter<"User">
    learningGoals?: StringNullableListFilter<"User">
    learningStyle?: EnumLearningStyleFilter<"User"> | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFilter<"User"> | $Enums.DifficultyLevel
    sessionDuration?: IntNullableFilter<"User"> | number | null
    interests?: StringNullableListFilter<"User">
    pastEngagement?: FloatNullableFilter<"User"> | number | null
    isInterestedInSATPrep?: BoolNullableFilter<"User"> | boolean | null
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    posts?: PostListRelationFilter
    activities?: StudentActivityListRelationFilter
    streak?: XOR<LearningStreakNullableScalarRelationFilter, LearningStreakWhereInput> | null
    achievements?: AchievementListRelationFilter
    chatSessions?: ChatSessionListRelationFilter
    satStudyPlans?: SATStudyPlanListRelationFilter
    satPracticeSessions?: SATPracticeSessionListRelationFilter
    satDiagnosticResults?: SATDiagnosticResultListRelationFilter
    generatedQuestions?: QuestionListRelationFilter
    mockExams?: MockExamListRelationFilter
    mockAttempts?: MockAttemptListRelationFilter
    topicMasteries?: TopicMasteryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    isOnboarded?: SortOrder
    gradeLevel?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    school?: SortOrderInput | SortOrder
    subjects?: SortOrder
    learningGoals?: SortOrder
    learningStyle?: SortOrder
    difficultyLevel?: SortOrder
    sessionDuration?: SortOrderInput | SortOrder
    interests?: SortOrder
    pastEngagement?: SortOrderInput | SortOrder
    isInterestedInSATPrep?: SortOrderInput | SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    activities?: StudentActivityOrderByRelationAggregateInput
    streak?: LearningStreakOrderByWithRelationInput
    achievements?: AchievementOrderByRelationAggregateInput
    chatSessions?: ChatSessionOrderByRelationAggregateInput
    satStudyPlans?: SATStudyPlanOrderByRelationAggregateInput
    satPracticeSessions?: SATPracticeSessionOrderByRelationAggregateInput
    satDiagnosticResults?: SATDiagnosticResultOrderByRelationAggregateInput
    generatedQuestions?: QuestionOrderByRelationAggregateInput
    mockExams?: MockExamOrderByRelationAggregateInput
    mockAttempts?: MockAttemptOrderByRelationAggregateInput
    topicMasteries?: TopicMasteryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    banned?: BoolNullableFilter<"User"> | boolean | null
    banReason?: StringNullableFilter<"User"> | string | null
    banExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    isOnboarded?: BoolFilter<"User"> | boolean
    gradeLevel?: IntNullableFilter<"User"> | number | null
    age?: IntNullableFilter<"User"> | number | null
    school?: StringNullableFilter<"User"> | string | null
    subjects?: StringNullableListFilter<"User">
    learningGoals?: StringNullableListFilter<"User">
    learningStyle?: EnumLearningStyleFilter<"User"> | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFilter<"User"> | $Enums.DifficultyLevel
    sessionDuration?: IntNullableFilter<"User"> | number | null
    interests?: StringNullableListFilter<"User">
    pastEngagement?: FloatNullableFilter<"User"> | number | null
    isInterestedInSATPrep?: BoolNullableFilter<"User"> | boolean | null
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    posts?: PostListRelationFilter
    activities?: StudentActivityListRelationFilter
    streak?: XOR<LearningStreakNullableScalarRelationFilter, LearningStreakWhereInput> | null
    achievements?: AchievementListRelationFilter
    chatSessions?: ChatSessionListRelationFilter
    satStudyPlans?: SATStudyPlanListRelationFilter
    satPracticeSessions?: SATPracticeSessionListRelationFilter
    satDiagnosticResults?: SATDiagnosticResultListRelationFilter
    generatedQuestions?: QuestionListRelationFilter
    mockExams?: MockExamListRelationFilter
    mockAttempts?: MockAttemptListRelationFilter
    topicMasteries?: TopicMasteryListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    banned?: SortOrderInput | SortOrder
    banReason?: SortOrderInput | SortOrder
    banExpires?: SortOrderInput | SortOrder
    isOnboarded?: SortOrder
    gradeLevel?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    school?: SortOrderInput | SortOrder
    subjects?: SortOrder
    learningGoals?: SortOrder
    learningStyle?: SortOrder
    difficultyLevel?: SortOrder
    sessionDuration?: SortOrderInput | SortOrder
    interests?: SortOrder
    pastEngagement?: SortOrderInput | SortOrder
    isInterestedInSATPrep?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    banned?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    banReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    banExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isOnboarded?: BoolWithAggregatesFilter<"User"> | boolean
    gradeLevel?: IntNullableWithAggregatesFilter<"User"> | number | null
    age?: IntNullableWithAggregatesFilter<"User"> | number | null
    school?: StringNullableWithAggregatesFilter<"User"> | string | null
    subjects?: StringNullableListFilter<"User">
    learningGoals?: StringNullableListFilter<"User">
    learningStyle?: EnumLearningStyleWithAggregatesFilter<"User"> | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelWithAggregatesFilter<"User"> | $Enums.DifficultyLevel
    sessionDuration?: IntNullableWithAggregatesFilter<"User"> | number | null
    interests?: StringNullableListFilter<"User">
    pastEngagement?: FloatNullableWithAggregatesFilter<"User"> | number | null
    isInterestedInSATPrep?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    impersonatedBy?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    impersonatedBy?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    impersonatedBy?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    userId?: StringFilter<"Account"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    userId?: StringFilter<"Account"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    userId?: StringWithAggregatesFilter<"Account"> | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type StudentActivityWhereInput = {
    AND?: StudentActivityWhereInput | StudentActivityWhereInput[]
    OR?: StudentActivityWhereInput[]
    NOT?: StudentActivityWhereInput | StudentActivityWhereInput[]
    id?: StringFilter<"StudentActivity"> | string
    createdAt?: DateTimeFilter<"StudentActivity"> | Date | string
    userId?: StringFilter<"StudentActivity"> | string
    type?: EnumActivityTypeFilter<"StudentActivity"> | $Enums.ActivityType
    subject?: StringNullableFilter<"StudentActivity"> | string | null
    topic?: StringNullableFilter<"StudentActivity"> | string | null
    duration?: IntNullableFilter<"StudentActivity"> | number | null
    score?: FloatNullableFilter<"StudentActivity"> | number | null
    metadata?: JsonNullableFilter<"StudentActivity">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StudentActivityOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type StudentActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentActivityWhereInput | StudentActivityWhereInput[]
    OR?: StudentActivityWhereInput[]
    NOT?: StudentActivityWhereInput | StudentActivityWhereInput[]
    createdAt?: DateTimeFilter<"StudentActivity"> | Date | string
    userId?: StringFilter<"StudentActivity"> | string
    type?: EnumActivityTypeFilter<"StudentActivity"> | $Enums.ActivityType
    subject?: StringNullableFilter<"StudentActivity"> | string | null
    topic?: StringNullableFilter<"StudentActivity"> | string | null
    duration?: IntNullableFilter<"StudentActivity"> | number | null
    score?: FloatNullableFilter<"StudentActivity"> | number | null
    metadata?: JsonNullableFilter<"StudentActivity">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type StudentActivityOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: StudentActivityCountOrderByAggregateInput
    _avg?: StudentActivityAvgOrderByAggregateInput
    _max?: StudentActivityMaxOrderByAggregateInput
    _min?: StudentActivityMinOrderByAggregateInput
    _sum?: StudentActivitySumOrderByAggregateInput
  }

  export type StudentActivityScalarWhereWithAggregatesInput = {
    AND?: StudentActivityScalarWhereWithAggregatesInput | StudentActivityScalarWhereWithAggregatesInput[]
    OR?: StudentActivityScalarWhereWithAggregatesInput[]
    NOT?: StudentActivityScalarWhereWithAggregatesInput | StudentActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentActivity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentActivity"> | Date | string
    userId?: StringWithAggregatesFilter<"StudentActivity"> | string
    type?: EnumActivityTypeWithAggregatesFilter<"StudentActivity"> | $Enums.ActivityType
    subject?: StringNullableWithAggregatesFilter<"StudentActivity"> | string | null
    topic?: StringNullableWithAggregatesFilter<"StudentActivity"> | string | null
    duration?: IntNullableWithAggregatesFilter<"StudentActivity"> | number | null
    score?: FloatNullableWithAggregatesFilter<"StudentActivity"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"StudentActivity">
  }

  export type LearningStreakWhereInput = {
    AND?: LearningStreakWhereInput | LearningStreakWhereInput[]
    OR?: LearningStreakWhereInput[]
    NOT?: LearningStreakWhereInput | LearningStreakWhereInput[]
    id?: StringFilter<"LearningStreak"> | string
    userId?: StringFilter<"LearningStreak"> | string
    currentStreak?: IntFilter<"LearningStreak"> | number
    longestStreak?: IntFilter<"LearningStreak"> | number
    lastActivity?: DateTimeFilter<"LearningStreak"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LearningStreakOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActivity?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LearningStreakWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: LearningStreakWhereInput | LearningStreakWhereInput[]
    OR?: LearningStreakWhereInput[]
    NOT?: LearningStreakWhereInput | LearningStreakWhereInput[]
    currentStreak?: IntFilter<"LearningStreak"> | number
    longestStreak?: IntFilter<"LearningStreak"> | number
    lastActivity?: DateTimeFilter<"LearningStreak"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type LearningStreakOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActivity?: SortOrder
    _count?: LearningStreakCountOrderByAggregateInput
    _avg?: LearningStreakAvgOrderByAggregateInput
    _max?: LearningStreakMaxOrderByAggregateInput
    _min?: LearningStreakMinOrderByAggregateInput
    _sum?: LearningStreakSumOrderByAggregateInput
  }

  export type LearningStreakScalarWhereWithAggregatesInput = {
    AND?: LearningStreakScalarWhereWithAggregatesInput | LearningStreakScalarWhereWithAggregatesInput[]
    OR?: LearningStreakScalarWhereWithAggregatesInput[]
    NOT?: LearningStreakScalarWhereWithAggregatesInput | LearningStreakScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningStreak"> | string
    userId?: StringWithAggregatesFilter<"LearningStreak"> | string
    currentStreak?: IntWithAggregatesFilter<"LearningStreak"> | number
    longestStreak?: IntWithAggregatesFilter<"LearningStreak"> | number
    lastActivity?: DateTimeWithAggregatesFilter<"LearningStreak"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    userId?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    icon?: StringFilter<"Achievement"> | string
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    progress?: FloatFilter<"Achievement"> | number
    completed?: BoolFilter<"Achievement"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    progress?: SortOrder
    completed?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    userId?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    icon?: StringFilter<"Achievement"> | string
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    progress?: FloatFilter<"Achievement"> | number
    completed?: BoolFilter<"Achievement"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    progress?: SortOrder
    completed?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
    userId?: StringWithAggregatesFilter<"Achievement"> | string
    title?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    icon?: StringWithAggregatesFilter<"Achievement"> | string
    category?: EnumAchievementCategoryWithAggregatesFilter<"Achievement"> | $Enums.AchievementCategory
    progress?: FloatWithAggregatesFilter<"Achievement"> | number
    completed?: BoolWithAggregatesFilter<"Achievement"> | boolean
  }

  export type ChatSessionWhereInput = {
    AND?: ChatSessionWhereInput | ChatSessionWhereInput[]
    OR?: ChatSessionWhereInput[]
    NOT?: ChatSessionWhereInput | ChatSessionWhereInput[]
    id?: StringFilter<"ChatSession"> | string
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
    userId?: StringFilter<"ChatSession"> | string
    title?: StringNullableFilter<"ChatSession"> | string | null
    topic?: StringNullableFilter<"ChatSession"> | string | null
    isActive?: BoolFilter<"ChatSession"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: ChatMessageListRelationFilter
  }

  export type ChatSessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    isActive?: SortOrder
    user?: UserOrderByWithRelationInput
    messages?: ChatMessageOrderByRelationAggregateInput
  }

  export type ChatSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatSessionWhereInput | ChatSessionWhereInput[]
    OR?: ChatSessionWhereInput[]
    NOT?: ChatSessionWhereInput | ChatSessionWhereInput[]
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
    userId?: StringFilter<"ChatSession"> | string
    title?: StringNullableFilter<"ChatSession"> | string | null
    topic?: StringNullableFilter<"ChatSession"> | string | null
    isActive?: BoolFilter<"ChatSession"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: ChatMessageListRelationFilter
  }, "id">

  export type ChatSessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    title?: SortOrderInput | SortOrder
    topic?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: ChatSessionCountOrderByAggregateInput
    _max?: ChatSessionMaxOrderByAggregateInput
    _min?: ChatSessionMinOrderByAggregateInput
  }

  export type ChatSessionScalarWhereWithAggregatesInput = {
    AND?: ChatSessionScalarWhereWithAggregatesInput | ChatSessionScalarWhereWithAggregatesInput[]
    OR?: ChatSessionScalarWhereWithAggregatesInput[]
    NOT?: ChatSessionScalarWhereWithAggregatesInput | ChatSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatSession"> | Date | string
    userId?: StringWithAggregatesFilter<"ChatSession"> | string
    title?: StringNullableWithAggregatesFilter<"ChatSession"> | string | null
    topic?: StringNullableWithAggregatesFilter<"ChatSession"> | string | null
    isActive?: BoolWithAggregatesFilter<"ChatSession"> | boolean
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    sessionId?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    type?: StringFilter<"ChatMessage"> | string
    metadata?: JsonNullableFilter<"ChatMessage">
    imageUrl?: StringNullableFilter<"ChatMessage"> | string | null
    links?: JsonNullableFilter<"ChatMessage">
    keywords?: StringNullableListFilter<"ChatMessage">
    session?: XOR<ChatSessionScalarRelationFilter, ChatSessionWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    links?: SortOrderInput | SortOrder
    keywords?: SortOrder
    session?: ChatSessionOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    sessionId?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    type?: StringFilter<"ChatMessage"> | string
    metadata?: JsonNullableFilter<"ChatMessage">
    imageUrl?: StringNullableFilter<"ChatMessage"> | string | null
    links?: JsonNullableFilter<"ChatMessage">
    keywords?: StringNullableListFilter<"ChatMessage">
    session?: XOR<ChatSessionScalarRelationFilter, ChatSessionWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    metadata?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    links?: SortOrderInput | SortOrder
    keywords?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
    sessionId?: StringWithAggregatesFilter<"ChatMessage"> | string
    content?: StringWithAggregatesFilter<"ChatMessage"> | string
    type?: StringWithAggregatesFilter<"ChatMessage"> | string
    metadata?: JsonNullableWithAggregatesFilter<"ChatMessage">
    imageUrl?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    links?: JsonNullableWithAggregatesFilter<"ChatMessage">
    keywords?: StringNullableListFilter<"ChatMessage">
  }

  export type SATStudyPlanWhereInput = {
    AND?: SATStudyPlanWhereInput | SATStudyPlanWhereInput[]
    OR?: SATStudyPlanWhereInput[]
    NOT?: SATStudyPlanWhereInput | SATStudyPlanWhereInput[]
    id?: StringFilter<"SATStudyPlan"> | string
    userId?: StringFilter<"SATStudyPlan"> | string
    timeline?: StringFilter<"SATStudyPlan"> | string
    focusAreas?: JsonFilter<"SATStudyPlan">
    weeklySchedule?: JsonFilter<"SATStudyPlan">
    resourceRecommendations?: JsonFilter<"SATStudyPlan">
    aiGeneratedPlan?: JsonNullableFilter<"SATStudyPlan">
    completedWeeks?: IntNullableListFilter<"SATStudyPlan">
    completedTasks?: JsonFilter<"SATStudyPlan">
    createdAt?: DateTimeFilter<"SATStudyPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SATStudyPlan"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SATStudyPlanOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    timeline?: SortOrder
    focusAreas?: SortOrder
    weeklySchedule?: SortOrder
    resourceRecommendations?: SortOrder
    aiGeneratedPlan?: SortOrderInput | SortOrder
    completedWeeks?: SortOrder
    completedTasks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SATStudyPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SATStudyPlanWhereInput | SATStudyPlanWhereInput[]
    OR?: SATStudyPlanWhereInput[]
    NOT?: SATStudyPlanWhereInput | SATStudyPlanWhereInput[]
    userId?: StringFilter<"SATStudyPlan"> | string
    timeline?: StringFilter<"SATStudyPlan"> | string
    focusAreas?: JsonFilter<"SATStudyPlan">
    weeklySchedule?: JsonFilter<"SATStudyPlan">
    resourceRecommendations?: JsonFilter<"SATStudyPlan">
    aiGeneratedPlan?: JsonNullableFilter<"SATStudyPlan">
    completedWeeks?: IntNullableListFilter<"SATStudyPlan">
    completedTasks?: JsonFilter<"SATStudyPlan">
    createdAt?: DateTimeFilter<"SATStudyPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SATStudyPlan"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SATStudyPlanOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    timeline?: SortOrder
    focusAreas?: SortOrder
    weeklySchedule?: SortOrder
    resourceRecommendations?: SortOrder
    aiGeneratedPlan?: SortOrderInput | SortOrder
    completedWeeks?: SortOrder
    completedTasks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SATStudyPlanCountOrderByAggregateInput
    _avg?: SATStudyPlanAvgOrderByAggregateInput
    _max?: SATStudyPlanMaxOrderByAggregateInput
    _min?: SATStudyPlanMinOrderByAggregateInput
    _sum?: SATStudyPlanSumOrderByAggregateInput
  }

  export type SATStudyPlanScalarWhereWithAggregatesInput = {
    AND?: SATStudyPlanScalarWhereWithAggregatesInput | SATStudyPlanScalarWhereWithAggregatesInput[]
    OR?: SATStudyPlanScalarWhereWithAggregatesInput[]
    NOT?: SATStudyPlanScalarWhereWithAggregatesInput | SATStudyPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SATStudyPlan"> | string
    userId?: StringWithAggregatesFilter<"SATStudyPlan"> | string
    timeline?: StringWithAggregatesFilter<"SATStudyPlan"> | string
    focusAreas?: JsonWithAggregatesFilter<"SATStudyPlan">
    weeklySchedule?: JsonWithAggregatesFilter<"SATStudyPlan">
    resourceRecommendations?: JsonWithAggregatesFilter<"SATStudyPlan">
    aiGeneratedPlan?: JsonNullableWithAggregatesFilter<"SATStudyPlan">
    completedWeeks?: IntNullableListFilter<"SATStudyPlan">
    completedTasks?: JsonWithAggregatesFilter<"SATStudyPlan">
    createdAt?: DateTimeWithAggregatesFilter<"SATStudyPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SATStudyPlan"> | Date | string
  }

  export type SATPracticeSessionWhereInput = {
    AND?: SATPracticeSessionWhereInput | SATPracticeSessionWhereInput[]
    OR?: SATPracticeSessionWhereInput[]
    NOT?: SATPracticeSessionWhereInput | SATPracticeSessionWhereInput[]
    id?: StringFilter<"SATPracticeSession"> | string
    userId?: StringFilter<"SATPracticeSession"> | string
    section?: StringFilter<"SATPracticeSession"> | string
    score?: IntNullableFilter<"SATPracticeSession"> | number | null
    maxScore?: IntNullableFilter<"SATPracticeSession"> | number | null
    answers?: JsonNullableFilter<"SATPracticeSession">
    timeSpent?: IntNullableFilter<"SATPracticeSession"> | number | null
    completedAt?: DateTimeNullableFilter<"SATPracticeSession"> | Date | string | null
    createdAt?: DateTimeFilter<"SATPracticeSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SATPracticeSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    section?: SortOrder
    score?: SortOrderInput | SortOrder
    maxScore?: SortOrderInput | SortOrder
    answers?: SortOrderInput | SortOrder
    timeSpent?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SATPracticeSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SATPracticeSessionWhereInput | SATPracticeSessionWhereInput[]
    OR?: SATPracticeSessionWhereInput[]
    NOT?: SATPracticeSessionWhereInput | SATPracticeSessionWhereInput[]
    userId?: StringFilter<"SATPracticeSession"> | string
    section?: StringFilter<"SATPracticeSession"> | string
    score?: IntNullableFilter<"SATPracticeSession"> | number | null
    maxScore?: IntNullableFilter<"SATPracticeSession"> | number | null
    answers?: JsonNullableFilter<"SATPracticeSession">
    timeSpent?: IntNullableFilter<"SATPracticeSession"> | number | null
    completedAt?: DateTimeNullableFilter<"SATPracticeSession"> | Date | string | null
    createdAt?: DateTimeFilter<"SATPracticeSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SATPracticeSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    section?: SortOrder
    score?: SortOrderInput | SortOrder
    maxScore?: SortOrderInput | SortOrder
    answers?: SortOrderInput | SortOrder
    timeSpent?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SATPracticeSessionCountOrderByAggregateInput
    _avg?: SATPracticeSessionAvgOrderByAggregateInput
    _max?: SATPracticeSessionMaxOrderByAggregateInput
    _min?: SATPracticeSessionMinOrderByAggregateInput
    _sum?: SATPracticeSessionSumOrderByAggregateInput
  }

  export type SATPracticeSessionScalarWhereWithAggregatesInput = {
    AND?: SATPracticeSessionScalarWhereWithAggregatesInput | SATPracticeSessionScalarWhereWithAggregatesInput[]
    OR?: SATPracticeSessionScalarWhereWithAggregatesInput[]
    NOT?: SATPracticeSessionScalarWhereWithAggregatesInput | SATPracticeSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SATPracticeSession"> | string
    userId?: StringWithAggregatesFilter<"SATPracticeSession"> | string
    section?: StringWithAggregatesFilter<"SATPracticeSession"> | string
    score?: IntNullableWithAggregatesFilter<"SATPracticeSession"> | number | null
    maxScore?: IntNullableWithAggregatesFilter<"SATPracticeSession"> | number | null
    answers?: JsonNullableWithAggregatesFilter<"SATPracticeSession">
    timeSpent?: IntNullableWithAggregatesFilter<"SATPracticeSession"> | number | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"SATPracticeSession"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SATPracticeSession"> | Date | string
  }

  export type SATDiagnosticResultWhereInput = {
    AND?: SATDiagnosticResultWhereInput | SATDiagnosticResultWhereInput[]
    OR?: SATDiagnosticResultWhereInput[]
    NOT?: SATDiagnosticResultWhereInput | SATDiagnosticResultWhereInput[]
    id?: StringFilter<"SATDiagnosticResult"> | string
    userId?: StringFilter<"SATDiagnosticResult"> | string
    mathScore?: IntNullableFilter<"SATDiagnosticResult"> | number | null
    readingScore?: IntNullableFilter<"SATDiagnosticResult"> | number | null
    writingScore?: IntNullableFilter<"SATDiagnosticResult"> | number | null
    totalScore?: IntNullableFilter<"SATDiagnosticResult"> | number | null
    strengths?: JsonNullableFilter<"SATDiagnosticResult">
    weaknesses?: JsonNullableFilter<"SATDiagnosticResult">
    createdAt?: DateTimeFilter<"SATDiagnosticResult"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SATDiagnosticResultOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mathScore?: SortOrderInput | SortOrder
    readingScore?: SortOrderInput | SortOrder
    writingScore?: SortOrderInput | SortOrder
    totalScore?: SortOrderInput | SortOrder
    strengths?: SortOrderInput | SortOrder
    weaknesses?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SATDiagnosticResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SATDiagnosticResultWhereInput | SATDiagnosticResultWhereInput[]
    OR?: SATDiagnosticResultWhereInput[]
    NOT?: SATDiagnosticResultWhereInput | SATDiagnosticResultWhereInput[]
    userId?: StringFilter<"SATDiagnosticResult"> | string
    mathScore?: IntNullableFilter<"SATDiagnosticResult"> | number | null
    readingScore?: IntNullableFilter<"SATDiagnosticResult"> | number | null
    writingScore?: IntNullableFilter<"SATDiagnosticResult"> | number | null
    totalScore?: IntNullableFilter<"SATDiagnosticResult"> | number | null
    strengths?: JsonNullableFilter<"SATDiagnosticResult">
    weaknesses?: JsonNullableFilter<"SATDiagnosticResult">
    createdAt?: DateTimeFilter<"SATDiagnosticResult"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SATDiagnosticResultOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mathScore?: SortOrderInput | SortOrder
    readingScore?: SortOrderInput | SortOrder
    writingScore?: SortOrderInput | SortOrder
    totalScore?: SortOrderInput | SortOrder
    strengths?: SortOrderInput | SortOrder
    weaknesses?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SATDiagnosticResultCountOrderByAggregateInput
    _avg?: SATDiagnosticResultAvgOrderByAggregateInput
    _max?: SATDiagnosticResultMaxOrderByAggregateInput
    _min?: SATDiagnosticResultMinOrderByAggregateInput
    _sum?: SATDiagnosticResultSumOrderByAggregateInput
  }

  export type SATDiagnosticResultScalarWhereWithAggregatesInput = {
    AND?: SATDiagnosticResultScalarWhereWithAggregatesInput | SATDiagnosticResultScalarWhereWithAggregatesInput[]
    OR?: SATDiagnosticResultScalarWhereWithAggregatesInput[]
    NOT?: SATDiagnosticResultScalarWhereWithAggregatesInput | SATDiagnosticResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SATDiagnosticResult"> | string
    userId?: StringWithAggregatesFilter<"SATDiagnosticResult"> | string
    mathScore?: IntNullableWithAggregatesFilter<"SATDiagnosticResult"> | number | null
    readingScore?: IntNullableWithAggregatesFilter<"SATDiagnosticResult"> | number | null
    writingScore?: IntNullableWithAggregatesFilter<"SATDiagnosticResult"> | number | null
    totalScore?: IntNullableWithAggregatesFilter<"SATDiagnosticResult"> | number | null
    strengths?: JsonNullableWithAggregatesFilter<"SATDiagnosticResult">
    weaknesses?: JsonNullableWithAggregatesFilter<"SATDiagnosticResult">
    createdAt?: DateTimeWithAggregatesFilter<"SATDiagnosticResult"> | Date | string
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: StringFilter<"Question"> | string
    topic?: StringFilter<"Question"> | string
    subject?: StringFilter<"Question"> | string
    difficulty?: StringFilter<"Question"> | string
    question?: StringFilter<"Question"> | string
    choices?: JsonFilter<"Question">
    answer?: StringFilter<"Question"> | string
    explanation?: StringFilter<"Question"> | string
    source?: StringFilter<"Question"> | string
    status?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    userGeneratedBy?: StringNullableFilter<"Question"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    difficulty?: SortOrder
    question?: SortOrder
    choices?: SortOrder
    answer?: SortOrder
    explanation?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userGeneratedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    topic?: StringFilter<"Question"> | string
    subject?: StringFilter<"Question"> | string
    difficulty?: StringFilter<"Question"> | string
    question?: StringFilter<"Question"> | string
    choices?: JsonFilter<"Question">
    answer?: StringFilter<"Question"> | string
    explanation?: StringFilter<"Question"> | string
    source?: StringFilter<"Question"> | string
    status?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    userGeneratedBy?: StringNullableFilter<"Question"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    difficulty?: SortOrder
    question?: SortOrder
    choices?: SortOrder
    answer?: SortOrder
    explanation?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userGeneratedBy?: SortOrderInput | SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Question"> | string
    topic?: StringWithAggregatesFilter<"Question"> | string
    subject?: StringWithAggregatesFilter<"Question"> | string
    difficulty?: StringWithAggregatesFilter<"Question"> | string
    question?: StringWithAggregatesFilter<"Question"> | string
    choices?: JsonWithAggregatesFilter<"Question">
    answer?: StringWithAggregatesFilter<"Question"> | string
    explanation?: StringWithAggregatesFilter<"Question"> | string
    source?: StringWithAggregatesFilter<"Question"> | string
    status?: StringWithAggregatesFilter<"Question"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    userGeneratedBy?: StringNullableWithAggregatesFilter<"Question"> | string | null
  }

  export type MockExamWhereInput = {
    AND?: MockExamWhereInput | MockExamWhereInput[]
    OR?: MockExamWhereInput[]
    NOT?: MockExamWhereInput | MockExamWhereInput[]
    id?: StringFilter<"MockExam"> | string
    userId?: StringFilter<"MockExam"> | string
    goal?: StringFilter<"MockExam"> | string
    grade?: IntFilter<"MockExam"> | number
    sections?: JsonFilter<"MockExam">
    totalTime?: IntFilter<"MockExam"> | number
    createdAt?: DateTimeFilter<"MockExam"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    attempts?: MockAttemptListRelationFilter
  }

  export type MockExamOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    goal?: SortOrder
    grade?: SortOrder
    sections?: SortOrder
    totalTime?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    attempts?: MockAttemptOrderByRelationAggregateInput
  }

  export type MockExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MockExamWhereInput | MockExamWhereInput[]
    OR?: MockExamWhereInput[]
    NOT?: MockExamWhereInput | MockExamWhereInput[]
    userId?: StringFilter<"MockExam"> | string
    goal?: StringFilter<"MockExam"> | string
    grade?: IntFilter<"MockExam"> | number
    sections?: JsonFilter<"MockExam">
    totalTime?: IntFilter<"MockExam"> | number
    createdAt?: DateTimeFilter<"MockExam"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    attempts?: MockAttemptListRelationFilter
  }, "id">

  export type MockExamOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    goal?: SortOrder
    grade?: SortOrder
    sections?: SortOrder
    totalTime?: SortOrder
    createdAt?: SortOrder
    _count?: MockExamCountOrderByAggregateInput
    _avg?: MockExamAvgOrderByAggregateInput
    _max?: MockExamMaxOrderByAggregateInput
    _min?: MockExamMinOrderByAggregateInput
    _sum?: MockExamSumOrderByAggregateInput
  }

  export type MockExamScalarWhereWithAggregatesInput = {
    AND?: MockExamScalarWhereWithAggregatesInput | MockExamScalarWhereWithAggregatesInput[]
    OR?: MockExamScalarWhereWithAggregatesInput[]
    NOT?: MockExamScalarWhereWithAggregatesInput | MockExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MockExam"> | string
    userId?: StringWithAggregatesFilter<"MockExam"> | string
    goal?: StringWithAggregatesFilter<"MockExam"> | string
    grade?: IntWithAggregatesFilter<"MockExam"> | number
    sections?: JsonWithAggregatesFilter<"MockExam">
    totalTime?: IntWithAggregatesFilter<"MockExam"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MockExam"> | Date | string
  }

  export type MockAttemptWhereInput = {
    AND?: MockAttemptWhereInput | MockAttemptWhereInput[]
    OR?: MockAttemptWhereInput[]
    NOT?: MockAttemptWhereInput | MockAttemptWhereInput[]
    id?: StringFilter<"MockAttempt"> | string
    userId?: StringFilter<"MockAttempt"> | string
    mockExamId?: StringFilter<"MockAttempt"> | string
    answers?: JsonFilter<"MockAttempt">
    scored?: JsonFilter<"MockAttempt">
    summary?: JsonFilter<"MockAttempt">
    startedAt?: DateTimeFilter<"MockAttempt"> | Date | string
    finishedAt?: DateTimeFilter<"MockAttempt"> | Date | string
    createdAt?: DateTimeFilter<"MockAttempt"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    mockExam?: XOR<MockExamScalarRelationFilter, MockExamWhereInput>
  }

  export type MockAttemptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mockExamId?: SortOrder
    answers?: SortOrder
    scored?: SortOrder
    summary?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    mockExam?: MockExamOrderByWithRelationInput
  }

  export type MockAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MockAttemptWhereInput | MockAttemptWhereInput[]
    OR?: MockAttemptWhereInput[]
    NOT?: MockAttemptWhereInput | MockAttemptWhereInput[]
    userId?: StringFilter<"MockAttempt"> | string
    mockExamId?: StringFilter<"MockAttempt"> | string
    answers?: JsonFilter<"MockAttempt">
    scored?: JsonFilter<"MockAttempt">
    summary?: JsonFilter<"MockAttempt">
    startedAt?: DateTimeFilter<"MockAttempt"> | Date | string
    finishedAt?: DateTimeFilter<"MockAttempt"> | Date | string
    createdAt?: DateTimeFilter<"MockAttempt"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    mockExam?: XOR<MockExamScalarRelationFilter, MockExamWhereInput>
  }, "id">

  export type MockAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mockExamId?: SortOrder
    answers?: SortOrder
    scored?: SortOrder
    summary?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdAt?: SortOrder
    _count?: MockAttemptCountOrderByAggregateInput
    _max?: MockAttemptMaxOrderByAggregateInput
    _min?: MockAttemptMinOrderByAggregateInput
  }

  export type MockAttemptScalarWhereWithAggregatesInput = {
    AND?: MockAttemptScalarWhereWithAggregatesInput | MockAttemptScalarWhereWithAggregatesInput[]
    OR?: MockAttemptScalarWhereWithAggregatesInput[]
    NOT?: MockAttemptScalarWhereWithAggregatesInput | MockAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MockAttempt"> | string
    userId?: StringWithAggregatesFilter<"MockAttempt"> | string
    mockExamId?: StringWithAggregatesFilter<"MockAttempt"> | string
    answers?: JsonWithAggregatesFilter<"MockAttempt">
    scored?: JsonWithAggregatesFilter<"MockAttempt">
    summary?: JsonWithAggregatesFilter<"MockAttempt">
    startedAt?: DateTimeWithAggregatesFilter<"MockAttempt"> | Date | string
    finishedAt?: DateTimeWithAggregatesFilter<"MockAttempt"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MockAttempt"> | Date | string
  }

  export type TopicMasteryWhereInput = {
    AND?: TopicMasteryWhereInput | TopicMasteryWhereInput[]
    OR?: TopicMasteryWhereInput[]
    NOT?: TopicMasteryWhereInput | TopicMasteryWhereInput[]
    id?: StringFilter<"TopicMastery"> | string
    userId?: StringFilter<"TopicMastery"> | string
    topic?: StringFilter<"TopicMastery"> | string
    correct?: IntFilter<"TopicMastery"> | number
    total?: IntFilter<"TopicMastery"> | number
    lastSeenAt?: DateTimeFilter<"TopicMastery"> | Date | string
    updatedAt?: DateTimeFilter<"TopicMastery"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TopicMasteryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    correct?: SortOrder
    total?: SortOrder
    lastSeenAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TopicMasteryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_topic?: TopicMasteryUserIdTopicCompoundUniqueInput
    AND?: TopicMasteryWhereInput | TopicMasteryWhereInput[]
    OR?: TopicMasteryWhereInput[]
    NOT?: TopicMasteryWhereInput | TopicMasteryWhereInput[]
    userId?: StringFilter<"TopicMastery"> | string
    topic?: StringFilter<"TopicMastery"> | string
    correct?: IntFilter<"TopicMastery"> | number
    total?: IntFilter<"TopicMastery"> | number
    lastSeenAt?: DateTimeFilter<"TopicMastery"> | Date | string
    updatedAt?: DateTimeFilter<"TopicMastery"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_topic">

  export type TopicMasteryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    correct?: SortOrder
    total?: SortOrder
    lastSeenAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TopicMasteryCountOrderByAggregateInput
    _avg?: TopicMasteryAvgOrderByAggregateInput
    _max?: TopicMasteryMaxOrderByAggregateInput
    _min?: TopicMasteryMinOrderByAggregateInput
    _sum?: TopicMasterySumOrderByAggregateInput
  }

  export type TopicMasteryScalarWhereWithAggregatesInput = {
    AND?: TopicMasteryScalarWhereWithAggregatesInput | TopicMasteryScalarWhereWithAggregatesInput[]
    OR?: TopicMasteryScalarWhereWithAggregatesInput[]
    NOT?: TopicMasteryScalarWhereWithAggregatesInput | TopicMasteryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TopicMastery"> | string
    userId?: StringWithAggregatesFilter<"TopicMastery"> | string
    topic?: StringWithAggregatesFilter<"TopicMastery"> | string
    correct?: IntWithAggregatesFilter<"TopicMastery"> | number
    total?: IntWithAggregatesFilter<"TopicMastery"> | number
    lastSeenAt?: DateTimeWithAggregatesFilter<"TopicMastery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TopicMastery"> | Date | string
  }

  export type PostCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    content: string
    user: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    content: string
    userId: string
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    content: string
    userId: string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SessionCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    userId: string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    userId: string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    identifier: string
    value: string
    expiresAt: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    identifier: string
    value: string
    expiresAt: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    identifier: string
    value: string
    expiresAt: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentActivityCreateInput = {
    id?: string
    createdAt?: Date | string
    type: $Enums.ActivityType
    subject?: string | null
    topic?: string | null
    duration?: number | null
    score?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutActivitiesInput
  }

  export type StudentActivityUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    type: $Enums.ActivityType
    subject?: string | null
    topic?: string | null
    duration?: number | null
    score?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StudentActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type StudentActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StudentActivityCreateManyInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    type: $Enums.ActivityType
    subject?: string | null
    topic?: string | null
    duration?: number | null
    score?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StudentActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StudentActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LearningStreakCreateInput = {
    id?: string
    currentStreak?: number
    longestStreak?: number
    lastActivity?: Date | string
    user: UserCreateNestedOneWithoutStreakInput
  }

  export type LearningStreakUncheckedCreateInput = {
    id?: string
    userId: string
    currentStreak?: number
    longestStreak?: number
    lastActivity?: Date | string
  }

  export type LearningStreakUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStreakNestedInput
  }

  export type LearningStreakUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningStreakCreateManyInput = {
    id?: string
    userId: string
    currentStreak?: number
    longestStreak?: number
    lastActivity?: Date | string
  }

  export type LearningStreakUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningStreakUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    createdAt?: Date | string
    title: string
    description: string
    icon: string
    category: $Enums.AchievementCategory
    progress?: number
    completed?: boolean
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    title: string
    description: string
    icon: string
    category: $Enums.AchievementCategory
    progress?: number
    completed?: boolean
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AchievementCreateManyInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    title: string
    description: string
    icon: string
    category: $Enums.AchievementCategory
    progress?: number
    completed?: boolean
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChatSessionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title?: string | null
    topic?: string | null
    isActive?: boolean
    user: UserCreateNestedOneWithoutChatSessionsInput
    messages?: ChatMessageCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    title?: string | null
    topic?: string | null
    isActive?: boolean
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutChatSessionsNestedInput
    messages?: ChatMessageUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    messages?: ChatMessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    title?: string | null
    topic?: string | null
    isActive?: boolean
  }

  export type ChatSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChatSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChatMessageCreateInput = {
    id?: string
    createdAt?: Date | string
    content: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    keywords?: ChatMessageCreatekeywordsInput | string[]
    session: ChatSessionCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    sessionId: string
    content: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    keywords?: ChatMessageCreatekeywordsInput | string[]
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    keywords?: ChatMessageUpdatekeywordsInput | string[]
    session?: ChatSessionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    keywords?: ChatMessageUpdatekeywordsInput | string[]
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    createdAt?: Date | string
    sessionId: string
    content: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    keywords?: ChatMessageCreatekeywordsInput | string[]
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    keywords?: ChatMessageUpdatekeywordsInput | string[]
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    keywords?: ChatMessageUpdatekeywordsInput | string[]
  }

  export type SATStudyPlanCreateInput = {
    id?: string
    timeline: string
    focusAreas: JsonNullValueInput | InputJsonValue
    weeklySchedule: JsonNullValueInput | InputJsonValue
    resourceRecommendations: JsonNullValueInput | InputJsonValue
    aiGeneratedPlan?: NullableJsonNullValueInput | InputJsonValue
    completedWeeks?: SATStudyPlanCreatecompletedWeeksInput | number[]
    completedTasks?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSatStudyPlansInput
  }

  export type SATStudyPlanUncheckedCreateInput = {
    id?: string
    userId: string
    timeline: string
    focusAreas: JsonNullValueInput | InputJsonValue
    weeklySchedule: JsonNullValueInput | InputJsonValue
    resourceRecommendations: JsonNullValueInput | InputJsonValue
    aiGeneratedPlan?: NullableJsonNullValueInput | InputJsonValue
    completedWeeks?: SATStudyPlanCreatecompletedWeeksInput | number[]
    completedTasks?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SATStudyPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    focusAreas?: JsonNullValueInput | InputJsonValue
    weeklySchedule?: JsonNullValueInput | InputJsonValue
    resourceRecommendations?: JsonNullValueInput | InputJsonValue
    aiGeneratedPlan?: NullableJsonNullValueInput | InputJsonValue
    completedWeeks?: SATStudyPlanUpdatecompletedWeeksInput | number[]
    completedTasks?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSatStudyPlansNestedInput
  }

  export type SATStudyPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    focusAreas?: JsonNullValueInput | InputJsonValue
    weeklySchedule?: JsonNullValueInput | InputJsonValue
    resourceRecommendations?: JsonNullValueInput | InputJsonValue
    aiGeneratedPlan?: NullableJsonNullValueInput | InputJsonValue
    completedWeeks?: SATStudyPlanUpdatecompletedWeeksInput | number[]
    completedTasks?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATStudyPlanCreateManyInput = {
    id?: string
    userId: string
    timeline: string
    focusAreas: JsonNullValueInput | InputJsonValue
    weeklySchedule: JsonNullValueInput | InputJsonValue
    resourceRecommendations: JsonNullValueInput | InputJsonValue
    aiGeneratedPlan?: NullableJsonNullValueInput | InputJsonValue
    completedWeeks?: SATStudyPlanCreatecompletedWeeksInput | number[]
    completedTasks?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SATStudyPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    focusAreas?: JsonNullValueInput | InputJsonValue
    weeklySchedule?: JsonNullValueInput | InputJsonValue
    resourceRecommendations?: JsonNullValueInput | InputJsonValue
    aiGeneratedPlan?: NullableJsonNullValueInput | InputJsonValue
    completedWeeks?: SATStudyPlanUpdatecompletedWeeksInput | number[]
    completedTasks?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATStudyPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    focusAreas?: JsonNullValueInput | InputJsonValue
    weeklySchedule?: JsonNullValueInput | InputJsonValue
    resourceRecommendations?: JsonNullValueInput | InputJsonValue
    aiGeneratedPlan?: NullableJsonNullValueInput | InputJsonValue
    completedWeeks?: SATStudyPlanUpdatecompletedWeeksInput | number[]
    completedTasks?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATPracticeSessionCreateInput = {
    id?: string
    section: string
    score?: number | null
    maxScore?: number | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    timeSpent?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSatPracticeSessionsInput
  }

  export type SATPracticeSessionUncheckedCreateInput = {
    id?: string
    userId: string
    section: string
    score?: number | null
    maxScore?: number | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    timeSpent?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SATPracticeSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSatPracticeSessionsNestedInput
  }

  export type SATPracticeSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATPracticeSessionCreateManyInput = {
    id?: string
    userId: string
    section: string
    score?: number | null
    maxScore?: number | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    timeSpent?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SATPracticeSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATPracticeSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATDiagnosticResultCreateInput = {
    id?: string
    mathScore?: number | null
    readingScore?: number | null
    writingScore?: number | null
    totalScore?: number | null
    strengths?: NullableJsonNullValueInput | InputJsonValue
    weaknesses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSatDiagnosticResultsInput
  }

  export type SATDiagnosticResultUncheckedCreateInput = {
    id?: string
    userId: string
    mathScore?: number | null
    readingScore?: number | null
    writingScore?: number | null
    totalScore?: number | null
    strengths?: NullableJsonNullValueInput | InputJsonValue
    weaknesses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SATDiagnosticResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mathScore?: NullableIntFieldUpdateOperationsInput | number | null
    readingScore?: NullableIntFieldUpdateOperationsInput | number | null
    writingScore?: NullableIntFieldUpdateOperationsInput | number | null
    totalScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableJsonNullValueInput | InputJsonValue
    weaknesses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSatDiagnosticResultsNestedInput
  }

  export type SATDiagnosticResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mathScore?: NullableIntFieldUpdateOperationsInput | number | null
    readingScore?: NullableIntFieldUpdateOperationsInput | number | null
    writingScore?: NullableIntFieldUpdateOperationsInput | number | null
    totalScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableJsonNullValueInput | InputJsonValue
    weaknesses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATDiagnosticResultCreateManyInput = {
    id?: string
    userId: string
    mathScore?: number | null
    readingScore?: number | null
    writingScore?: number | null
    totalScore?: number | null
    strengths?: NullableJsonNullValueInput | InputJsonValue
    weaknesses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SATDiagnosticResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mathScore?: NullableIntFieldUpdateOperationsInput | number | null
    readingScore?: NullableIntFieldUpdateOperationsInput | number | null
    writingScore?: NullableIntFieldUpdateOperationsInput | number | null
    totalScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableJsonNullValueInput | InputJsonValue
    weaknesses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATDiagnosticResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mathScore?: NullableIntFieldUpdateOperationsInput | number | null
    readingScore?: NullableIntFieldUpdateOperationsInput | number | null
    writingScore?: NullableIntFieldUpdateOperationsInput | number | null
    totalScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableJsonNullValueInput | InputJsonValue
    weaknesses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateInput = {
    id?: string
    topic: string
    subject: string
    difficulty: string
    question: string
    choices: JsonNullValueInput | InputJsonValue
    answer: string
    explanation: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedQuestionsInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    topic: string
    subject: string
    difficulty: string
    question: string
    choices: JsonNullValueInput | InputJsonValue
    answer: string
    explanation: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userGeneratedBy?: string | null
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    choices?: JsonNullValueInput | InputJsonValue
    answer?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedQuestionsNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    choices?: JsonNullValueInput | InputJsonValue
    answer?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userGeneratedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuestionCreateManyInput = {
    id?: string
    topic: string
    subject: string
    difficulty: string
    question: string
    choices: JsonNullValueInput | InputJsonValue
    answer: string
    explanation: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userGeneratedBy?: string | null
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    choices?: JsonNullValueInput | InputJsonValue
    answer?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    choices?: JsonNullValueInput | InputJsonValue
    answer?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userGeneratedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MockExamCreateInput = {
    id?: string
    goal: string
    grade: number
    sections: JsonNullValueInput | InputJsonValue
    totalTime: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMockExamsInput
    attempts?: MockAttemptCreateNestedManyWithoutMockExamInput
  }

  export type MockExamUncheckedCreateInput = {
    id?: string
    userId: string
    goal: string
    grade: number
    sections: JsonNullValueInput | InputJsonValue
    totalTime: number
    createdAt?: Date | string
    attempts?: MockAttemptUncheckedCreateNestedManyWithoutMockExamInput
  }

  export type MockExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    totalTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMockExamsNestedInput
    attempts?: MockAttemptUpdateManyWithoutMockExamNestedInput
  }

  export type MockExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    totalTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: MockAttemptUncheckedUpdateManyWithoutMockExamNestedInput
  }

  export type MockExamCreateManyInput = {
    id?: string
    userId: string
    goal: string
    grade: number
    sections: JsonNullValueInput | InputJsonValue
    totalTime: number
    createdAt?: Date | string
  }

  export type MockExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    totalTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    totalTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockAttemptCreateInput = {
    id?: string
    answers: JsonNullValueInput | InputJsonValue
    scored: JsonNullValueInput | InputJsonValue
    summary: JsonNullValueInput | InputJsonValue
    startedAt: Date | string
    finishedAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMockAttemptsInput
    mockExam: MockExamCreateNestedOneWithoutAttemptsInput
  }

  export type MockAttemptUncheckedCreateInput = {
    id?: string
    userId: string
    mockExamId: string
    answers: JsonNullValueInput | InputJsonValue
    scored: JsonNullValueInput | InputJsonValue
    summary: JsonNullValueInput | InputJsonValue
    startedAt: Date | string
    finishedAt: Date | string
    createdAt?: Date | string
  }

  export type MockAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    scored?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMockAttemptsNestedInput
    mockExam?: MockExamUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type MockAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mockExamId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    scored?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockAttemptCreateManyInput = {
    id?: string
    userId: string
    mockExamId: string
    answers: JsonNullValueInput | InputJsonValue
    scored: JsonNullValueInput | InputJsonValue
    summary: JsonNullValueInput | InputJsonValue
    startedAt: Date | string
    finishedAt: Date | string
    createdAt?: Date | string
  }

  export type MockAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    scored?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mockExamId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    scored?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicMasteryCreateInput = {
    id?: string
    topic: string
    correct?: number
    total?: number
    lastSeenAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTopicMasteriesInput
  }

  export type TopicMasteryUncheckedCreateInput = {
    id?: string
    userId: string
    topic: string
    correct?: number
    total?: number
    lastSeenAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicMasteryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    correct?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTopicMasteriesNestedInput
  }

  export type TopicMasteryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    correct?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicMasteryCreateManyInput = {
    id?: string
    userId: string
    topic: string
    correct?: number
    total?: number
    lastSeenAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicMasteryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    correct?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicMasteryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    correct?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    userId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    userId?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    content?: SortOrder
    userId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumLearningStyleFilter<$PrismaModel = never> = {
    equals?: $Enums.LearningStyle | EnumLearningStyleFieldRefInput<$PrismaModel>
    in?: $Enums.LearningStyle[] | ListEnumLearningStyleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LearningStyle[] | ListEnumLearningStyleFieldRefInput<$PrismaModel>
    not?: NestedEnumLearningStyleFilter<$PrismaModel> | $Enums.LearningStyle
  }

  export type EnumDifficultyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelFilter<$PrismaModel> | $Enums.DifficultyLevel
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type StudentActivityListRelationFilter = {
    every?: StudentActivityWhereInput
    some?: StudentActivityWhereInput
    none?: StudentActivityWhereInput
  }

  export type LearningStreakNullableScalarRelationFilter = {
    is?: LearningStreakWhereInput | null
    isNot?: LearningStreakWhereInput | null
  }

  export type AchievementListRelationFilter = {
    every?: AchievementWhereInput
    some?: AchievementWhereInput
    none?: AchievementWhereInput
  }

  export type ChatSessionListRelationFilter = {
    every?: ChatSessionWhereInput
    some?: ChatSessionWhereInput
    none?: ChatSessionWhereInput
  }

  export type SATStudyPlanListRelationFilter = {
    every?: SATStudyPlanWhereInput
    some?: SATStudyPlanWhereInput
    none?: SATStudyPlanWhereInput
  }

  export type SATPracticeSessionListRelationFilter = {
    every?: SATPracticeSessionWhereInput
    some?: SATPracticeSessionWhereInput
    none?: SATPracticeSessionWhereInput
  }

  export type SATDiagnosticResultListRelationFilter = {
    every?: SATDiagnosticResultWhereInput
    some?: SATDiagnosticResultWhereInput
    none?: SATDiagnosticResultWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type MockExamListRelationFilter = {
    every?: MockExamWhereInput
    some?: MockExamWhereInput
    none?: MockExamWhereInput
  }

  export type MockAttemptListRelationFilter = {
    every?: MockAttemptWhereInput
    some?: MockAttemptWhereInput
    none?: MockAttemptWhereInput
  }

  export type TopicMasteryListRelationFilter = {
    every?: TopicMasteryWhereInput
    some?: TopicMasteryWhereInput
    none?: TopicMasteryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SATStudyPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SATPracticeSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SATDiagnosticResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MockExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MockAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TopicMasteryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    isOnboarded?: SortOrder
    gradeLevel?: SortOrder
    age?: SortOrder
    school?: SortOrder
    subjects?: SortOrder
    learningGoals?: SortOrder
    learningStyle?: SortOrder
    difficultyLevel?: SortOrder
    sessionDuration?: SortOrder
    interests?: SortOrder
    pastEngagement?: SortOrder
    isInterestedInSATPrep?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    gradeLevel?: SortOrder
    age?: SortOrder
    sessionDuration?: SortOrder
    pastEngagement?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    isOnboarded?: SortOrder
    gradeLevel?: SortOrder
    age?: SortOrder
    school?: SortOrder
    learningStyle?: SortOrder
    difficultyLevel?: SortOrder
    sessionDuration?: SortOrder
    pastEngagement?: SortOrder
    isInterestedInSATPrep?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    role?: SortOrder
    banned?: SortOrder
    banReason?: SortOrder
    banExpires?: SortOrder
    isOnboarded?: SortOrder
    gradeLevel?: SortOrder
    age?: SortOrder
    school?: SortOrder
    learningStyle?: SortOrder
    difficultyLevel?: SortOrder
    sessionDuration?: SortOrder
    pastEngagement?: SortOrder
    isInterestedInSATPrep?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    gradeLevel?: SortOrder
    age?: SortOrder
    sessionDuration?: SortOrder
    pastEngagement?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumLearningStyleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LearningStyle | EnumLearningStyleFieldRefInput<$PrismaModel>
    in?: $Enums.LearningStyle[] | ListEnumLearningStyleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LearningStyle[] | ListEnumLearningStyleFieldRefInput<$PrismaModel>
    not?: NestedEnumLearningStyleWithAggregatesFilter<$PrismaModel> | $Enums.LearningStyle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLearningStyleFilter<$PrismaModel>
    _max?: NestedEnumLearningStyleFilter<$PrismaModel>
  }

  export type EnumDifficultyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelWithAggregatesFilter<$PrismaModel> | $Enums.DifficultyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyLevelFilter<$PrismaModel>
    _max?: NestedEnumDifficultyLevelFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    impersonatedBy?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    impersonatedBy?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    impersonatedBy?: SortOrder
    userId?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    userId?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    userId?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    userId?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StudentActivityCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    topic?: SortOrder
    duration?: SortOrder
    score?: SortOrder
    metadata?: SortOrder
  }

  export type StudentActivityAvgOrderByAggregateInput = {
    duration?: SortOrder
    score?: SortOrder
  }

  export type StudentActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    topic?: SortOrder
    duration?: SortOrder
    score?: SortOrder
  }

  export type StudentActivityMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    topic?: SortOrder
    duration?: SortOrder
    score?: SortOrder
  }

  export type StudentActivitySumOrderByAggregateInput = {
    duration?: SortOrder
    score?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type LearningStreakCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActivity?: SortOrder
  }

  export type LearningStreakAvgOrderByAggregateInput = {
    currentStreak?: SortOrder
    longestStreak?: SortOrder
  }

  export type LearningStreakMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActivity?: SortOrder
  }

  export type LearningStreakMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActivity?: SortOrder
  }

  export type LearningStreakSumOrderByAggregateInput = {
    currentStreak?: SortOrder
    longestStreak?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    progress?: SortOrder
    completed?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    progress?: SortOrder
    completed?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    progress?: SortOrder
    completed?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatSessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    topic?: SortOrder
    isActive?: SortOrder
  }

  export type ChatSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    topic?: SortOrder
    isActive?: SortOrder
  }

  export type ChatSessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    topic?: SortOrder
    isActive?: SortOrder
  }

  export type ChatSessionScalarRelationFilter = {
    is?: ChatSessionWhereInput
    isNot?: ChatSessionWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    imageUrl?: SortOrder
    links?: SortOrder
    keywords?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    imageUrl?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    sessionId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    imageUrl?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type SATStudyPlanCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timeline?: SortOrder
    focusAreas?: SortOrder
    weeklySchedule?: SortOrder
    resourceRecommendations?: SortOrder
    aiGeneratedPlan?: SortOrder
    completedWeeks?: SortOrder
    completedTasks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SATStudyPlanAvgOrderByAggregateInput = {
    completedWeeks?: SortOrder
  }

  export type SATStudyPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timeline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SATStudyPlanMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    timeline?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SATStudyPlanSumOrderByAggregateInput = {
    completedWeeks?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type SATPracticeSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    section?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    answers?: SortOrder
    timeSpent?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SATPracticeSessionAvgOrderByAggregateInput = {
    score?: SortOrder
    maxScore?: SortOrder
    timeSpent?: SortOrder
  }

  export type SATPracticeSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    section?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    timeSpent?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SATPracticeSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    section?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    timeSpent?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SATPracticeSessionSumOrderByAggregateInput = {
    score?: SortOrder
    maxScore?: SortOrder
    timeSpent?: SortOrder
  }

  export type SATDiagnosticResultCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mathScore?: SortOrder
    readingScore?: SortOrder
    writingScore?: SortOrder
    totalScore?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    createdAt?: SortOrder
  }

  export type SATDiagnosticResultAvgOrderByAggregateInput = {
    mathScore?: SortOrder
    readingScore?: SortOrder
    writingScore?: SortOrder
    totalScore?: SortOrder
  }

  export type SATDiagnosticResultMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mathScore?: SortOrder
    readingScore?: SortOrder
    writingScore?: SortOrder
    totalScore?: SortOrder
    createdAt?: SortOrder
  }

  export type SATDiagnosticResultMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mathScore?: SortOrder
    readingScore?: SortOrder
    writingScore?: SortOrder
    totalScore?: SortOrder
    createdAt?: SortOrder
  }

  export type SATDiagnosticResultSumOrderByAggregateInput = {
    mathScore?: SortOrder
    readingScore?: SortOrder
    writingScore?: SortOrder
    totalScore?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    difficulty?: SortOrder
    question?: SortOrder
    choices?: SortOrder
    answer?: SortOrder
    explanation?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userGeneratedBy?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    difficulty?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    explanation?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userGeneratedBy?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    subject?: SortOrder
    difficulty?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    explanation?: SortOrder
    source?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userGeneratedBy?: SortOrder
  }

  export type MockExamCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goal?: SortOrder
    grade?: SortOrder
    sections?: SortOrder
    totalTime?: SortOrder
    createdAt?: SortOrder
  }

  export type MockExamAvgOrderByAggregateInput = {
    grade?: SortOrder
    totalTime?: SortOrder
  }

  export type MockExamMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goal?: SortOrder
    grade?: SortOrder
    totalTime?: SortOrder
    createdAt?: SortOrder
  }

  export type MockExamMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goal?: SortOrder
    grade?: SortOrder
    totalTime?: SortOrder
    createdAt?: SortOrder
  }

  export type MockExamSumOrderByAggregateInput = {
    grade?: SortOrder
    totalTime?: SortOrder
  }

  export type MockExamScalarRelationFilter = {
    is?: MockExamWhereInput
    isNot?: MockExamWhereInput
  }

  export type MockAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mockExamId?: SortOrder
    answers?: SortOrder
    scored?: SortOrder
    summary?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MockAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mockExamId?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MockAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mockExamId?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TopicMasteryUserIdTopicCompoundUniqueInput = {
    userId: string
    topic: string
  }

  export type TopicMasteryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    correct?: SortOrder
    total?: SortOrder
    lastSeenAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicMasteryAvgOrderByAggregateInput = {
    correct?: SortOrder
    total?: SortOrder
  }

  export type TopicMasteryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    correct?: SortOrder
    total?: SortOrder
    lastSeenAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicMasteryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    topic?: SortOrder
    correct?: SortOrder
    total?: SortOrder
    lastSeenAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicMasterySumOrderByAggregateInput = {
    correct?: SortOrder
    total?: SortOrder
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserCreatesubjectsInput = {
    set: string[]
  }

  export type UserCreatelearningGoalsInput = {
    set: string[]
  }

  export type UserCreateinterestsInput = {
    set: string[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type StudentActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<StudentActivityCreateWithoutUserInput, StudentActivityUncheckedCreateWithoutUserInput> | StudentActivityCreateWithoutUserInput[] | StudentActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentActivityCreateOrConnectWithoutUserInput | StudentActivityCreateOrConnectWithoutUserInput[]
    createMany?: StudentActivityCreateManyUserInputEnvelope
    connect?: StudentActivityWhereUniqueInput | StudentActivityWhereUniqueInput[]
  }

  export type LearningStreakCreateNestedOneWithoutUserInput = {
    create?: XOR<LearningStreakCreateWithoutUserInput, LearningStreakUncheckedCreateWithoutUserInput>
    connectOrCreate?: LearningStreakCreateOrConnectWithoutUserInput
    connect?: LearningStreakWhereUniqueInput
  }

  export type AchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type ChatSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
  }

  export type SATStudyPlanCreateNestedManyWithoutUserInput = {
    create?: XOR<SATStudyPlanCreateWithoutUserInput, SATStudyPlanUncheckedCreateWithoutUserInput> | SATStudyPlanCreateWithoutUserInput[] | SATStudyPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SATStudyPlanCreateOrConnectWithoutUserInput | SATStudyPlanCreateOrConnectWithoutUserInput[]
    createMany?: SATStudyPlanCreateManyUserInputEnvelope
    connect?: SATStudyPlanWhereUniqueInput | SATStudyPlanWhereUniqueInput[]
  }

  export type SATPracticeSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SATPracticeSessionCreateWithoutUserInput, SATPracticeSessionUncheckedCreateWithoutUserInput> | SATPracticeSessionCreateWithoutUserInput[] | SATPracticeSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SATPracticeSessionCreateOrConnectWithoutUserInput | SATPracticeSessionCreateOrConnectWithoutUserInput[]
    createMany?: SATPracticeSessionCreateManyUserInputEnvelope
    connect?: SATPracticeSessionWhereUniqueInput | SATPracticeSessionWhereUniqueInput[]
  }

  export type SATDiagnosticResultCreateNestedManyWithoutUserInput = {
    create?: XOR<SATDiagnosticResultCreateWithoutUserInput, SATDiagnosticResultUncheckedCreateWithoutUserInput> | SATDiagnosticResultCreateWithoutUserInput[] | SATDiagnosticResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SATDiagnosticResultCreateOrConnectWithoutUserInput | SATDiagnosticResultCreateOrConnectWithoutUserInput[]
    createMany?: SATDiagnosticResultCreateManyUserInputEnvelope
    connect?: SATDiagnosticResultWhereUniqueInput | SATDiagnosticResultWhereUniqueInput[]
  }

  export type QuestionCreateNestedManyWithoutUserInput = {
    create?: XOR<QuestionCreateWithoutUserInput, QuestionUncheckedCreateWithoutUserInput> | QuestionCreateWithoutUserInput[] | QuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutUserInput | QuestionCreateOrConnectWithoutUserInput[]
    createMany?: QuestionCreateManyUserInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type MockExamCreateNestedManyWithoutUserInput = {
    create?: XOR<MockExamCreateWithoutUserInput, MockExamUncheckedCreateWithoutUserInput> | MockExamCreateWithoutUserInput[] | MockExamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MockExamCreateOrConnectWithoutUserInput | MockExamCreateOrConnectWithoutUserInput[]
    createMany?: MockExamCreateManyUserInputEnvelope
    connect?: MockExamWhereUniqueInput | MockExamWhereUniqueInput[]
  }

  export type MockAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<MockAttemptCreateWithoutUserInput, MockAttemptUncheckedCreateWithoutUserInput> | MockAttemptCreateWithoutUserInput[] | MockAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MockAttemptCreateOrConnectWithoutUserInput | MockAttemptCreateOrConnectWithoutUserInput[]
    createMany?: MockAttemptCreateManyUserInputEnvelope
    connect?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
  }

  export type TopicMasteryCreateNestedManyWithoutUserInput = {
    create?: XOR<TopicMasteryCreateWithoutUserInput, TopicMasteryUncheckedCreateWithoutUserInput> | TopicMasteryCreateWithoutUserInput[] | TopicMasteryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopicMasteryCreateOrConnectWithoutUserInput | TopicMasteryCreateOrConnectWithoutUserInput[]
    createMany?: TopicMasteryCreateManyUserInputEnvelope
    connect?: TopicMasteryWhereUniqueInput | TopicMasteryWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type StudentActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StudentActivityCreateWithoutUserInput, StudentActivityUncheckedCreateWithoutUserInput> | StudentActivityCreateWithoutUserInput[] | StudentActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentActivityCreateOrConnectWithoutUserInput | StudentActivityCreateOrConnectWithoutUserInput[]
    createMany?: StudentActivityCreateManyUserInputEnvelope
    connect?: StudentActivityWhereUniqueInput | StudentActivityWhereUniqueInput[]
  }

  export type LearningStreakUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<LearningStreakCreateWithoutUserInput, LearningStreakUncheckedCreateWithoutUserInput>
    connectOrCreate?: LearningStreakCreateOrConnectWithoutUserInput
    connect?: LearningStreakWhereUniqueInput
  }

  export type AchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type ChatSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
  }

  export type SATStudyPlanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SATStudyPlanCreateWithoutUserInput, SATStudyPlanUncheckedCreateWithoutUserInput> | SATStudyPlanCreateWithoutUserInput[] | SATStudyPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SATStudyPlanCreateOrConnectWithoutUserInput | SATStudyPlanCreateOrConnectWithoutUserInput[]
    createMany?: SATStudyPlanCreateManyUserInputEnvelope
    connect?: SATStudyPlanWhereUniqueInput | SATStudyPlanWhereUniqueInput[]
  }

  export type SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SATPracticeSessionCreateWithoutUserInput, SATPracticeSessionUncheckedCreateWithoutUserInput> | SATPracticeSessionCreateWithoutUserInput[] | SATPracticeSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SATPracticeSessionCreateOrConnectWithoutUserInput | SATPracticeSessionCreateOrConnectWithoutUserInput[]
    createMany?: SATPracticeSessionCreateManyUserInputEnvelope
    connect?: SATPracticeSessionWhereUniqueInput | SATPracticeSessionWhereUniqueInput[]
  }

  export type SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SATDiagnosticResultCreateWithoutUserInput, SATDiagnosticResultUncheckedCreateWithoutUserInput> | SATDiagnosticResultCreateWithoutUserInput[] | SATDiagnosticResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SATDiagnosticResultCreateOrConnectWithoutUserInput | SATDiagnosticResultCreateOrConnectWithoutUserInput[]
    createMany?: SATDiagnosticResultCreateManyUserInputEnvelope
    connect?: SATDiagnosticResultWhereUniqueInput | SATDiagnosticResultWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuestionCreateWithoutUserInput, QuestionUncheckedCreateWithoutUserInput> | QuestionCreateWithoutUserInput[] | QuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutUserInput | QuestionCreateOrConnectWithoutUserInput[]
    createMany?: QuestionCreateManyUserInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type MockExamUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MockExamCreateWithoutUserInput, MockExamUncheckedCreateWithoutUserInput> | MockExamCreateWithoutUserInput[] | MockExamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MockExamCreateOrConnectWithoutUserInput | MockExamCreateOrConnectWithoutUserInput[]
    createMany?: MockExamCreateManyUserInputEnvelope
    connect?: MockExamWhereUniqueInput | MockExamWhereUniqueInput[]
  }

  export type MockAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MockAttemptCreateWithoutUserInput, MockAttemptUncheckedCreateWithoutUserInput> | MockAttemptCreateWithoutUserInput[] | MockAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MockAttemptCreateOrConnectWithoutUserInput | MockAttemptCreateOrConnectWithoutUserInput[]
    createMany?: MockAttemptCreateManyUserInputEnvelope
    connect?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
  }

  export type TopicMasteryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TopicMasteryCreateWithoutUserInput, TopicMasteryUncheckedCreateWithoutUserInput> | TopicMasteryCreateWithoutUserInput[] | TopicMasteryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopicMasteryCreateOrConnectWithoutUserInput | TopicMasteryCreateOrConnectWithoutUserInput[]
    createMany?: TopicMasteryCreateManyUserInputEnvelope
    connect?: TopicMasteryWhereUniqueInput | TopicMasteryWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdatesubjectsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdatelearningGoalsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumLearningStyleFieldUpdateOperationsInput = {
    set?: $Enums.LearningStyle
  }

  export type EnumDifficultyLevelFieldUpdateOperationsInput = {
    set?: $Enums.DifficultyLevel
  }

  export type UserUpdateinterestsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type PostUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type StudentActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudentActivityCreateWithoutUserInput, StudentActivityUncheckedCreateWithoutUserInput> | StudentActivityCreateWithoutUserInput[] | StudentActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentActivityCreateOrConnectWithoutUserInput | StudentActivityCreateOrConnectWithoutUserInput[]
    upsert?: StudentActivityUpsertWithWhereUniqueWithoutUserInput | StudentActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudentActivityCreateManyUserInputEnvelope
    set?: StudentActivityWhereUniqueInput | StudentActivityWhereUniqueInput[]
    disconnect?: StudentActivityWhereUniqueInput | StudentActivityWhereUniqueInput[]
    delete?: StudentActivityWhereUniqueInput | StudentActivityWhereUniqueInput[]
    connect?: StudentActivityWhereUniqueInput | StudentActivityWhereUniqueInput[]
    update?: StudentActivityUpdateWithWhereUniqueWithoutUserInput | StudentActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudentActivityUpdateManyWithWhereWithoutUserInput | StudentActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudentActivityScalarWhereInput | StudentActivityScalarWhereInput[]
  }

  export type LearningStreakUpdateOneWithoutUserNestedInput = {
    create?: XOR<LearningStreakCreateWithoutUserInput, LearningStreakUncheckedCreateWithoutUserInput>
    connectOrCreate?: LearningStreakCreateOrConnectWithoutUserInput
    upsert?: LearningStreakUpsertWithoutUserInput
    disconnect?: LearningStreakWhereInput | boolean
    delete?: LearningStreakWhereInput | boolean
    connect?: LearningStreakWhereUniqueInput
    update?: XOR<XOR<LearningStreakUpdateToOneWithWhereWithoutUserInput, LearningStreakUpdateWithoutUserInput>, LearningStreakUncheckedUpdateWithoutUserInput>
  }

  export type AchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserInput | AchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserInput | AchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserInput | AchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type ChatSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    upsert?: ChatSessionUpsertWithWhereUniqueWithoutUserInput | ChatSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    set?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    disconnect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    delete?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    update?: ChatSessionUpdateWithWhereUniqueWithoutUserInput | ChatSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatSessionUpdateManyWithWhereWithoutUserInput | ChatSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
  }

  export type SATStudyPlanUpdateManyWithoutUserNestedInput = {
    create?: XOR<SATStudyPlanCreateWithoutUserInput, SATStudyPlanUncheckedCreateWithoutUserInput> | SATStudyPlanCreateWithoutUserInput[] | SATStudyPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SATStudyPlanCreateOrConnectWithoutUserInput | SATStudyPlanCreateOrConnectWithoutUserInput[]
    upsert?: SATStudyPlanUpsertWithWhereUniqueWithoutUserInput | SATStudyPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SATStudyPlanCreateManyUserInputEnvelope
    set?: SATStudyPlanWhereUniqueInput | SATStudyPlanWhereUniqueInput[]
    disconnect?: SATStudyPlanWhereUniqueInput | SATStudyPlanWhereUniqueInput[]
    delete?: SATStudyPlanWhereUniqueInput | SATStudyPlanWhereUniqueInput[]
    connect?: SATStudyPlanWhereUniqueInput | SATStudyPlanWhereUniqueInput[]
    update?: SATStudyPlanUpdateWithWhereUniqueWithoutUserInput | SATStudyPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SATStudyPlanUpdateManyWithWhereWithoutUserInput | SATStudyPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SATStudyPlanScalarWhereInput | SATStudyPlanScalarWhereInput[]
  }

  export type SATPracticeSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SATPracticeSessionCreateWithoutUserInput, SATPracticeSessionUncheckedCreateWithoutUserInput> | SATPracticeSessionCreateWithoutUserInput[] | SATPracticeSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SATPracticeSessionCreateOrConnectWithoutUserInput | SATPracticeSessionCreateOrConnectWithoutUserInput[]
    upsert?: SATPracticeSessionUpsertWithWhereUniqueWithoutUserInput | SATPracticeSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SATPracticeSessionCreateManyUserInputEnvelope
    set?: SATPracticeSessionWhereUniqueInput | SATPracticeSessionWhereUniqueInput[]
    disconnect?: SATPracticeSessionWhereUniqueInput | SATPracticeSessionWhereUniqueInput[]
    delete?: SATPracticeSessionWhereUniqueInput | SATPracticeSessionWhereUniqueInput[]
    connect?: SATPracticeSessionWhereUniqueInput | SATPracticeSessionWhereUniqueInput[]
    update?: SATPracticeSessionUpdateWithWhereUniqueWithoutUserInput | SATPracticeSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SATPracticeSessionUpdateManyWithWhereWithoutUserInput | SATPracticeSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SATPracticeSessionScalarWhereInput | SATPracticeSessionScalarWhereInput[]
  }

  export type SATDiagnosticResultUpdateManyWithoutUserNestedInput = {
    create?: XOR<SATDiagnosticResultCreateWithoutUserInput, SATDiagnosticResultUncheckedCreateWithoutUserInput> | SATDiagnosticResultCreateWithoutUserInput[] | SATDiagnosticResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SATDiagnosticResultCreateOrConnectWithoutUserInput | SATDiagnosticResultCreateOrConnectWithoutUserInput[]
    upsert?: SATDiagnosticResultUpsertWithWhereUniqueWithoutUserInput | SATDiagnosticResultUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SATDiagnosticResultCreateManyUserInputEnvelope
    set?: SATDiagnosticResultWhereUniqueInput | SATDiagnosticResultWhereUniqueInput[]
    disconnect?: SATDiagnosticResultWhereUniqueInput | SATDiagnosticResultWhereUniqueInput[]
    delete?: SATDiagnosticResultWhereUniqueInput | SATDiagnosticResultWhereUniqueInput[]
    connect?: SATDiagnosticResultWhereUniqueInput | SATDiagnosticResultWhereUniqueInput[]
    update?: SATDiagnosticResultUpdateWithWhereUniqueWithoutUserInput | SATDiagnosticResultUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SATDiagnosticResultUpdateManyWithWhereWithoutUserInput | SATDiagnosticResultUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SATDiagnosticResultScalarWhereInput | SATDiagnosticResultScalarWhereInput[]
  }

  export type QuestionUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuestionCreateWithoutUserInput, QuestionUncheckedCreateWithoutUserInput> | QuestionCreateWithoutUserInput[] | QuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutUserInput | QuestionCreateOrConnectWithoutUserInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutUserInput | QuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuestionCreateManyUserInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutUserInput | QuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutUserInput | QuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type MockExamUpdateManyWithoutUserNestedInput = {
    create?: XOR<MockExamCreateWithoutUserInput, MockExamUncheckedCreateWithoutUserInput> | MockExamCreateWithoutUserInput[] | MockExamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MockExamCreateOrConnectWithoutUserInput | MockExamCreateOrConnectWithoutUserInput[]
    upsert?: MockExamUpsertWithWhereUniqueWithoutUserInput | MockExamUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MockExamCreateManyUserInputEnvelope
    set?: MockExamWhereUniqueInput | MockExamWhereUniqueInput[]
    disconnect?: MockExamWhereUniqueInput | MockExamWhereUniqueInput[]
    delete?: MockExamWhereUniqueInput | MockExamWhereUniqueInput[]
    connect?: MockExamWhereUniqueInput | MockExamWhereUniqueInput[]
    update?: MockExamUpdateWithWhereUniqueWithoutUserInput | MockExamUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MockExamUpdateManyWithWhereWithoutUserInput | MockExamUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MockExamScalarWhereInput | MockExamScalarWhereInput[]
  }

  export type MockAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<MockAttemptCreateWithoutUserInput, MockAttemptUncheckedCreateWithoutUserInput> | MockAttemptCreateWithoutUserInput[] | MockAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MockAttemptCreateOrConnectWithoutUserInput | MockAttemptCreateOrConnectWithoutUserInput[]
    upsert?: MockAttemptUpsertWithWhereUniqueWithoutUserInput | MockAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MockAttemptCreateManyUserInputEnvelope
    set?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    disconnect?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    delete?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    connect?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    update?: MockAttemptUpdateWithWhereUniqueWithoutUserInput | MockAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MockAttemptUpdateManyWithWhereWithoutUserInput | MockAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MockAttemptScalarWhereInput | MockAttemptScalarWhereInput[]
  }

  export type TopicMasteryUpdateManyWithoutUserNestedInput = {
    create?: XOR<TopicMasteryCreateWithoutUserInput, TopicMasteryUncheckedCreateWithoutUserInput> | TopicMasteryCreateWithoutUserInput[] | TopicMasteryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopicMasteryCreateOrConnectWithoutUserInput | TopicMasteryCreateOrConnectWithoutUserInput[]
    upsert?: TopicMasteryUpsertWithWhereUniqueWithoutUserInput | TopicMasteryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TopicMasteryCreateManyUserInputEnvelope
    set?: TopicMasteryWhereUniqueInput | TopicMasteryWhereUniqueInput[]
    disconnect?: TopicMasteryWhereUniqueInput | TopicMasteryWhereUniqueInput[]
    delete?: TopicMasteryWhereUniqueInput | TopicMasteryWhereUniqueInput[]
    connect?: TopicMasteryWhereUniqueInput | TopicMasteryWhereUniqueInput[]
    update?: TopicMasteryUpdateWithWhereUniqueWithoutUserInput | TopicMasteryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TopicMasteryUpdateManyWithWhereWithoutUserInput | TopicMasteryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TopicMasteryScalarWhereInput | TopicMasteryScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type StudentActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudentActivityCreateWithoutUserInput, StudentActivityUncheckedCreateWithoutUserInput> | StudentActivityCreateWithoutUserInput[] | StudentActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentActivityCreateOrConnectWithoutUserInput | StudentActivityCreateOrConnectWithoutUserInput[]
    upsert?: StudentActivityUpsertWithWhereUniqueWithoutUserInput | StudentActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudentActivityCreateManyUserInputEnvelope
    set?: StudentActivityWhereUniqueInput | StudentActivityWhereUniqueInput[]
    disconnect?: StudentActivityWhereUniqueInput | StudentActivityWhereUniqueInput[]
    delete?: StudentActivityWhereUniqueInput | StudentActivityWhereUniqueInput[]
    connect?: StudentActivityWhereUniqueInput | StudentActivityWhereUniqueInput[]
    update?: StudentActivityUpdateWithWhereUniqueWithoutUserInput | StudentActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudentActivityUpdateManyWithWhereWithoutUserInput | StudentActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudentActivityScalarWhereInput | StudentActivityScalarWhereInput[]
  }

  export type LearningStreakUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<LearningStreakCreateWithoutUserInput, LearningStreakUncheckedCreateWithoutUserInput>
    connectOrCreate?: LearningStreakCreateOrConnectWithoutUserInput
    upsert?: LearningStreakUpsertWithoutUserInput
    disconnect?: LearningStreakWhereInput | boolean
    delete?: LearningStreakWhereInput | boolean
    connect?: LearningStreakWhereUniqueInput
    update?: XOR<XOR<LearningStreakUpdateToOneWithWhereWithoutUserInput, LearningStreakUpdateWithoutUserInput>, LearningStreakUncheckedUpdateWithoutUserInput>
  }

  export type AchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserInput | AchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserInput | AchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserInput | AchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type ChatSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput> | ChatSessionCreateWithoutUserInput[] | ChatSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatSessionCreateOrConnectWithoutUserInput | ChatSessionCreateOrConnectWithoutUserInput[]
    upsert?: ChatSessionUpsertWithWhereUniqueWithoutUserInput | ChatSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatSessionCreateManyUserInputEnvelope
    set?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    disconnect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    delete?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    connect?: ChatSessionWhereUniqueInput | ChatSessionWhereUniqueInput[]
    update?: ChatSessionUpdateWithWhereUniqueWithoutUserInput | ChatSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatSessionUpdateManyWithWhereWithoutUserInput | ChatSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
  }

  export type SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SATStudyPlanCreateWithoutUserInput, SATStudyPlanUncheckedCreateWithoutUserInput> | SATStudyPlanCreateWithoutUserInput[] | SATStudyPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SATStudyPlanCreateOrConnectWithoutUserInput | SATStudyPlanCreateOrConnectWithoutUserInput[]
    upsert?: SATStudyPlanUpsertWithWhereUniqueWithoutUserInput | SATStudyPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SATStudyPlanCreateManyUserInputEnvelope
    set?: SATStudyPlanWhereUniqueInput | SATStudyPlanWhereUniqueInput[]
    disconnect?: SATStudyPlanWhereUniqueInput | SATStudyPlanWhereUniqueInput[]
    delete?: SATStudyPlanWhereUniqueInput | SATStudyPlanWhereUniqueInput[]
    connect?: SATStudyPlanWhereUniqueInput | SATStudyPlanWhereUniqueInput[]
    update?: SATStudyPlanUpdateWithWhereUniqueWithoutUserInput | SATStudyPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SATStudyPlanUpdateManyWithWhereWithoutUserInput | SATStudyPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SATStudyPlanScalarWhereInput | SATStudyPlanScalarWhereInput[]
  }

  export type SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SATPracticeSessionCreateWithoutUserInput, SATPracticeSessionUncheckedCreateWithoutUserInput> | SATPracticeSessionCreateWithoutUserInput[] | SATPracticeSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SATPracticeSessionCreateOrConnectWithoutUserInput | SATPracticeSessionCreateOrConnectWithoutUserInput[]
    upsert?: SATPracticeSessionUpsertWithWhereUniqueWithoutUserInput | SATPracticeSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SATPracticeSessionCreateManyUserInputEnvelope
    set?: SATPracticeSessionWhereUniqueInput | SATPracticeSessionWhereUniqueInput[]
    disconnect?: SATPracticeSessionWhereUniqueInput | SATPracticeSessionWhereUniqueInput[]
    delete?: SATPracticeSessionWhereUniqueInput | SATPracticeSessionWhereUniqueInput[]
    connect?: SATPracticeSessionWhereUniqueInput | SATPracticeSessionWhereUniqueInput[]
    update?: SATPracticeSessionUpdateWithWhereUniqueWithoutUserInput | SATPracticeSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SATPracticeSessionUpdateManyWithWhereWithoutUserInput | SATPracticeSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SATPracticeSessionScalarWhereInput | SATPracticeSessionScalarWhereInput[]
  }

  export type SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SATDiagnosticResultCreateWithoutUserInput, SATDiagnosticResultUncheckedCreateWithoutUserInput> | SATDiagnosticResultCreateWithoutUserInput[] | SATDiagnosticResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SATDiagnosticResultCreateOrConnectWithoutUserInput | SATDiagnosticResultCreateOrConnectWithoutUserInput[]
    upsert?: SATDiagnosticResultUpsertWithWhereUniqueWithoutUserInput | SATDiagnosticResultUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SATDiagnosticResultCreateManyUserInputEnvelope
    set?: SATDiagnosticResultWhereUniqueInput | SATDiagnosticResultWhereUniqueInput[]
    disconnect?: SATDiagnosticResultWhereUniqueInput | SATDiagnosticResultWhereUniqueInput[]
    delete?: SATDiagnosticResultWhereUniqueInput | SATDiagnosticResultWhereUniqueInput[]
    connect?: SATDiagnosticResultWhereUniqueInput | SATDiagnosticResultWhereUniqueInput[]
    update?: SATDiagnosticResultUpdateWithWhereUniqueWithoutUserInput | SATDiagnosticResultUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SATDiagnosticResultUpdateManyWithWhereWithoutUserInput | SATDiagnosticResultUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SATDiagnosticResultScalarWhereInput | SATDiagnosticResultScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuestionCreateWithoutUserInput, QuestionUncheckedCreateWithoutUserInput> | QuestionCreateWithoutUserInput[] | QuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutUserInput | QuestionCreateOrConnectWithoutUserInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutUserInput | QuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuestionCreateManyUserInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutUserInput | QuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutUserInput | QuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type MockExamUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MockExamCreateWithoutUserInput, MockExamUncheckedCreateWithoutUserInput> | MockExamCreateWithoutUserInput[] | MockExamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MockExamCreateOrConnectWithoutUserInput | MockExamCreateOrConnectWithoutUserInput[]
    upsert?: MockExamUpsertWithWhereUniqueWithoutUserInput | MockExamUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MockExamCreateManyUserInputEnvelope
    set?: MockExamWhereUniqueInput | MockExamWhereUniqueInput[]
    disconnect?: MockExamWhereUniqueInput | MockExamWhereUniqueInput[]
    delete?: MockExamWhereUniqueInput | MockExamWhereUniqueInput[]
    connect?: MockExamWhereUniqueInput | MockExamWhereUniqueInput[]
    update?: MockExamUpdateWithWhereUniqueWithoutUserInput | MockExamUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MockExamUpdateManyWithWhereWithoutUserInput | MockExamUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MockExamScalarWhereInput | MockExamScalarWhereInput[]
  }

  export type MockAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MockAttemptCreateWithoutUserInput, MockAttemptUncheckedCreateWithoutUserInput> | MockAttemptCreateWithoutUserInput[] | MockAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MockAttemptCreateOrConnectWithoutUserInput | MockAttemptCreateOrConnectWithoutUserInput[]
    upsert?: MockAttemptUpsertWithWhereUniqueWithoutUserInput | MockAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MockAttemptCreateManyUserInputEnvelope
    set?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    disconnect?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    delete?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    connect?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    update?: MockAttemptUpdateWithWhereUniqueWithoutUserInput | MockAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MockAttemptUpdateManyWithWhereWithoutUserInput | MockAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MockAttemptScalarWhereInput | MockAttemptScalarWhereInput[]
  }

  export type TopicMasteryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TopicMasteryCreateWithoutUserInput, TopicMasteryUncheckedCreateWithoutUserInput> | TopicMasteryCreateWithoutUserInput[] | TopicMasteryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopicMasteryCreateOrConnectWithoutUserInput | TopicMasteryCreateOrConnectWithoutUserInput[]
    upsert?: TopicMasteryUpsertWithWhereUniqueWithoutUserInput | TopicMasteryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TopicMasteryCreateManyUserInputEnvelope
    set?: TopicMasteryWhereUniqueInput | TopicMasteryWhereUniqueInput[]
    disconnect?: TopicMasteryWhereUniqueInput | TopicMasteryWhereUniqueInput[]
    delete?: TopicMasteryWhereUniqueInput | TopicMasteryWhereUniqueInput[]
    connect?: TopicMasteryWhereUniqueInput | TopicMasteryWhereUniqueInput[]
    update?: TopicMasteryUpdateWithWhereUniqueWithoutUserInput | TopicMasteryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TopicMasteryUpdateManyWithWhereWithoutUserInput | TopicMasteryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TopicMasteryScalarWhereInput | TopicMasteryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserCreateNestedOneWithoutStreakInput = {
    create?: XOR<UserCreateWithoutStreakInput, UserUncheckedCreateWithoutStreakInput>
    connectOrCreate?: UserCreateOrConnectWithoutStreakInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutStreakNestedInput = {
    create?: XOR<UserCreateWithoutStreakInput, UserUncheckedCreateWithoutStreakInput>
    connectOrCreate?: UserCreateOrConnectWithoutStreakInput
    upsert?: UserUpsertWithoutStreakInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStreakInput, UserUpdateWithoutStreakInput>, UserUncheckedUpdateWithoutStreakInput>
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAchievementCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AchievementCategory
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserCreateNestedOneWithoutChatSessionsInput = {
    create?: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutSessionInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutChatSessionsNestedInput = {
    create?: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatSessionsInput
    upsert?: UserUpsertWithoutChatSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatSessionsInput, UserUpdateWithoutChatSessionsInput>, UserUncheckedUpdateWithoutChatSessionsInput>
  }

  export type ChatMessageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSessionInput | ChatMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSessionInput | ChatMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSessionInput | ChatMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput> | ChatMessageCreateWithoutSessionInput[] | ChatMessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutSessionInput | ChatMessageCreateOrConnectWithoutSessionInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutSessionInput | ChatMessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ChatMessageCreateManySessionInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutSessionInput | ChatMessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutSessionInput | ChatMessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageCreatekeywordsInput = {
    set: string[]
  }

  export type ChatSessionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutMessagesInput
    connect?: ChatSessionWhereUniqueInput
  }

  export type ChatMessageUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ChatSessionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatSessionCreateOrConnectWithoutMessagesInput
    upsert?: ChatSessionUpsertWithoutMessagesInput
    connect?: ChatSessionWhereUniqueInput
    update?: XOR<XOR<ChatSessionUpdateToOneWithWhereWithoutMessagesInput, ChatSessionUpdateWithoutMessagesInput>, ChatSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type SATStudyPlanCreatecompletedWeeksInput = {
    set: number[]
  }

  export type UserCreateNestedOneWithoutSatStudyPlansInput = {
    create?: XOR<UserCreateWithoutSatStudyPlansInput, UserUncheckedCreateWithoutSatStudyPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutSatStudyPlansInput
    connect?: UserWhereUniqueInput
  }

  export type SATStudyPlanUpdatecompletedWeeksInput = {
    set?: number[]
    push?: number | number[]
  }

  export type UserUpdateOneRequiredWithoutSatStudyPlansNestedInput = {
    create?: XOR<UserCreateWithoutSatStudyPlansInput, UserUncheckedCreateWithoutSatStudyPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutSatStudyPlansInput
    upsert?: UserUpsertWithoutSatStudyPlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSatStudyPlansInput, UserUpdateWithoutSatStudyPlansInput>, UserUncheckedUpdateWithoutSatStudyPlansInput>
  }

  export type UserCreateNestedOneWithoutSatPracticeSessionsInput = {
    create?: XOR<UserCreateWithoutSatPracticeSessionsInput, UserUncheckedCreateWithoutSatPracticeSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSatPracticeSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSatPracticeSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSatPracticeSessionsInput, UserUncheckedCreateWithoutSatPracticeSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSatPracticeSessionsInput
    upsert?: UserUpsertWithoutSatPracticeSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSatPracticeSessionsInput, UserUpdateWithoutSatPracticeSessionsInput>, UserUncheckedUpdateWithoutSatPracticeSessionsInput>
  }

  export type UserCreateNestedOneWithoutSatDiagnosticResultsInput = {
    create?: XOR<UserCreateWithoutSatDiagnosticResultsInput, UserUncheckedCreateWithoutSatDiagnosticResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSatDiagnosticResultsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSatDiagnosticResultsNestedInput = {
    create?: XOR<UserCreateWithoutSatDiagnosticResultsInput, UserUncheckedCreateWithoutSatDiagnosticResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSatDiagnosticResultsInput
    upsert?: UserUpsertWithoutSatDiagnosticResultsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSatDiagnosticResultsInput, UserUpdateWithoutSatDiagnosticResultsInput>, UserUncheckedUpdateWithoutSatDiagnosticResultsInput>
  }

  export type UserCreateNestedOneWithoutGeneratedQuestionsInput = {
    create?: XOR<UserCreateWithoutGeneratedQuestionsInput, UserUncheckedCreateWithoutGeneratedQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedQuestionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutGeneratedQuestionsNestedInput = {
    create?: XOR<UserCreateWithoutGeneratedQuestionsInput, UserUncheckedCreateWithoutGeneratedQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedQuestionsInput
    upsert?: UserUpsertWithoutGeneratedQuestionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGeneratedQuestionsInput, UserUpdateWithoutGeneratedQuestionsInput>, UserUncheckedUpdateWithoutGeneratedQuestionsInput>
  }

  export type UserCreateNestedOneWithoutMockExamsInput = {
    create?: XOR<UserCreateWithoutMockExamsInput, UserUncheckedCreateWithoutMockExamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMockExamsInput
    connect?: UserWhereUniqueInput
  }

  export type MockAttemptCreateNestedManyWithoutMockExamInput = {
    create?: XOR<MockAttemptCreateWithoutMockExamInput, MockAttemptUncheckedCreateWithoutMockExamInput> | MockAttemptCreateWithoutMockExamInput[] | MockAttemptUncheckedCreateWithoutMockExamInput[]
    connectOrCreate?: MockAttemptCreateOrConnectWithoutMockExamInput | MockAttemptCreateOrConnectWithoutMockExamInput[]
    createMany?: MockAttemptCreateManyMockExamInputEnvelope
    connect?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
  }

  export type MockAttemptUncheckedCreateNestedManyWithoutMockExamInput = {
    create?: XOR<MockAttemptCreateWithoutMockExamInput, MockAttemptUncheckedCreateWithoutMockExamInput> | MockAttemptCreateWithoutMockExamInput[] | MockAttemptUncheckedCreateWithoutMockExamInput[]
    connectOrCreate?: MockAttemptCreateOrConnectWithoutMockExamInput | MockAttemptCreateOrConnectWithoutMockExamInput[]
    createMany?: MockAttemptCreateManyMockExamInputEnvelope
    connect?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMockExamsNestedInput = {
    create?: XOR<UserCreateWithoutMockExamsInput, UserUncheckedCreateWithoutMockExamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMockExamsInput
    upsert?: UserUpsertWithoutMockExamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMockExamsInput, UserUpdateWithoutMockExamsInput>, UserUncheckedUpdateWithoutMockExamsInput>
  }

  export type MockAttemptUpdateManyWithoutMockExamNestedInput = {
    create?: XOR<MockAttemptCreateWithoutMockExamInput, MockAttemptUncheckedCreateWithoutMockExamInput> | MockAttemptCreateWithoutMockExamInput[] | MockAttemptUncheckedCreateWithoutMockExamInput[]
    connectOrCreate?: MockAttemptCreateOrConnectWithoutMockExamInput | MockAttemptCreateOrConnectWithoutMockExamInput[]
    upsert?: MockAttemptUpsertWithWhereUniqueWithoutMockExamInput | MockAttemptUpsertWithWhereUniqueWithoutMockExamInput[]
    createMany?: MockAttemptCreateManyMockExamInputEnvelope
    set?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    disconnect?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    delete?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    connect?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    update?: MockAttemptUpdateWithWhereUniqueWithoutMockExamInput | MockAttemptUpdateWithWhereUniqueWithoutMockExamInput[]
    updateMany?: MockAttemptUpdateManyWithWhereWithoutMockExamInput | MockAttemptUpdateManyWithWhereWithoutMockExamInput[]
    deleteMany?: MockAttemptScalarWhereInput | MockAttemptScalarWhereInput[]
  }

  export type MockAttemptUncheckedUpdateManyWithoutMockExamNestedInput = {
    create?: XOR<MockAttemptCreateWithoutMockExamInput, MockAttemptUncheckedCreateWithoutMockExamInput> | MockAttemptCreateWithoutMockExamInput[] | MockAttemptUncheckedCreateWithoutMockExamInput[]
    connectOrCreate?: MockAttemptCreateOrConnectWithoutMockExamInput | MockAttemptCreateOrConnectWithoutMockExamInput[]
    upsert?: MockAttemptUpsertWithWhereUniqueWithoutMockExamInput | MockAttemptUpsertWithWhereUniqueWithoutMockExamInput[]
    createMany?: MockAttemptCreateManyMockExamInputEnvelope
    set?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    disconnect?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    delete?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    connect?: MockAttemptWhereUniqueInput | MockAttemptWhereUniqueInput[]
    update?: MockAttemptUpdateWithWhereUniqueWithoutMockExamInput | MockAttemptUpdateWithWhereUniqueWithoutMockExamInput[]
    updateMany?: MockAttemptUpdateManyWithWhereWithoutMockExamInput | MockAttemptUpdateManyWithWhereWithoutMockExamInput[]
    deleteMany?: MockAttemptScalarWhereInput | MockAttemptScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMockAttemptsInput = {
    create?: XOR<UserCreateWithoutMockAttemptsInput, UserUncheckedCreateWithoutMockAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMockAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type MockExamCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<MockExamCreateWithoutAttemptsInput, MockExamUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: MockExamCreateOrConnectWithoutAttemptsInput
    connect?: MockExamWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMockAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutMockAttemptsInput, UserUncheckedCreateWithoutMockAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMockAttemptsInput
    upsert?: UserUpsertWithoutMockAttemptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMockAttemptsInput, UserUpdateWithoutMockAttemptsInput>, UserUncheckedUpdateWithoutMockAttemptsInput>
  }

  export type MockExamUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<MockExamCreateWithoutAttemptsInput, MockExamUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: MockExamCreateOrConnectWithoutAttemptsInput
    upsert?: MockExamUpsertWithoutAttemptsInput
    connect?: MockExamWhereUniqueInput
    update?: XOR<XOR<MockExamUpdateToOneWithWhereWithoutAttemptsInput, MockExamUpdateWithoutAttemptsInput>, MockExamUncheckedUpdateWithoutAttemptsInput>
  }

  export type UserCreateNestedOneWithoutTopicMasteriesInput = {
    create?: XOR<UserCreateWithoutTopicMasteriesInput, UserUncheckedCreateWithoutTopicMasteriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopicMasteriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTopicMasteriesNestedInput = {
    create?: XOR<UserCreateWithoutTopicMasteriesInput, UserUncheckedCreateWithoutTopicMasteriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopicMasteriesInput
    upsert?: UserUpsertWithoutTopicMasteriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTopicMasteriesInput, UserUpdateWithoutTopicMasteriesInput>, UserUncheckedUpdateWithoutTopicMasteriesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLearningStyleFilter<$PrismaModel = never> = {
    equals?: $Enums.LearningStyle | EnumLearningStyleFieldRefInput<$PrismaModel>
    in?: $Enums.LearningStyle[] | ListEnumLearningStyleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LearningStyle[] | ListEnumLearningStyleFieldRefInput<$PrismaModel>
    not?: NestedEnumLearningStyleFilter<$PrismaModel> | $Enums.LearningStyle
  }

  export type NestedEnumDifficultyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelFilter<$PrismaModel> | $Enums.DifficultyLevel
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumLearningStyleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LearningStyle | EnumLearningStyleFieldRefInput<$PrismaModel>
    in?: $Enums.LearningStyle[] | ListEnumLearningStyleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LearningStyle[] | ListEnumLearningStyleFieldRefInput<$PrismaModel>
    not?: NestedEnumLearningStyleWithAggregatesFilter<$PrismaModel> | $Enums.LearningStyle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLearningStyleFilter<$PrismaModel>
    _max?: NestedEnumLearningStyleFilter<$PrismaModel>
  }

  export type NestedEnumDifficultyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelWithAggregatesFilter<$PrismaModel> | $Enums.DifficultyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyLevelFilter<$PrismaModel>
    _max?: NestedEnumDifficultyLevelFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserCreateWithoutPostsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    content: string
  }

  export type PostUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    content: string
  }

  export type PostCreateOrConnectWithoutUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostCreateManyUserInputEnvelope = {
    data: PostCreateManyUserInput | PostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudentActivityCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    type: $Enums.ActivityType
    subject?: string | null
    topic?: string | null
    duration?: number | null
    score?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StudentActivityUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    type: $Enums.ActivityType
    subject?: string | null
    topic?: string | null
    duration?: number | null
    score?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StudentActivityCreateOrConnectWithoutUserInput = {
    where: StudentActivityWhereUniqueInput
    create: XOR<StudentActivityCreateWithoutUserInput, StudentActivityUncheckedCreateWithoutUserInput>
  }

  export type StudentActivityCreateManyUserInputEnvelope = {
    data: StudentActivityCreateManyUserInput | StudentActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LearningStreakCreateWithoutUserInput = {
    id?: string
    currentStreak?: number
    longestStreak?: number
    lastActivity?: Date | string
  }

  export type LearningStreakUncheckedCreateWithoutUserInput = {
    id?: string
    currentStreak?: number
    longestStreak?: number
    lastActivity?: Date | string
  }

  export type LearningStreakCreateOrConnectWithoutUserInput = {
    where: LearningStreakWhereUniqueInput
    create: XOR<LearningStreakCreateWithoutUserInput, LearningStreakUncheckedCreateWithoutUserInput>
  }

  export type AchievementCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    title: string
    description: string
    icon: string
    category: $Enums.AchievementCategory
    progress?: number
    completed?: boolean
  }

  export type AchievementUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    title: string
    description: string
    icon: string
    category: $Enums.AchievementCategory
    progress?: number
    completed?: boolean
  }

  export type AchievementCreateOrConnectWithoutUserInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput>
  }

  export type AchievementCreateManyUserInputEnvelope = {
    data: AchievementCreateManyUserInput | AchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatSessionCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title?: string | null
    topic?: string | null
    isActive?: boolean
    messages?: ChatMessageCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title?: string | null
    topic?: string | null
    isActive?: boolean
    messages?: ChatMessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ChatSessionCreateOrConnectWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput>
  }

  export type ChatSessionCreateManyUserInputEnvelope = {
    data: ChatSessionCreateManyUserInput | ChatSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SATStudyPlanCreateWithoutUserInput = {
    id?: string
    timeline: string
    focusAreas: JsonNullValueInput | InputJsonValue
    weeklySchedule: JsonNullValueInput | InputJsonValue
    resourceRecommendations: JsonNullValueInput | InputJsonValue
    aiGeneratedPlan?: NullableJsonNullValueInput | InputJsonValue
    completedWeeks?: SATStudyPlanCreatecompletedWeeksInput | number[]
    completedTasks?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SATStudyPlanUncheckedCreateWithoutUserInput = {
    id?: string
    timeline: string
    focusAreas: JsonNullValueInput | InputJsonValue
    weeklySchedule: JsonNullValueInput | InputJsonValue
    resourceRecommendations: JsonNullValueInput | InputJsonValue
    aiGeneratedPlan?: NullableJsonNullValueInput | InputJsonValue
    completedWeeks?: SATStudyPlanCreatecompletedWeeksInput | number[]
    completedTasks?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SATStudyPlanCreateOrConnectWithoutUserInput = {
    where: SATStudyPlanWhereUniqueInput
    create: XOR<SATStudyPlanCreateWithoutUserInput, SATStudyPlanUncheckedCreateWithoutUserInput>
  }

  export type SATStudyPlanCreateManyUserInputEnvelope = {
    data: SATStudyPlanCreateManyUserInput | SATStudyPlanCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SATPracticeSessionCreateWithoutUserInput = {
    id?: string
    section: string
    score?: number | null
    maxScore?: number | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    timeSpent?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SATPracticeSessionUncheckedCreateWithoutUserInput = {
    id?: string
    section: string
    score?: number | null
    maxScore?: number | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    timeSpent?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SATPracticeSessionCreateOrConnectWithoutUserInput = {
    where: SATPracticeSessionWhereUniqueInput
    create: XOR<SATPracticeSessionCreateWithoutUserInput, SATPracticeSessionUncheckedCreateWithoutUserInput>
  }

  export type SATPracticeSessionCreateManyUserInputEnvelope = {
    data: SATPracticeSessionCreateManyUserInput | SATPracticeSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SATDiagnosticResultCreateWithoutUserInput = {
    id?: string
    mathScore?: number | null
    readingScore?: number | null
    writingScore?: number | null
    totalScore?: number | null
    strengths?: NullableJsonNullValueInput | InputJsonValue
    weaknesses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SATDiagnosticResultUncheckedCreateWithoutUserInput = {
    id?: string
    mathScore?: number | null
    readingScore?: number | null
    writingScore?: number | null
    totalScore?: number | null
    strengths?: NullableJsonNullValueInput | InputJsonValue
    weaknesses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SATDiagnosticResultCreateOrConnectWithoutUserInput = {
    where: SATDiagnosticResultWhereUniqueInput
    create: XOR<SATDiagnosticResultCreateWithoutUserInput, SATDiagnosticResultUncheckedCreateWithoutUserInput>
  }

  export type SATDiagnosticResultCreateManyUserInputEnvelope = {
    data: SATDiagnosticResultCreateManyUserInput | SATDiagnosticResultCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuestionCreateWithoutUserInput = {
    id?: string
    topic: string
    subject: string
    difficulty: string
    question: string
    choices: JsonNullValueInput | InputJsonValue
    answer: string
    explanation: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionUncheckedCreateWithoutUserInput = {
    id?: string
    topic: string
    subject: string
    difficulty: string
    question: string
    choices: JsonNullValueInput | InputJsonValue
    answer: string
    explanation: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionCreateOrConnectWithoutUserInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutUserInput, QuestionUncheckedCreateWithoutUserInput>
  }

  export type QuestionCreateManyUserInputEnvelope = {
    data: QuestionCreateManyUserInput | QuestionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MockExamCreateWithoutUserInput = {
    id?: string
    goal: string
    grade: number
    sections: JsonNullValueInput | InputJsonValue
    totalTime: number
    createdAt?: Date | string
    attempts?: MockAttemptCreateNestedManyWithoutMockExamInput
  }

  export type MockExamUncheckedCreateWithoutUserInput = {
    id?: string
    goal: string
    grade: number
    sections: JsonNullValueInput | InputJsonValue
    totalTime: number
    createdAt?: Date | string
    attempts?: MockAttemptUncheckedCreateNestedManyWithoutMockExamInput
  }

  export type MockExamCreateOrConnectWithoutUserInput = {
    where: MockExamWhereUniqueInput
    create: XOR<MockExamCreateWithoutUserInput, MockExamUncheckedCreateWithoutUserInput>
  }

  export type MockExamCreateManyUserInputEnvelope = {
    data: MockExamCreateManyUserInput | MockExamCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MockAttemptCreateWithoutUserInput = {
    id?: string
    answers: JsonNullValueInput | InputJsonValue
    scored: JsonNullValueInput | InputJsonValue
    summary: JsonNullValueInput | InputJsonValue
    startedAt: Date | string
    finishedAt: Date | string
    createdAt?: Date | string
    mockExam: MockExamCreateNestedOneWithoutAttemptsInput
  }

  export type MockAttemptUncheckedCreateWithoutUserInput = {
    id?: string
    mockExamId: string
    answers: JsonNullValueInput | InputJsonValue
    scored: JsonNullValueInput | InputJsonValue
    summary: JsonNullValueInput | InputJsonValue
    startedAt: Date | string
    finishedAt: Date | string
    createdAt?: Date | string
  }

  export type MockAttemptCreateOrConnectWithoutUserInput = {
    where: MockAttemptWhereUniqueInput
    create: XOR<MockAttemptCreateWithoutUserInput, MockAttemptUncheckedCreateWithoutUserInput>
  }

  export type MockAttemptCreateManyUserInputEnvelope = {
    data: MockAttemptCreateManyUserInput | MockAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TopicMasteryCreateWithoutUserInput = {
    id?: string
    topic: string
    correct?: number
    total?: number
    lastSeenAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicMasteryUncheckedCreateWithoutUserInput = {
    id?: string
    topic: string
    correct?: number
    total?: number
    lastSeenAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicMasteryCreateOrConnectWithoutUserInput = {
    where: TopicMasteryWhereUniqueInput
    create: XOR<TopicMasteryCreateWithoutUserInput, TopicMasteryUncheckedCreateWithoutUserInput>
  }

  export type TopicMasteryCreateManyUserInputEnvelope = {
    data: TopicMasteryCreateManyUserInput | TopicMasteryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    impersonatedBy?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    userId?: StringFilter<"Account"> | string
  }

  export type PostUpsertWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithWhereWithoutUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutUserInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    userId?: StringFilter<"Post"> | string
  }

  export type StudentActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: StudentActivityWhereUniqueInput
    update: XOR<StudentActivityUpdateWithoutUserInput, StudentActivityUncheckedUpdateWithoutUserInput>
    create: XOR<StudentActivityCreateWithoutUserInput, StudentActivityUncheckedCreateWithoutUserInput>
  }

  export type StudentActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: StudentActivityWhereUniqueInput
    data: XOR<StudentActivityUpdateWithoutUserInput, StudentActivityUncheckedUpdateWithoutUserInput>
  }

  export type StudentActivityUpdateManyWithWhereWithoutUserInput = {
    where: StudentActivityScalarWhereInput
    data: XOR<StudentActivityUpdateManyMutationInput, StudentActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type StudentActivityScalarWhereInput = {
    AND?: StudentActivityScalarWhereInput | StudentActivityScalarWhereInput[]
    OR?: StudentActivityScalarWhereInput[]
    NOT?: StudentActivityScalarWhereInput | StudentActivityScalarWhereInput[]
    id?: StringFilter<"StudentActivity"> | string
    createdAt?: DateTimeFilter<"StudentActivity"> | Date | string
    userId?: StringFilter<"StudentActivity"> | string
    type?: EnumActivityTypeFilter<"StudentActivity"> | $Enums.ActivityType
    subject?: StringNullableFilter<"StudentActivity"> | string | null
    topic?: StringNullableFilter<"StudentActivity"> | string | null
    duration?: IntNullableFilter<"StudentActivity"> | number | null
    score?: FloatNullableFilter<"StudentActivity"> | number | null
    metadata?: JsonNullableFilter<"StudentActivity">
  }

  export type LearningStreakUpsertWithoutUserInput = {
    update: XOR<LearningStreakUpdateWithoutUserInput, LearningStreakUncheckedUpdateWithoutUserInput>
    create: XOR<LearningStreakCreateWithoutUserInput, LearningStreakUncheckedCreateWithoutUserInput>
    where?: LearningStreakWhereInput
  }

  export type LearningStreakUpdateToOneWithWhereWithoutUserInput = {
    where?: LearningStreakWhereInput
    data: XOR<LearningStreakUpdateWithoutUserInput, LearningStreakUncheckedUpdateWithoutUserInput>
  }

  export type LearningStreakUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningStreakUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: AchievementWhereUniqueInput
    update: XOR<AchievementUpdateWithoutUserInput, AchievementUncheckedUpdateWithoutUserInput>
    create: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput>
  }

  export type AchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: AchievementWhereUniqueInput
    data: XOR<AchievementUpdateWithoutUserInput, AchievementUncheckedUpdateWithoutUserInput>
  }

  export type AchievementUpdateManyWithWhereWithoutUserInput = {
    where: AchievementScalarWhereInput
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type AchievementScalarWhereInput = {
    AND?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    OR?: AchievementScalarWhereInput[]
    NOT?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    id?: StringFilter<"Achievement"> | string
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    userId?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    icon?: StringFilter<"Achievement"> | string
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    progress?: FloatFilter<"Achievement"> | number
    completed?: BoolFilter<"Achievement"> | boolean
  }

  export type ChatSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    update: XOR<ChatSessionUpdateWithoutUserInput, ChatSessionUncheckedUpdateWithoutUserInput>
    create: XOR<ChatSessionCreateWithoutUserInput, ChatSessionUncheckedCreateWithoutUserInput>
  }

  export type ChatSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatSessionWhereUniqueInput
    data: XOR<ChatSessionUpdateWithoutUserInput, ChatSessionUncheckedUpdateWithoutUserInput>
  }

  export type ChatSessionUpdateManyWithWhereWithoutUserInput = {
    where: ChatSessionScalarWhereInput
    data: XOR<ChatSessionUpdateManyMutationInput, ChatSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatSessionScalarWhereInput = {
    AND?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
    OR?: ChatSessionScalarWhereInput[]
    NOT?: ChatSessionScalarWhereInput | ChatSessionScalarWhereInput[]
    id?: StringFilter<"ChatSession"> | string
    createdAt?: DateTimeFilter<"ChatSession"> | Date | string
    updatedAt?: DateTimeFilter<"ChatSession"> | Date | string
    userId?: StringFilter<"ChatSession"> | string
    title?: StringNullableFilter<"ChatSession"> | string | null
    topic?: StringNullableFilter<"ChatSession"> | string | null
    isActive?: BoolFilter<"ChatSession"> | boolean
  }

  export type SATStudyPlanUpsertWithWhereUniqueWithoutUserInput = {
    where: SATStudyPlanWhereUniqueInput
    update: XOR<SATStudyPlanUpdateWithoutUserInput, SATStudyPlanUncheckedUpdateWithoutUserInput>
    create: XOR<SATStudyPlanCreateWithoutUserInput, SATStudyPlanUncheckedCreateWithoutUserInput>
  }

  export type SATStudyPlanUpdateWithWhereUniqueWithoutUserInput = {
    where: SATStudyPlanWhereUniqueInput
    data: XOR<SATStudyPlanUpdateWithoutUserInput, SATStudyPlanUncheckedUpdateWithoutUserInput>
  }

  export type SATStudyPlanUpdateManyWithWhereWithoutUserInput = {
    where: SATStudyPlanScalarWhereInput
    data: XOR<SATStudyPlanUpdateManyMutationInput, SATStudyPlanUncheckedUpdateManyWithoutUserInput>
  }

  export type SATStudyPlanScalarWhereInput = {
    AND?: SATStudyPlanScalarWhereInput | SATStudyPlanScalarWhereInput[]
    OR?: SATStudyPlanScalarWhereInput[]
    NOT?: SATStudyPlanScalarWhereInput | SATStudyPlanScalarWhereInput[]
    id?: StringFilter<"SATStudyPlan"> | string
    userId?: StringFilter<"SATStudyPlan"> | string
    timeline?: StringFilter<"SATStudyPlan"> | string
    focusAreas?: JsonFilter<"SATStudyPlan">
    weeklySchedule?: JsonFilter<"SATStudyPlan">
    resourceRecommendations?: JsonFilter<"SATStudyPlan">
    aiGeneratedPlan?: JsonNullableFilter<"SATStudyPlan">
    completedWeeks?: IntNullableListFilter<"SATStudyPlan">
    completedTasks?: JsonFilter<"SATStudyPlan">
    createdAt?: DateTimeFilter<"SATStudyPlan"> | Date | string
    updatedAt?: DateTimeFilter<"SATStudyPlan"> | Date | string
  }

  export type SATPracticeSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SATPracticeSessionWhereUniqueInput
    update: XOR<SATPracticeSessionUpdateWithoutUserInput, SATPracticeSessionUncheckedUpdateWithoutUserInput>
    create: XOR<SATPracticeSessionCreateWithoutUserInput, SATPracticeSessionUncheckedCreateWithoutUserInput>
  }

  export type SATPracticeSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SATPracticeSessionWhereUniqueInput
    data: XOR<SATPracticeSessionUpdateWithoutUserInput, SATPracticeSessionUncheckedUpdateWithoutUserInput>
  }

  export type SATPracticeSessionUpdateManyWithWhereWithoutUserInput = {
    where: SATPracticeSessionScalarWhereInput
    data: XOR<SATPracticeSessionUpdateManyMutationInput, SATPracticeSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SATPracticeSessionScalarWhereInput = {
    AND?: SATPracticeSessionScalarWhereInput | SATPracticeSessionScalarWhereInput[]
    OR?: SATPracticeSessionScalarWhereInput[]
    NOT?: SATPracticeSessionScalarWhereInput | SATPracticeSessionScalarWhereInput[]
    id?: StringFilter<"SATPracticeSession"> | string
    userId?: StringFilter<"SATPracticeSession"> | string
    section?: StringFilter<"SATPracticeSession"> | string
    score?: IntNullableFilter<"SATPracticeSession"> | number | null
    maxScore?: IntNullableFilter<"SATPracticeSession"> | number | null
    answers?: JsonNullableFilter<"SATPracticeSession">
    timeSpent?: IntNullableFilter<"SATPracticeSession"> | number | null
    completedAt?: DateTimeNullableFilter<"SATPracticeSession"> | Date | string | null
    createdAt?: DateTimeFilter<"SATPracticeSession"> | Date | string
  }

  export type SATDiagnosticResultUpsertWithWhereUniqueWithoutUserInput = {
    where: SATDiagnosticResultWhereUniqueInput
    update: XOR<SATDiagnosticResultUpdateWithoutUserInput, SATDiagnosticResultUncheckedUpdateWithoutUserInput>
    create: XOR<SATDiagnosticResultCreateWithoutUserInput, SATDiagnosticResultUncheckedCreateWithoutUserInput>
  }

  export type SATDiagnosticResultUpdateWithWhereUniqueWithoutUserInput = {
    where: SATDiagnosticResultWhereUniqueInput
    data: XOR<SATDiagnosticResultUpdateWithoutUserInput, SATDiagnosticResultUncheckedUpdateWithoutUserInput>
  }

  export type SATDiagnosticResultUpdateManyWithWhereWithoutUserInput = {
    where: SATDiagnosticResultScalarWhereInput
    data: XOR<SATDiagnosticResultUpdateManyMutationInput, SATDiagnosticResultUncheckedUpdateManyWithoutUserInput>
  }

  export type SATDiagnosticResultScalarWhereInput = {
    AND?: SATDiagnosticResultScalarWhereInput | SATDiagnosticResultScalarWhereInput[]
    OR?: SATDiagnosticResultScalarWhereInput[]
    NOT?: SATDiagnosticResultScalarWhereInput | SATDiagnosticResultScalarWhereInput[]
    id?: StringFilter<"SATDiagnosticResult"> | string
    userId?: StringFilter<"SATDiagnosticResult"> | string
    mathScore?: IntNullableFilter<"SATDiagnosticResult"> | number | null
    readingScore?: IntNullableFilter<"SATDiagnosticResult"> | number | null
    writingScore?: IntNullableFilter<"SATDiagnosticResult"> | number | null
    totalScore?: IntNullableFilter<"SATDiagnosticResult"> | number | null
    strengths?: JsonNullableFilter<"SATDiagnosticResult">
    weaknesses?: JsonNullableFilter<"SATDiagnosticResult">
    createdAt?: DateTimeFilter<"SATDiagnosticResult"> | Date | string
  }

  export type QuestionUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutUserInput, QuestionUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionCreateWithoutUserInput, QuestionUncheckedCreateWithoutUserInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutUserInput, QuestionUncheckedUpdateWithoutUserInput>
  }

  export type QuestionUpdateManyWithWhereWithoutUserInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutUserInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: StringFilter<"Question"> | string
    topic?: StringFilter<"Question"> | string
    subject?: StringFilter<"Question"> | string
    difficulty?: StringFilter<"Question"> | string
    question?: StringFilter<"Question"> | string
    choices?: JsonFilter<"Question">
    answer?: StringFilter<"Question"> | string
    explanation?: StringFilter<"Question"> | string
    source?: StringFilter<"Question"> | string
    status?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    userGeneratedBy?: StringNullableFilter<"Question"> | string | null
  }

  export type MockExamUpsertWithWhereUniqueWithoutUserInput = {
    where: MockExamWhereUniqueInput
    update: XOR<MockExamUpdateWithoutUserInput, MockExamUncheckedUpdateWithoutUserInput>
    create: XOR<MockExamCreateWithoutUserInput, MockExamUncheckedCreateWithoutUserInput>
  }

  export type MockExamUpdateWithWhereUniqueWithoutUserInput = {
    where: MockExamWhereUniqueInput
    data: XOR<MockExamUpdateWithoutUserInput, MockExamUncheckedUpdateWithoutUserInput>
  }

  export type MockExamUpdateManyWithWhereWithoutUserInput = {
    where: MockExamScalarWhereInput
    data: XOR<MockExamUpdateManyMutationInput, MockExamUncheckedUpdateManyWithoutUserInput>
  }

  export type MockExamScalarWhereInput = {
    AND?: MockExamScalarWhereInput | MockExamScalarWhereInput[]
    OR?: MockExamScalarWhereInput[]
    NOT?: MockExamScalarWhereInput | MockExamScalarWhereInput[]
    id?: StringFilter<"MockExam"> | string
    userId?: StringFilter<"MockExam"> | string
    goal?: StringFilter<"MockExam"> | string
    grade?: IntFilter<"MockExam"> | number
    sections?: JsonFilter<"MockExam">
    totalTime?: IntFilter<"MockExam"> | number
    createdAt?: DateTimeFilter<"MockExam"> | Date | string
  }

  export type MockAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: MockAttemptWhereUniqueInput
    update: XOR<MockAttemptUpdateWithoutUserInput, MockAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<MockAttemptCreateWithoutUserInput, MockAttemptUncheckedCreateWithoutUserInput>
  }

  export type MockAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: MockAttemptWhereUniqueInput
    data: XOR<MockAttemptUpdateWithoutUserInput, MockAttemptUncheckedUpdateWithoutUserInput>
  }

  export type MockAttemptUpdateManyWithWhereWithoutUserInput = {
    where: MockAttemptScalarWhereInput
    data: XOR<MockAttemptUpdateManyMutationInput, MockAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type MockAttemptScalarWhereInput = {
    AND?: MockAttemptScalarWhereInput | MockAttemptScalarWhereInput[]
    OR?: MockAttemptScalarWhereInput[]
    NOT?: MockAttemptScalarWhereInput | MockAttemptScalarWhereInput[]
    id?: StringFilter<"MockAttempt"> | string
    userId?: StringFilter<"MockAttempt"> | string
    mockExamId?: StringFilter<"MockAttempt"> | string
    answers?: JsonFilter<"MockAttempt">
    scored?: JsonFilter<"MockAttempt">
    summary?: JsonFilter<"MockAttempt">
    startedAt?: DateTimeFilter<"MockAttempt"> | Date | string
    finishedAt?: DateTimeFilter<"MockAttempt"> | Date | string
    createdAt?: DateTimeFilter<"MockAttempt"> | Date | string
  }

  export type TopicMasteryUpsertWithWhereUniqueWithoutUserInput = {
    where: TopicMasteryWhereUniqueInput
    update: XOR<TopicMasteryUpdateWithoutUserInput, TopicMasteryUncheckedUpdateWithoutUserInput>
    create: XOR<TopicMasteryCreateWithoutUserInput, TopicMasteryUncheckedCreateWithoutUserInput>
  }

  export type TopicMasteryUpdateWithWhereUniqueWithoutUserInput = {
    where: TopicMasteryWhereUniqueInput
    data: XOR<TopicMasteryUpdateWithoutUserInput, TopicMasteryUncheckedUpdateWithoutUserInput>
  }

  export type TopicMasteryUpdateManyWithWhereWithoutUserInput = {
    where: TopicMasteryScalarWhereInput
    data: XOR<TopicMasteryUpdateManyMutationInput, TopicMasteryUncheckedUpdateManyWithoutUserInput>
  }

  export type TopicMasteryScalarWhereInput = {
    AND?: TopicMasteryScalarWhereInput | TopicMasteryScalarWhereInput[]
    OR?: TopicMasteryScalarWhereInput[]
    NOT?: TopicMasteryScalarWhereInput | TopicMasteryScalarWhereInput[]
    id?: StringFilter<"TopicMastery"> | string
    userId?: StringFilter<"TopicMastery"> | string
    topic?: StringFilter<"TopicMastery"> | string
    correct?: IntFilter<"TopicMastery"> | number
    total?: IntFilter<"TopicMastery"> | number
    lastSeenAt?: DateTimeFilter<"TopicMastery"> | Date | string
    updatedAt?: DateTimeFilter<"TopicMastery"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutActivitiesInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutStreakInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStreakInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStreakInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStreakInput, UserUncheckedCreateWithoutStreakInput>
  }

  export type UserUpsertWithoutStreakInput = {
    update: XOR<UserUpdateWithoutStreakInput, UserUncheckedUpdateWithoutStreakInput>
    create: XOR<UserCreateWithoutStreakInput, UserUncheckedCreateWithoutStreakInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStreakInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStreakInput, UserUncheckedUpdateWithoutStreakInput>
  }

  export type UserUpdateWithoutStreakInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStreakInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAchievementsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutChatSessionsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatSessionsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
  }

  export type ChatMessageCreateWithoutSessionInput = {
    id?: string
    createdAt?: Date | string
    content: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    keywords?: ChatMessageCreatekeywordsInput | string[]
  }

  export type ChatMessageUncheckedCreateWithoutSessionInput = {
    id?: string
    createdAt?: Date | string
    content: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    keywords?: ChatMessageCreatekeywordsInput | string[]
  }

  export type ChatMessageCreateOrConnectWithoutSessionInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput>
  }

  export type ChatMessageCreateManySessionInputEnvelope = {
    data: ChatMessageCreateManySessionInput | ChatMessageCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutChatSessionsInput = {
    update: XOR<UserUpdateWithoutChatSessionsInput, UserUncheckedUpdateWithoutChatSessionsInput>
    create: XOR<UserCreateWithoutChatSessionsInput, UserUncheckedCreateWithoutChatSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatSessionsInput, UserUncheckedUpdateWithoutChatSessionsInput>
  }

  export type UserUpdateWithoutChatSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutSessionInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutSessionInput, ChatMessageUncheckedUpdateWithoutSessionInput>
    create: XOR<ChatMessageCreateWithoutSessionInput, ChatMessageUncheckedCreateWithoutSessionInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutSessionInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutSessionInput, ChatMessageUncheckedUpdateWithoutSessionInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutSessionInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutSessionInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    sessionId?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    type?: StringFilter<"ChatMessage"> | string
    metadata?: JsonNullableFilter<"ChatMessage">
    imageUrl?: StringNullableFilter<"ChatMessage"> | string | null
    links?: JsonNullableFilter<"ChatMessage">
    keywords?: StringNullableListFilter<"ChatMessage">
  }

  export type ChatSessionCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title?: string | null
    topic?: string | null
    isActive?: boolean
    user: UserCreateNestedOneWithoutChatSessionsInput
  }

  export type ChatSessionUncheckedCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    title?: string | null
    topic?: string | null
    isActive?: boolean
  }

  export type ChatSessionCreateOrConnectWithoutMessagesInput = {
    where: ChatSessionWhereUniqueInput
    create: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
  }

  export type ChatSessionUpsertWithoutMessagesInput = {
    update: XOR<ChatSessionUpdateWithoutMessagesInput, ChatSessionUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatSessionCreateWithoutMessagesInput, ChatSessionUncheckedCreateWithoutMessagesInput>
    where?: ChatSessionWhereInput
  }

  export type ChatSessionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatSessionWhereInput
    data: XOR<ChatSessionUpdateWithoutMessagesInput, ChatSessionUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatSessionUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutChatSessionsNestedInput
  }

  export type ChatSessionUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateWithoutSatStudyPlansInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSatStudyPlansInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSatStudyPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSatStudyPlansInput, UserUncheckedCreateWithoutSatStudyPlansInput>
  }

  export type UserUpsertWithoutSatStudyPlansInput = {
    update: XOR<UserUpdateWithoutSatStudyPlansInput, UserUncheckedUpdateWithoutSatStudyPlansInput>
    create: XOR<UserCreateWithoutSatStudyPlansInput, UserUncheckedCreateWithoutSatStudyPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSatStudyPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSatStudyPlansInput, UserUncheckedUpdateWithoutSatStudyPlansInput>
  }

  export type UserUpdateWithoutSatStudyPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSatStudyPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSatPracticeSessionsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSatPracticeSessionsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSatPracticeSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSatPracticeSessionsInput, UserUncheckedCreateWithoutSatPracticeSessionsInput>
  }

  export type UserUpsertWithoutSatPracticeSessionsInput = {
    update: XOR<UserUpdateWithoutSatPracticeSessionsInput, UserUncheckedUpdateWithoutSatPracticeSessionsInput>
    create: XOR<UserCreateWithoutSatPracticeSessionsInput, UserUncheckedCreateWithoutSatPracticeSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSatPracticeSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSatPracticeSessionsInput, UserUncheckedUpdateWithoutSatPracticeSessionsInput>
  }

  export type UserUpdateWithoutSatPracticeSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSatPracticeSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSatDiagnosticResultsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSatDiagnosticResultsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSatDiagnosticResultsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSatDiagnosticResultsInput, UserUncheckedCreateWithoutSatDiagnosticResultsInput>
  }

  export type UserUpsertWithoutSatDiagnosticResultsInput = {
    update: XOR<UserUpdateWithoutSatDiagnosticResultsInput, UserUncheckedUpdateWithoutSatDiagnosticResultsInput>
    create: XOR<UserCreateWithoutSatDiagnosticResultsInput, UserUncheckedCreateWithoutSatDiagnosticResultsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSatDiagnosticResultsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSatDiagnosticResultsInput, UserUncheckedUpdateWithoutSatDiagnosticResultsInput>
  }

  export type UserUpdateWithoutSatDiagnosticResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSatDiagnosticResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutGeneratedQuestionsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGeneratedQuestionsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGeneratedQuestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGeneratedQuestionsInput, UserUncheckedCreateWithoutGeneratedQuestionsInput>
  }

  export type UserUpsertWithoutGeneratedQuestionsInput = {
    update: XOR<UserUpdateWithoutGeneratedQuestionsInput, UserUncheckedUpdateWithoutGeneratedQuestionsInput>
    create: XOR<UserCreateWithoutGeneratedQuestionsInput, UserUncheckedCreateWithoutGeneratedQuestionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGeneratedQuestionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGeneratedQuestionsInput, UserUncheckedUpdateWithoutGeneratedQuestionsInput>
  }

  export type UserUpdateWithoutGeneratedQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGeneratedQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMockExamsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMockExamsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMockExamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMockExamsInput, UserUncheckedCreateWithoutMockExamsInput>
  }

  export type MockAttemptCreateWithoutMockExamInput = {
    id?: string
    answers: JsonNullValueInput | InputJsonValue
    scored: JsonNullValueInput | InputJsonValue
    summary: JsonNullValueInput | InputJsonValue
    startedAt: Date | string
    finishedAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMockAttemptsInput
  }

  export type MockAttemptUncheckedCreateWithoutMockExamInput = {
    id?: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    scored: JsonNullValueInput | InputJsonValue
    summary: JsonNullValueInput | InputJsonValue
    startedAt: Date | string
    finishedAt: Date | string
    createdAt?: Date | string
  }

  export type MockAttemptCreateOrConnectWithoutMockExamInput = {
    where: MockAttemptWhereUniqueInput
    create: XOR<MockAttemptCreateWithoutMockExamInput, MockAttemptUncheckedCreateWithoutMockExamInput>
  }

  export type MockAttemptCreateManyMockExamInputEnvelope = {
    data: MockAttemptCreateManyMockExamInput | MockAttemptCreateManyMockExamInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMockExamsInput = {
    update: XOR<UserUpdateWithoutMockExamsInput, UserUncheckedUpdateWithoutMockExamsInput>
    create: XOR<UserCreateWithoutMockExamsInput, UserUncheckedCreateWithoutMockExamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMockExamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMockExamsInput, UserUncheckedUpdateWithoutMockExamsInput>
  }

  export type UserUpdateWithoutMockExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMockExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MockAttemptUpsertWithWhereUniqueWithoutMockExamInput = {
    where: MockAttemptWhereUniqueInput
    update: XOR<MockAttemptUpdateWithoutMockExamInput, MockAttemptUncheckedUpdateWithoutMockExamInput>
    create: XOR<MockAttemptCreateWithoutMockExamInput, MockAttemptUncheckedCreateWithoutMockExamInput>
  }

  export type MockAttemptUpdateWithWhereUniqueWithoutMockExamInput = {
    where: MockAttemptWhereUniqueInput
    data: XOR<MockAttemptUpdateWithoutMockExamInput, MockAttemptUncheckedUpdateWithoutMockExamInput>
  }

  export type MockAttemptUpdateManyWithWhereWithoutMockExamInput = {
    where: MockAttemptScalarWhereInput
    data: XOR<MockAttemptUpdateManyMutationInput, MockAttemptUncheckedUpdateManyWithoutMockExamInput>
  }

  export type UserCreateWithoutMockAttemptsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMockAttemptsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    topicMasteries?: TopicMasteryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMockAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMockAttemptsInput, UserUncheckedCreateWithoutMockAttemptsInput>
  }

  export type MockExamCreateWithoutAttemptsInput = {
    id?: string
    goal: string
    grade: number
    sections: JsonNullValueInput | InputJsonValue
    totalTime: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMockExamsInput
  }

  export type MockExamUncheckedCreateWithoutAttemptsInput = {
    id?: string
    userId: string
    goal: string
    grade: number
    sections: JsonNullValueInput | InputJsonValue
    totalTime: number
    createdAt?: Date | string
  }

  export type MockExamCreateOrConnectWithoutAttemptsInput = {
    where: MockExamWhereUniqueInput
    create: XOR<MockExamCreateWithoutAttemptsInput, MockExamUncheckedCreateWithoutAttemptsInput>
  }

  export type UserUpsertWithoutMockAttemptsInput = {
    update: XOR<UserUpdateWithoutMockAttemptsInput, UserUncheckedUpdateWithoutMockAttemptsInput>
    create: XOR<UserCreateWithoutMockAttemptsInput, UserUncheckedCreateWithoutMockAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMockAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMockAttemptsInput, UserUncheckedUpdateWithoutMockAttemptsInput>
  }

  export type UserUpdateWithoutMockAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMockAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    topicMasteries?: TopicMasteryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MockExamUpsertWithoutAttemptsInput = {
    update: XOR<MockExamUpdateWithoutAttemptsInput, MockExamUncheckedUpdateWithoutAttemptsInput>
    create: XOR<MockExamCreateWithoutAttemptsInput, MockExamUncheckedCreateWithoutAttemptsInput>
    where?: MockExamWhereInput
  }

  export type MockExamUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: MockExamWhereInput
    data: XOR<MockExamUpdateWithoutAttemptsInput, MockExamUncheckedUpdateWithoutAttemptsInput>
  }

  export type MockExamUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    totalTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMockExamsNestedInput
  }

  export type MockExamUncheckedUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    totalTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutTopicMasteriesInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutUserInput
    activities?: StudentActivityCreateNestedManyWithoutUserInput
    streak?: LearningStreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionCreateNestedManyWithoutUserInput
    mockExams?: MockExamCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTopicMasteriesInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    role?: $Enums.UserRole
    banned?: boolean | null
    banReason?: string | null
    banExpires?: Date | string | null
    isOnboarded?: boolean
    gradeLevel?: number | null
    age?: number | null
    school?: string | null
    subjects?: UserCreatesubjectsInput | string[]
    learningGoals?: UserCreatelearningGoalsInput | string[]
    learningStyle?: $Enums.LearningStyle
    difficultyLevel?: $Enums.DifficultyLevel
    sessionDuration?: number | null
    interests?: UserCreateinterestsInput | string[]
    pastEngagement?: number | null
    isInterestedInSATPrep?: boolean | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutUserInput
    activities?: StudentActivityUncheckedCreateNestedManyWithoutUserInput
    streak?: LearningStreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    chatSessions?: ChatSessionUncheckedCreateNestedManyWithoutUserInput
    satStudyPlans?: SATStudyPlanUncheckedCreateNestedManyWithoutUserInput
    satPracticeSessions?: SATPracticeSessionUncheckedCreateNestedManyWithoutUserInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedCreateNestedManyWithoutUserInput
    generatedQuestions?: QuestionUncheckedCreateNestedManyWithoutUserInput
    mockExams?: MockExamUncheckedCreateNestedManyWithoutUserInput
    mockAttempts?: MockAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTopicMasteriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTopicMasteriesInput, UserUncheckedCreateWithoutTopicMasteriesInput>
  }

  export type UserUpsertWithoutTopicMasteriesInput = {
    update: XOR<UserUpdateWithoutTopicMasteriesInput, UserUncheckedUpdateWithoutTopicMasteriesInput>
    create: XOR<UserCreateWithoutTopicMasteriesInput, UserUncheckedCreateWithoutTopicMasteriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTopicMasteriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTopicMasteriesInput, UserUncheckedUpdateWithoutTopicMasteriesInput>
  }

  export type UserUpdateWithoutTopicMasteriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTopicMasteriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    banReason?: NullableStringFieldUpdateOperationsInput | string | null
    banExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isOnboarded?: BoolFieldUpdateOperationsInput | boolean
    gradeLevel?: NullableIntFieldUpdateOperationsInput | number | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: UserUpdatesubjectsInput | string[]
    learningGoals?: UserUpdatelearningGoalsInput | string[]
    learningStyle?: EnumLearningStyleFieldUpdateOperationsInput | $Enums.LearningStyle
    difficultyLevel?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    sessionDuration?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: UserUpdateinterestsInput | string[]
    pastEngagement?: NullableFloatFieldUpdateOperationsInput | number | null
    isInterestedInSATPrep?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    activities?: StudentActivityUncheckedUpdateManyWithoutUserNestedInput
    streak?: LearningStreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    chatSessions?: ChatSessionUncheckedUpdateManyWithoutUserNestedInput
    satStudyPlans?: SATStudyPlanUncheckedUpdateManyWithoutUserNestedInput
    satPracticeSessions?: SATPracticeSessionUncheckedUpdateManyWithoutUserNestedInput
    satDiagnosticResults?: SATDiagnosticResultUncheckedUpdateManyWithoutUserNestedInput
    generatedQuestions?: QuestionUncheckedUpdateManyWithoutUserNestedInput
    mockExams?: MockExamUncheckedUpdateManyWithoutUserNestedInput
    mockAttempts?: MockAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionCreateManyUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt: Date | string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    impersonatedBy?: string | null
  }

  export type AccountCreateManyUserInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
  }

  export type PostCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    content: string
  }

  export type StudentActivityCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    type: $Enums.ActivityType
    subject?: string | null
    topic?: string | null
    duration?: number | null
    score?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AchievementCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    title: string
    description: string
    icon: string
    category: $Enums.AchievementCategory
    progress?: number
    completed?: boolean
  }

  export type ChatSessionCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title?: string | null
    topic?: string | null
    isActive?: boolean
  }

  export type SATStudyPlanCreateManyUserInput = {
    id?: string
    timeline: string
    focusAreas: JsonNullValueInput | InputJsonValue
    weeklySchedule: JsonNullValueInput | InputJsonValue
    resourceRecommendations: JsonNullValueInput | InputJsonValue
    aiGeneratedPlan?: NullableJsonNullValueInput | InputJsonValue
    completedWeeks?: SATStudyPlanCreatecompletedWeeksInput | number[]
    completedTasks?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SATPracticeSessionCreateManyUserInput = {
    id?: string
    section: string
    score?: number | null
    maxScore?: number | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    timeSpent?: number | null
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SATDiagnosticResultCreateManyUserInput = {
    id?: string
    mathScore?: number | null
    readingScore?: number | null
    writingScore?: number | null
    totalScore?: number | null
    strengths?: NullableJsonNullValueInput | InputJsonValue
    weaknesses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type QuestionCreateManyUserInput = {
    id?: string
    topic: string
    subject: string
    difficulty: string
    question: string
    choices: JsonNullValueInput | InputJsonValue
    answer: string
    explanation: string
    source?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MockExamCreateManyUserInput = {
    id?: string
    goal: string
    grade: number
    sections: JsonNullValueInput | InputJsonValue
    totalTime: number
    createdAt?: Date | string
  }

  export type MockAttemptCreateManyUserInput = {
    id?: string
    mockExamId: string
    answers: JsonNullValueInput | InputJsonValue
    scored: JsonNullValueInput | InputJsonValue
    summary: JsonNullValueInput | InputJsonValue
    startedAt: Date | string
    finishedAt: Date | string
    createdAt?: Date | string
  }

  export type TopicMasteryCreateManyUserInput = {
    id?: string
    topic: string
    correct?: number
    total?: number
    lastSeenAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    impersonatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type PostUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type PostUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type StudentActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StudentActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StudentActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    progress?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChatSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    messages?: ChatMessageUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    messages?: ChatMessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ChatSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SATStudyPlanUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    focusAreas?: JsonNullValueInput | InputJsonValue
    weeklySchedule?: JsonNullValueInput | InputJsonValue
    resourceRecommendations?: JsonNullValueInput | InputJsonValue
    aiGeneratedPlan?: NullableJsonNullValueInput | InputJsonValue
    completedWeeks?: SATStudyPlanUpdatecompletedWeeksInput | number[]
    completedTasks?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATStudyPlanUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    focusAreas?: JsonNullValueInput | InputJsonValue
    weeklySchedule?: JsonNullValueInput | InputJsonValue
    resourceRecommendations?: JsonNullValueInput | InputJsonValue
    aiGeneratedPlan?: NullableJsonNullValueInput | InputJsonValue
    completedWeeks?: SATStudyPlanUpdatecompletedWeeksInput | number[]
    completedTasks?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATStudyPlanUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeline?: StringFieldUpdateOperationsInput | string
    focusAreas?: JsonNullValueInput | InputJsonValue
    weeklySchedule?: JsonNullValueInput | InputJsonValue
    resourceRecommendations?: JsonNullValueInput | InputJsonValue
    aiGeneratedPlan?: NullableJsonNullValueInput | InputJsonValue
    completedWeeks?: SATStudyPlanUpdatecompletedWeeksInput | number[]
    completedTasks?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATPracticeSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATPracticeSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATPracticeSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    score?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: NullableIntFieldUpdateOperationsInput | number | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATDiagnosticResultUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mathScore?: NullableIntFieldUpdateOperationsInput | number | null
    readingScore?: NullableIntFieldUpdateOperationsInput | number | null
    writingScore?: NullableIntFieldUpdateOperationsInput | number | null
    totalScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableJsonNullValueInput | InputJsonValue
    weaknesses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATDiagnosticResultUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mathScore?: NullableIntFieldUpdateOperationsInput | number | null
    readingScore?: NullableIntFieldUpdateOperationsInput | number | null
    writingScore?: NullableIntFieldUpdateOperationsInput | number | null
    totalScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableJsonNullValueInput | InputJsonValue
    weaknesses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SATDiagnosticResultUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mathScore?: NullableIntFieldUpdateOperationsInput | number | null
    readingScore?: NullableIntFieldUpdateOperationsInput | number | null
    writingScore?: NullableIntFieldUpdateOperationsInput | number | null
    totalScore?: NullableIntFieldUpdateOperationsInput | number | null
    strengths?: NullableJsonNullValueInput | InputJsonValue
    weaknesses?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    choices?: JsonNullValueInput | InputJsonValue
    answer?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    choices?: JsonNullValueInput | InputJsonValue
    answer?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    choices?: JsonNullValueInput | InputJsonValue
    answer?: StringFieldUpdateOperationsInput | string
    explanation?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockExamUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    totalTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: MockAttemptUpdateManyWithoutMockExamNestedInput
  }

  export type MockExamUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    totalTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: MockAttemptUncheckedUpdateManyWithoutMockExamNestedInput
  }

  export type MockExamUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    goal?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    totalTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockAttemptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    scored?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mockExam?: MockExamUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type MockAttemptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mockExamId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    scored?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mockExamId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    scored?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicMasteryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    correct?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicMasteryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    correct?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicMasteryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    correct?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManySessionInput = {
    id?: string
    createdAt?: Date | string
    content: string
    type: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    keywords?: ChatMessageCreatekeywordsInput | string[]
  }

  export type ChatMessageUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    keywords?: ChatMessageUpdatekeywordsInput | string[]
  }

  export type ChatMessageUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    keywords?: ChatMessageUpdatekeywordsInput | string[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    links?: NullableJsonNullValueInput | InputJsonValue
    keywords?: ChatMessageUpdatekeywordsInput | string[]
  }

  export type MockAttemptCreateManyMockExamInput = {
    id?: string
    userId: string
    answers: JsonNullValueInput | InputJsonValue
    scored: JsonNullValueInput | InputJsonValue
    summary: JsonNullValueInput | InputJsonValue
    startedAt: Date | string
    finishedAt: Date | string
    createdAt?: Date | string
  }

  export type MockAttemptUpdateWithoutMockExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    scored?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMockAttemptsNestedInput
  }

  export type MockAttemptUncheckedUpdateWithoutMockExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    scored?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MockAttemptUncheckedUpdateManyWithoutMockExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: JsonNullValueInput | InputJsonValue
    scored?: JsonNullValueInput | InputJsonValue
    summary?: JsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    finishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}